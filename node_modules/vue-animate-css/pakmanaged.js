var global = Function("return this;")();
/*!
  * Ender: open module JavaScript framework (client-lib)
  * copyright Dustin Diaz & Jacob Thornton 2011 (@ded @fat)
  * http://ender.no.de
  * License MIT
  */
!function (context) {

  // a global object for node.js module compatiblity
  // ============================================

  context['global'] = context

  // Implements simple module system
  // losely based on CommonJS Modules spec v1.1.1
  // ============================================

  var modules = {}
    , old = context.$

  function require (identifier) {
    // modules can be required from ender's build system, or found on the window
    var module = modules[identifier] || window[identifier]
    if (!module) throw new Error("Requested module '" + identifier + "' has not been defined.")
    return module
  }

  function provide (name, what) {
    return (modules[name] = what)
  }

  context['provide'] = provide
  context['require'] = require

  function aug(o, o2) {
    for (var k in o2) k != 'noConflict' && k != '_VERSION' && (o[k] = o2[k])
    return o
  }

  function boosh(s, r, els) {
    // string || node || nodelist || window
    if (typeof s == 'string' || s.nodeName || (s.length && 'item' in s) || s == window) {
      els = ender._select(s, r)
      els.selector = s
    } else els = isFinite(s.length) ? s : [s]
    return aug(els, boosh)
  }

  function ender(s, r) {
    return boosh(s, r)
  }

  aug(ender, {
      _VERSION: '0.3.6'
    , fn: boosh // for easy compat to jQuery plugins
    , ender: function (o, chain) {
        aug(chain ? boosh : ender, o)
      }
    , _select: function (s, r) {
        return (r || document).querySelectorAll(s)
      }
  })

  aug(boosh, {
    forEach: function (fn, scope, i) {
      // opt out of native forEach so we can intentionally call our own scope
      // defaulting to the current item and be able to return self
      for (i = 0, l = this.length; i < l; ++i) i in this && fn.call(scope || this[i], this[i], i, this)
      // return self for chaining
      return this
    },
    $: ender // handy reference to self
  })

  ender.noConflict = function () {
    context.$ = old
    return this
  }

  if (typeof module !== 'undefined' && module.exports) module.exports = ender
  // use subscript notation as extern for Closure compilation
  context['ender'] = context['$'] = context['ender'] || ender

}(this);
// pakmanager:amdefine
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /** vim: et:ts=4:sw=4:sts=4
     * @license amdefine 1.0.0 Copyright (c) 2011-2015, The Dojo Foundation All Rights Reserved.
     * Available via the MIT or new BSD license.
     * see: http://github.com/jrburke/amdefine for details
     */
    
    /*jslint node: true */
    /*global module, process */
    'use strict';
    
    /**
     * Creates a define for node.
     * @param {Object} module the "module" object that is defined by Node for the
     * current module.
     * @param {Function} [requireFn]. Node's require function for the current module.
     * It only needs to be passed in Node versions before 0.5, when module.require
     * did not exist.
     * @returns {Function} a define function that is usable for the current node
     * module.
     */
    function amdefine(module, requireFn) {
        'use strict';
        var defineCache = {},
            loaderCache = {},
            alreadyCalled = false,
            path = require('path'),
            makeRequire, stringRequire;
    
        /**
         * Trims the . and .. from an array of path segments.
         * It will keep a leading path segment if a .. will become
         * the first path segment, to help with module name lookups,
         * which act like paths, but can be remapped. But the end result,
         * all paths that use this function should look normalized.
         * NOTE: this method MODIFIES the input array.
         * @param {Array} ary the array of path segments.
         */
        function trimDots(ary) {
            var i, part;
            for (i = 0; ary[i]; i+= 1) {
                part = ary[i];
                if (part === '.') {
                    ary.splice(i, 1);
                    i -= 1;
                } else if (part === '..') {
                    if (i === 1 && (ary[2] === '..' || ary[0] === '..')) {
                        //End of the line. Keep at least one non-dot
                        //path segment at the front so it can be mapped
                        //correctly to disk. Otherwise, there is likely
                        //no path mapping for a path starting with '..'.
                        //This can still fail, but catches the most reasonable
                        //uses of ..
                        break;
                    } else if (i > 0) {
                        ary.splice(i - 1, 2);
                        i -= 2;
                    }
                }
            }
        }
    
        function normalize(name, baseName) {
            var baseParts;
    
            //Adjust any relative paths.
            if (name && name.charAt(0) === '.') {
                //If have a base name, try to normalize against it,
                //otherwise, assume it is a top-level require that will
                //be relative to baseUrl in the end.
                if (baseName) {
                    baseParts = baseName.split('/');
                    baseParts = baseParts.slice(0, baseParts.length - 1);
                    baseParts = baseParts.concat(name.split('/'));
                    trimDots(baseParts);
                    name = baseParts.join('/');
                }
            }
    
            return name;
        }
    
        /**
         * Create the normalize() function passed to a loader plugin's
         * normalize method.
         */
        function makeNormalize(relName) {
            return function (name) {
                return normalize(name, relName);
            };
        }
    
        function makeLoad(id) {
            function load(value) {
                loaderCache[id] = value;
            }
    
            load.fromText = function (id, text) {
                //This one is difficult because the text can/probably uses
                //define, and any relative paths and requires should be relative
                //to that id was it would be found on disk. But this would require
                //bootstrapping a module/require fairly deeply from node core.
                //Not sure how best to go about that yet.
                throw new Error('amdefine does not implement load.fromText');
            };
    
            return load;
        }
    
        makeRequire = function (systemRequire, exports, module, relId) {
            function amdRequire(deps, callback) {
                if (typeof deps === 'string') {
                    //Synchronous, single module require('')
                    return stringRequire(systemRequire, exports, module, deps, relId);
                } else {
                    //Array of dependencies with a callback.
    
                    //Convert the dependencies to modules.
                    deps = deps.map(function (depName) {
                        return stringRequire(systemRequire, exports, module, depName, relId);
                    });
    
                    //Wait for next tick to call back the require call.
                    if (callback) {
                        process.nextTick(function () {
                            callback.apply(null, deps);
                        });
                    }
                }
            }
    
            amdRequire.toUrl = function (filePath) {
                if (filePath.indexOf('.') === 0) {
                    return normalize(filePath, path.dirname(module.filename));
                } else {
                    return filePath;
                }
            };
    
            return amdRequire;
        };
    
        //Favor explicit value, passed in if the module wants to support Node 0.4.
        requireFn = requireFn || function req() {
            return module.require.apply(module, arguments);
        };
    
        function runFactory(id, deps, factory) {
            var r, e, m, result;
    
            if (id) {
                e = loaderCache[id] = {};
                m = {
                    id: id,
                    uri: __filename,
                    exports: e
                };
                r = makeRequire(requireFn, e, m, id);
            } else {
                //Only support one define call per file
                if (alreadyCalled) {
                    throw new Error('amdefine with no module ID cannot be called more than once per file.');
                }
                alreadyCalled = true;
    
                //Use the real variables from node
                //Use module.exports for exports, since
                //the exports in here is amdefine exports.
                e = module.exports;
                m = module;
                r = makeRequire(requireFn, e, m, module.id);
            }
    
            //If there are dependencies, they are strings, so need
            //to convert them to dependency values.
            if (deps) {
                deps = deps.map(function (depName) {
                    return r(depName);
                });
            }
    
            //Call the factory with the right dependencies.
            if (typeof factory === 'function') {
                result = factory.apply(m.exports, deps);
            } else {
                result = factory;
            }
    
            if (result !== undefined) {
                m.exports = result;
                if (id) {
                    loaderCache[id] = m.exports;
                }
            }
        }
    
        stringRequire = function (systemRequire, exports, module, id, relId) {
            //Split the ID by a ! so that
            var index = id.indexOf('!'),
                originalId = id,
                prefix, plugin;
    
            if (index === -1) {
                id = normalize(id, relId);
    
                //Straight module lookup. If it is one of the special dependencies,
                //deal with it, otherwise, delegate to node.
                if (id === 'require') {
                    return makeRequire(systemRequire, exports, module, relId);
                } else if (id === 'exports') {
                    return exports;
                } else if (id === 'module') {
                    return module;
                } else if (loaderCache.hasOwnProperty(id)) {
                    return loaderCache[id];
                } else if (defineCache[id]) {
                    runFactory.apply(null, defineCache[id]);
                    return loaderCache[id];
                } else {
                    if(systemRequire) {
                        return systemRequire(originalId);
                    } else {
                        throw new Error('No module with ID: ' + id);
                    }
                }
            } else {
                //There is a plugin in play.
                prefix = id.substring(0, index);
                id = id.substring(index + 1, id.length);
    
                plugin = stringRequire(systemRequire, exports, module, prefix, relId);
    
                if (plugin.normalize) {
                    id = plugin.normalize(id, makeNormalize(relId));
                } else {
                    //Normalize the ID normally.
                    id = normalize(id, relId);
                }
    
                if (loaderCache[id]) {
                    return loaderCache[id];
                } else {
                    plugin.load(id, makeRequire(systemRequire, exports, module, relId), makeLoad(id), {});
    
                    return loaderCache[id];
                }
            }
        };
    
        //Create a define function specific to the module asking for amdefine.
        function define(id, deps, factory) {
            if (Array.isArray(id)) {
                factory = deps;
                deps = id;
                id = undefined;
            } else if (typeof id !== 'string') {
                factory = id;
                id = deps = undefined;
            }
    
            if (deps && !Array.isArray(deps)) {
                factory = deps;
                deps = undefined;
            }
    
            if (!deps) {
                deps = ['require', 'exports', 'module'];
            }
    
            //Set up properties for this module. If an ID, then use
            //internal cache. If no ID, then use the external variables
            //for this node module.
            if (id) {
                //Put the module in deep freeze until there is a
                //require call for it.
                defineCache[id] = [id, deps, factory];
            } else {
                runFactory(id, deps, factory);
            }
        }
    
        //define.require, which has access to all the values in the
        //cache. Useful for AMD modules that all have IDs in the file,
        //but need to finally export a value to node based on one of those
        //IDs.
        define.require = function (id) {
            if (loaderCache[id]) {
                return loaderCache[id];
            }
    
            if (defineCache[id]) {
                runFactory.apply(null, defineCache[id]);
                return loaderCache[id];
            }
        };
    
        define.amd = {};
    
        return define;
    }
    
    module.exports = amdefine;
    
  provide("amdefine", module.exports);
}(global));

// pakmanager:base62
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  var Base62 = (function (my) {
      my.chars = ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z", "A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z"]
    
      my.encode = function(i){
        if (i === 0) {return '0'}
        var s = ''
        while (i > 0) {
          s = this.chars[i % 62] + s
          i = Math.floor(i/62)
        }
        return s
      };
      my.decode = function(a,b,c,d){
        for (
          b = c = (
            a === (/\W|_|^$/.test(a += "") || a)
          ) - 1;
          d = a.charCodeAt(c++);
        )
        b = b * 62 + d - [, 48, 29, 87][d >> 5];
        return b
      };
    
      return my;
    }({}));
    
    module.exports = Base62
  provide("base62", module.exports);
}(global));

// pakmanager:esprima-fb
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /*
      Copyright (C) 2013 Ariya Hidayat <ariya.hidayat@gmail.com>
      Copyright (C) 2013 Thaddee Tyl <thaddee.tyl@gmail.com>
      Copyright (C) 2012 Ariya Hidayat <ariya.hidayat@gmail.com>
      Copyright (C) 2012 Mathias Bynens <mathias@qiwi.be>
      Copyright (C) 2012 Joost-Wim Boekesteijn <joost-wim@boekesteijn.nl>
      Copyright (C) 2012 Kris Kowal <kris.kowal@cixar.com>
      Copyright (C) 2012 Yusuke Suzuki <utatane.tea@gmail.com>
      Copyright (C) 2012 Arpad Borsos <arpad.borsos@googlemail.com>
      Copyright (C) 2011 Ariya Hidayat <ariya.hidayat@gmail.com>
    
      Redistribution and use in source and binary forms, with or without
      modification, are permitted provided that the following conditions are met:
    
        * Redistributions of source code must retain the above copyright
          notice, this list of conditions and the following disclaimer.
        * Redistributions in binary form must reproduce the above copyright
          notice, this list of conditions and the following disclaimer in the
          documentation and/or other materials provided with the distribution.
    
      THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
      AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
      IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
      ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
      DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
      (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
      LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
      ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
      (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
      THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
    */
    
    (function (root, factory) {
        'use strict';
    
        // Universal Module Definition (UMD) to support AMD, CommonJS/Node.js,
        // Rhino, and plain browser loading.
    
        /* istanbul ignore next */
        if (typeof define === 'function' && define.amd) {
            define(['exports'], factory);
        } else if (typeof exports !== 'undefined') {
            factory(exports);
        } else {
            factory((root.esprima = {}));
        }
    }(this, function (exports) {
        'use strict';
    
        var Token,
            TokenName,
            FnExprTokens,
            Syntax,
            PropertyKind,
            Messages,
            Regex,
            SyntaxTreeDelegate,
            XHTMLEntities,
            ClassPropertyType,
            source,
            strict,
            index,
            lineNumber,
            lineStart,
            length,
            delegate,
            lookahead,
            state,
            extra;
    
        Token = {
            BooleanLiteral: 1,
            EOF: 2,
            Identifier: 3,
            Keyword: 4,
            NullLiteral: 5,
            NumericLiteral: 6,
            Punctuator: 7,
            StringLiteral: 8,
            RegularExpression: 9,
            Template: 10,
            JSXIdentifier: 11,
            JSXText: 12
        };
    
        TokenName = {};
        TokenName[Token.BooleanLiteral] = 'Boolean';
        TokenName[Token.EOF] = '<end>';
        TokenName[Token.Identifier] = 'Identifier';
        TokenName[Token.Keyword] = 'Keyword';
        TokenName[Token.NullLiteral] = 'Null';
        TokenName[Token.NumericLiteral] = 'Numeric';
        TokenName[Token.Punctuator] = 'Punctuator';
        TokenName[Token.StringLiteral] = 'String';
        TokenName[Token.JSXIdentifier] = 'JSXIdentifier';
        TokenName[Token.JSXText] = 'JSXText';
        TokenName[Token.RegularExpression] = 'RegularExpression';
    
        // A function following one of those tokens is an expression.
        FnExprTokens = ['(', '{', '[', 'in', 'typeof', 'instanceof', 'new',
                        'return', 'case', 'delete', 'throw', 'void',
                        // assignment operators
                        '=', '+=', '-=', '*=', '/=', '%=', '<<=', '>>=', '>>>=',
                        '&=', '|=', '^=', ',',
                        // binary/unary operators
                        '+', '-', '*', '/', '%', '++', '--', '<<', '>>', '>>>', '&',
                        '|', '^', '!', '~', '&&', '||', '?', ':', '===', '==', '>=',
                        '<=', '<', '>', '!=', '!=='];
    
        Syntax = {
            AnyTypeAnnotation: 'AnyTypeAnnotation',
            ArrayExpression: 'ArrayExpression',
            ArrayPattern: 'ArrayPattern',
            ArrayTypeAnnotation: 'ArrayTypeAnnotation',
            ArrowFunctionExpression: 'ArrowFunctionExpression',
            AssignmentExpression: 'AssignmentExpression',
            BinaryExpression: 'BinaryExpression',
            BlockStatement: 'BlockStatement',
            BooleanTypeAnnotation: 'BooleanTypeAnnotation',
            BreakStatement: 'BreakStatement',
            CallExpression: 'CallExpression',
            CatchClause: 'CatchClause',
            ClassBody: 'ClassBody',
            ClassDeclaration: 'ClassDeclaration',
            ClassExpression: 'ClassExpression',
            ClassImplements: 'ClassImplements',
            ClassProperty: 'ClassProperty',
            ComprehensionBlock: 'ComprehensionBlock',
            ComprehensionExpression: 'ComprehensionExpression',
            ConditionalExpression: 'ConditionalExpression',
            ContinueStatement: 'ContinueStatement',
            DebuggerStatement: 'DebuggerStatement',
            DeclareClass: 'DeclareClass',
            DeclareFunction: 'DeclareFunction',
            DeclareModule: 'DeclareModule',
            DeclareVariable: 'DeclareVariable',
            DoWhileStatement: 'DoWhileStatement',
            EmptyStatement: 'EmptyStatement',
            ExportDeclaration: 'ExportDeclaration',
            ExportBatchSpecifier: 'ExportBatchSpecifier',
            ExportSpecifier: 'ExportSpecifier',
            ExpressionStatement: 'ExpressionStatement',
            ForInStatement: 'ForInStatement',
            ForOfStatement: 'ForOfStatement',
            ForStatement: 'ForStatement',
            FunctionDeclaration: 'FunctionDeclaration',
            FunctionExpression: 'FunctionExpression',
            FunctionTypeAnnotation: 'FunctionTypeAnnotation',
            FunctionTypeParam: 'FunctionTypeParam',
            GenericTypeAnnotation: 'GenericTypeAnnotation',
            Identifier: 'Identifier',
            IfStatement: 'IfStatement',
            ImportDeclaration: 'ImportDeclaration',
            ImportDefaultSpecifier: 'ImportDefaultSpecifier',
            ImportNamespaceSpecifier: 'ImportNamespaceSpecifier',
            ImportSpecifier: 'ImportSpecifier',
            InterfaceDeclaration: 'InterfaceDeclaration',
            InterfaceExtends: 'InterfaceExtends',
            IntersectionTypeAnnotation: 'IntersectionTypeAnnotation',
            LabeledStatement: 'LabeledStatement',
            Literal: 'Literal',
            LogicalExpression: 'LogicalExpression',
            MemberExpression: 'MemberExpression',
            MethodDefinition: 'MethodDefinition',
            ModuleSpecifier: 'ModuleSpecifier',
            NewExpression: 'NewExpression',
            NullableTypeAnnotation: 'NullableTypeAnnotation',
            NumberTypeAnnotation: 'NumberTypeAnnotation',
            ObjectExpression: 'ObjectExpression',
            ObjectPattern: 'ObjectPattern',
            ObjectTypeAnnotation: 'ObjectTypeAnnotation',
            ObjectTypeCallProperty: 'ObjectTypeCallProperty',
            ObjectTypeIndexer: 'ObjectTypeIndexer',
            ObjectTypeProperty: 'ObjectTypeProperty',
            Program: 'Program',
            Property: 'Property',
            QualifiedTypeIdentifier: 'QualifiedTypeIdentifier',
            ReturnStatement: 'ReturnStatement',
            SequenceExpression: 'SequenceExpression',
            SpreadElement: 'SpreadElement',
            SpreadProperty: 'SpreadProperty',
            StringLiteralTypeAnnotation: 'StringLiteralTypeAnnotation',
            StringTypeAnnotation: 'StringTypeAnnotation',
            SwitchCase: 'SwitchCase',
            SwitchStatement: 'SwitchStatement',
            TaggedTemplateExpression: 'TaggedTemplateExpression',
            TemplateElement: 'TemplateElement',
            TemplateLiteral: 'TemplateLiteral',
            ThisExpression: 'ThisExpression',
            ThrowStatement: 'ThrowStatement',
            TupleTypeAnnotation: 'TupleTypeAnnotation',
            TryStatement: 'TryStatement',
            TypeAlias: 'TypeAlias',
            TypeAnnotation: 'TypeAnnotation',
            TypeCastExpression: 'TypeCastExpression',
            TypeofTypeAnnotation: 'TypeofTypeAnnotation',
            TypeParameterDeclaration: 'TypeParameterDeclaration',
            TypeParameterInstantiation: 'TypeParameterInstantiation',
            UnaryExpression: 'UnaryExpression',
            UnionTypeAnnotation: 'UnionTypeAnnotation',
            UpdateExpression: 'UpdateExpression',
            VariableDeclaration: 'VariableDeclaration',
            VariableDeclarator: 'VariableDeclarator',
            VoidTypeAnnotation: 'VoidTypeAnnotation',
            WhileStatement: 'WhileStatement',
            WithStatement: 'WithStatement',
            JSXIdentifier: 'JSXIdentifier',
            JSXNamespacedName: 'JSXNamespacedName',
            JSXMemberExpression: 'JSXMemberExpression',
            JSXEmptyExpression: 'JSXEmptyExpression',
            JSXExpressionContainer: 'JSXExpressionContainer',
            JSXElement: 'JSXElement',
            JSXClosingElement: 'JSXClosingElement',
            JSXOpeningElement: 'JSXOpeningElement',
            JSXAttribute: 'JSXAttribute',
            JSXSpreadAttribute: 'JSXSpreadAttribute',
            JSXText: 'JSXText',
            YieldExpression: 'YieldExpression',
            AwaitExpression: 'AwaitExpression'
        };
    
        PropertyKind = {
            Data: 1,
            Get: 2,
            Set: 4
        };
    
        ClassPropertyType = {
            'static': 'static',
            prototype: 'prototype'
        };
    
        // Error messages should be identical to V8.
        Messages = {
            UnexpectedToken: 'Unexpected token %0',
            UnexpectedNumber: 'Unexpected number',
            UnexpectedString: 'Unexpected string',
            UnexpectedIdentifier: 'Unexpected identifier',
            UnexpectedReserved: 'Unexpected reserved word',
            UnexpectedTemplate: 'Unexpected quasi %0',
            UnexpectedEOS: 'Unexpected end of input',
            NewlineAfterThrow: 'Illegal newline after throw',
            InvalidRegExp: 'Invalid regular expression',
            UnterminatedRegExp: 'Invalid regular expression: missing /',
            InvalidLHSInAssignment: 'Invalid left-hand side in assignment',
            InvalidLHSInFormalsList: 'Invalid left-hand side in formals list',
            InvalidLHSInForIn: 'Invalid left-hand side in for-in',
            MultipleDefaultsInSwitch: 'More than one default clause in switch statement',
            NoCatchOrFinally: 'Missing catch or finally after try',
            UnknownLabel: 'Undefined label \'%0\'',
            Redeclaration: '%0 \'%1\' has already been declared',
            IllegalContinue: 'Illegal continue statement',
            IllegalBreak: 'Illegal break statement',
            IllegalDuplicateClassProperty: 'Illegal duplicate property in class definition',
            IllegalClassConstructorProperty: 'Illegal constructor property in class definition',
            IllegalReturn: 'Illegal return statement',
            IllegalSpread: 'Illegal spread element',
            StrictModeWith: 'Strict mode code may not include a with statement',
            StrictCatchVariable: 'Catch variable may not be eval or arguments in strict mode',
            StrictVarName: 'Variable name may not be eval or arguments in strict mode',
            StrictParamName: 'Parameter name eval or arguments is not allowed in strict mode',
            StrictParamDupe: 'Strict mode function may not have duplicate parameter names',
            ParameterAfterRestParameter: 'Rest parameter must be final parameter of an argument list',
            DefaultRestParameter: 'Rest parameter can not have a default value',
            ElementAfterSpreadElement: 'Spread must be the final element of an element list',
            PropertyAfterSpreadProperty: 'A rest property must be the final property of an object literal',
            ObjectPatternAsRestParameter: 'Invalid rest parameter',
            ObjectPatternAsSpread: 'Invalid spread argument',
            StrictFunctionName: 'Function name may not be eval or arguments in strict mode',
            StrictOctalLiteral: 'Octal literals are not allowed in strict mode.',
            StrictDelete: 'Delete of an unqualified identifier in strict mode.',
            StrictDuplicateProperty: 'Duplicate data property in object literal not allowed in strict mode',
            AccessorDataProperty: 'Object literal may not have data and accessor property with the same name',
            AccessorGetSet: 'Object literal may not have multiple get/set accessors with the same name',
            StrictLHSAssignment: 'Assignment to eval or arguments is not allowed in strict mode',
            StrictLHSPostfix: 'Postfix increment/decrement may not have eval or arguments operand in strict mode',
            StrictLHSPrefix: 'Prefix increment/decrement may not have eval or arguments operand in strict mode',
            StrictReservedWord: 'Use of future reserved word in strict mode',
            MissingFromClause: 'Missing from clause',
            NoAsAfterImportNamespace: 'Missing as after import *',
            InvalidModuleSpecifier: 'Invalid module specifier',
            IllegalImportDeclaration: 'Illegal import declaration',
            IllegalExportDeclaration: 'Illegal export declaration',
            NoUninitializedConst: 'Const must be initialized',
            ComprehensionRequiresBlock: 'Comprehension must have at least one block',
            ComprehensionError: 'Comprehension Error',
            EachNotAllowed: 'Each is not supported',
            InvalidJSXAttributeValue: 'JSX value should be either an expression or a quoted JSX text',
            ExpectedJSXClosingTag: 'Expected corresponding JSX closing tag for %0',
            AdjacentJSXElements: 'Adjacent JSX elements must be wrapped in an enclosing tag',
            ConfusedAboutFunctionType: 'Unexpected token =>. It looks like ' +
                'you are trying to write a function type, but you ended up ' +
                'writing a grouped type followed by an =>, which is a syntax ' +
                'error. Remember, function type parameters are named so function ' +
                'types look like (name1: type1, name2: type2) => returnType. You ' +
                'probably wrote (type1) => returnType'
        };
    
        // See also tools/generate-unicode-regex.py.
        Regex = {
            NonAsciiIdentifierStart: new RegExp('[\xaa\xb5\xba\xc0-\xd6\xd8-\xf6\xf8-\u02c1\u02c6-\u02d1\u02e0-\u02e4\u02ec\u02ee\u0370-\u0374\u0376\u0377\u037a-\u037d\u0386\u0388-\u038a\u038c\u038e-\u03a1\u03a3-\u03f5\u03f7-\u0481\u048a-\u0527\u0531-\u0556\u0559\u0561-\u0587\u05d0-\u05ea\u05f0-\u05f2\u0620-\u064a\u066e\u066f\u0671-\u06d3\u06d5\u06e5\u06e6\u06ee\u06ef\u06fa-\u06fc\u06ff\u0710\u0712-\u072f\u074d-\u07a5\u07b1\u07ca-\u07ea\u07f4\u07f5\u07fa\u0800-\u0815\u081a\u0824\u0828\u0840-\u0858\u08a0\u08a2-\u08ac\u0904-\u0939\u093d\u0950\u0958-\u0961\u0971-\u0977\u0979-\u097f\u0985-\u098c\u098f\u0990\u0993-\u09a8\u09aa-\u09b0\u09b2\u09b6-\u09b9\u09bd\u09ce\u09dc\u09dd\u09df-\u09e1\u09f0\u09f1\u0a05-\u0a0a\u0a0f\u0a10\u0a13-\u0a28\u0a2a-\u0a30\u0a32\u0a33\u0a35\u0a36\u0a38\u0a39\u0a59-\u0a5c\u0a5e\u0a72-\u0a74\u0a85-\u0a8d\u0a8f-\u0a91\u0a93-\u0aa8\u0aaa-\u0ab0\u0ab2\u0ab3\u0ab5-\u0ab9\u0abd\u0ad0\u0ae0\u0ae1\u0b05-\u0b0c\u0b0f\u0b10\u0b13-\u0b28\u0b2a-\u0b30\u0b32\u0b33\u0b35-\u0b39\u0b3d\u0b5c\u0b5d\u0b5f-\u0b61\u0b71\u0b83\u0b85-\u0b8a\u0b8e-\u0b90\u0b92-\u0b95\u0b99\u0b9a\u0b9c\u0b9e\u0b9f\u0ba3\u0ba4\u0ba8-\u0baa\u0bae-\u0bb9\u0bd0\u0c05-\u0c0c\u0c0e-\u0c10\u0c12-\u0c28\u0c2a-\u0c33\u0c35-\u0c39\u0c3d\u0c58\u0c59\u0c60\u0c61\u0c85-\u0c8c\u0c8e-\u0c90\u0c92-\u0ca8\u0caa-\u0cb3\u0cb5-\u0cb9\u0cbd\u0cde\u0ce0\u0ce1\u0cf1\u0cf2\u0d05-\u0d0c\u0d0e-\u0d10\u0d12-\u0d3a\u0d3d\u0d4e\u0d60\u0d61\u0d7a-\u0d7f\u0d85-\u0d96\u0d9a-\u0db1\u0db3-\u0dbb\u0dbd\u0dc0-\u0dc6\u0e01-\u0e30\u0e32\u0e33\u0e40-\u0e46\u0e81\u0e82\u0e84\u0e87\u0e88\u0e8a\u0e8d\u0e94-\u0e97\u0e99-\u0e9f\u0ea1-\u0ea3\u0ea5\u0ea7\u0eaa\u0eab\u0ead-\u0eb0\u0eb2\u0eb3\u0ebd\u0ec0-\u0ec4\u0ec6\u0edc-\u0edf\u0f00\u0f40-\u0f47\u0f49-\u0f6c\u0f88-\u0f8c\u1000-\u102a\u103f\u1050-\u1055\u105a-\u105d\u1061\u1065\u1066\u106e-\u1070\u1075-\u1081\u108e\u10a0-\u10c5\u10c7\u10cd\u10d0-\u10fa\u10fc-\u1248\u124a-\u124d\u1250-\u1256\u1258\u125a-\u125d\u1260-\u1288\u128a-\u128d\u1290-\u12b0\u12b2-\u12b5\u12b8-\u12be\u12c0\u12c2-\u12c5\u12c8-\u12d6\u12d8-\u1310\u1312-\u1315\u1318-\u135a\u1380-\u138f\u13a0-\u13f4\u1401-\u166c\u166f-\u167f\u1681-\u169a\u16a0-\u16ea\u16ee-\u16f0\u1700-\u170c\u170e-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176c\u176e-\u1770\u1780-\u17b3\u17d7\u17dc\u1820-\u1877\u1880-\u18a8\u18aa\u18b0-\u18f5\u1900-\u191c\u1950-\u196d\u1970-\u1974\u1980-\u19ab\u19c1-\u19c7\u1a00-\u1a16\u1a20-\u1a54\u1aa7\u1b05-\u1b33\u1b45-\u1b4b\u1b83-\u1ba0\u1bae\u1baf\u1bba-\u1be5\u1c00-\u1c23\u1c4d-\u1c4f\u1c5a-\u1c7d\u1ce9-\u1cec\u1cee-\u1cf1\u1cf5\u1cf6\u1d00-\u1dbf\u1e00-\u1f15\u1f18-\u1f1d\u1f20-\u1f45\u1f48-\u1f4d\u1f50-\u1f57\u1f59\u1f5b\u1f5d\u1f5f-\u1f7d\u1f80-\u1fb4\u1fb6-\u1fbc\u1fbe\u1fc2-\u1fc4\u1fc6-\u1fcc\u1fd0-\u1fd3\u1fd6-\u1fdb\u1fe0-\u1fec\u1ff2-\u1ff4\u1ff6-\u1ffc\u2071\u207f\u2090-\u209c\u2102\u2107\u210a-\u2113\u2115\u2119-\u211d\u2124\u2126\u2128\u212a-\u212d\u212f-\u2139\u213c-\u213f\u2145-\u2149\u214e\u2160-\u2188\u2c00-\u2c2e\u2c30-\u2c5e\u2c60-\u2ce4\u2ceb-\u2cee\u2cf2\u2cf3\u2d00-\u2d25\u2d27\u2d2d\u2d30-\u2d67\u2d6f\u2d80-\u2d96\u2da0-\u2da6\u2da8-\u2dae\u2db0-\u2db6\u2db8-\u2dbe\u2dc0-\u2dc6\u2dc8-\u2dce\u2dd0-\u2dd6\u2dd8-\u2dde\u2e2f\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303c\u3041-\u3096\u309d-\u309f\u30a1-\u30fa\u30fc-\u30ff\u3105-\u312d\u3131-\u318e\u31a0-\u31ba\u31f0-\u31ff\u3400-\u4db5\u4e00-\u9fcc\ua000-\ua48c\ua4d0-\ua4fd\ua500-\ua60c\ua610-\ua61f\ua62a\ua62b\ua640-\ua66e\ua67f-\ua697\ua6a0-\ua6ef\ua717-\ua71f\ua722-\ua788\ua78b-\ua78e\ua790-\ua793\ua7a0-\ua7aa\ua7f8-\ua801\ua803-\ua805\ua807-\ua80a\ua80c-\ua822\ua840-\ua873\ua882-\ua8b3\ua8f2-\ua8f7\ua8fb\ua90a-\ua925\ua930-\ua946\ua960-\ua97c\ua984-\ua9b2\ua9cf\uaa00-\uaa28\uaa40-\uaa42\uaa44-\uaa4b\uaa60-\uaa76\uaa7a\uaa80-\uaaaf\uaab1\uaab5\uaab6\uaab9-\uaabd\uaac0\uaac2\uaadb-\uaadd\uaae0-\uaaea\uaaf2-\uaaf4\uab01-\uab06\uab09-\uab0e\uab11-\uab16\uab20-\uab26\uab28-\uab2e\uabc0-\uabe2\uac00-\ud7a3\ud7b0-\ud7c6\ud7cb-\ud7fb\uf900-\ufa6d\ufa70-\ufad9\ufb00-\ufb06\ufb13-\ufb17\ufb1d\ufb1f-\ufb28\ufb2a-\ufb36\ufb38-\ufb3c\ufb3e\ufb40\ufb41\ufb43\ufb44\ufb46-\ufbb1\ufbd3-\ufd3d\ufd50-\ufd8f\ufd92-\ufdc7\ufdf0-\ufdfb\ufe70-\ufe74\ufe76-\ufefc\uff21-\uff3a\uff41-\uff5a\uff66-\uffbe\uffc2-\uffc7\uffca-\uffcf\uffd2-\uffd7\uffda-\uffdc]'),
            NonAsciiIdentifierPart: new RegExp('[\xaa\xb5\xba\xc0-\xd6\xd8-\xf6\xf8-\u02c1\u02c6-\u02d1\u02e0-\u02e4\u02ec\u02ee\u0300-\u0374\u0376\u0377\u037a-\u037d\u0386\u0388-\u038a\u038c\u038e-\u03a1\u03a3-\u03f5\u03f7-\u0481\u0483-\u0487\u048a-\u0527\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u05d0-\u05ea\u05f0-\u05f2\u0610-\u061a\u0620-\u0669\u066e-\u06d3\u06d5-\u06dc\u06df-\u06e8\u06ea-\u06fc\u06ff\u0710-\u074a\u074d-\u07b1\u07c0-\u07f5\u07fa\u0800-\u082d\u0840-\u085b\u08a0\u08a2-\u08ac\u08e4-\u08fe\u0900-\u0963\u0966-\u096f\u0971-\u0977\u0979-\u097f\u0981-\u0983\u0985-\u098c\u098f\u0990\u0993-\u09a8\u09aa-\u09b0\u09b2\u09b6-\u09b9\u09bc-\u09c4\u09c7\u09c8\u09cb-\u09ce\u09d7\u09dc\u09dd\u09df-\u09e3\u09e6-\u09f1\u0a01-\u0a03\u0a05-\u0a0a\u0a0f\u0a10\u0a13-\u0a28\u0a2a-\u0a30\u0a32\u0a33\u0a35\u0a36\u0a38\u0a39\u0a3c\u0a3e-\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a59-\u0a5c\u0a5e\u0a66-\u0a75\u0a81-\u0a83\u0a85-\u0a8d\u0a8f-\u0a91\u0a93-\u0aa8\u0aaa-\u0ab0\u0ab2\u0ab3\u0ab5-\u0ab9\u0abc-\u0ac5\u0ac7-\u0ac9\u0acb-\u0acd\u0ad0\u0ae0-\u0ae3\u0ae6-\u0aef\u0b01-\u0b03\u0b05-\u0b0c\u0b0f\u0b10\u0b13-\u0b28\u0b2a-\u0b30\u0b32\u0b33\u0b35-\u0b39\u0b3c-\u0b44\u0b47\u0b48\u0b4b-\u0b4d\u0b56\u0b57\u0b5c\u0b5d\u0b5f-\u0b63\u0b66-\u0b6f\u0b71\u0b82\u0b83\u0b85-\u0b8a\u0b8e-\u0b90\u0b92-\u0b95\u0b99\u0b9a\u0b9c\u0b9e\u0b9f\u0ba3\u0ba4\u0ba8-\u0baa\u0bae-\u0bb9\u0bbe-\u0bc2\u0bc6-\u0bc8\u0bca-\u0bcd\u0bd0\u0bd7\u0be6-\u0bef\u0c01-\u0c03\u0c05-\u0c0c\u0c0e-\u0c10\u0c12-\u0c28\u0c2a-\u0c33\u0c35-\u0c39\u0c3d-\u0c44\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c58\u0c59\u0c60-\u0c63\u0c66-\u0c6f\u0c82\u0c83\u0c85-\u0c8c\u0c8e-\u0c90\u0c92-\u0ca8\u0caa-\u0cb3\u0cb5-\u0cb9\u0cbc-\u0cc4\u0cc6-\u0cc8\u0cca-\u0ccd\u0cd5\u0cd6\u0cde\u0ce0-\u0ce3\u0ce6-\u0cef\u0cf1\u0cf2\u0d02\u0d03\u0d05-\u0d0c\u0d0e-\u0d10\u0d12-\u0d3a\u0d3d-\u0d44\u0d46-\u0d48\u0d4a-\u0d4e\u0d57\u0d60-\u0d63\u0d66-\u0d6f\u0d7a-\u0d7f\u0d82\u0d83\u0d85-\u0d96\u0d9a-\u0db1\u0db3-\u0dbb\u0dbd\u0dc0-\u0dc6\u0dca\u0dcf-\u0dd4\u0dd6\u0dd8-\u0ddf\u0df2\u0df3\u0e01-\u0e3a\u0e40-\u0e4e\u0e50-\u0e59\u0e81\u0e82\u0e84\u0e87\u0e88\u0e8a\u0e8d\u0e94-\u0e97\u0e99-\u0e9f\u0ea1-\u0ea3\u0ea5\u0ea7\u0eaa\u0eab\u0ead-\u0eb9\u0ebb-\u0ebd\u0ec0-\u0ec4\u0ec6\u0ec8-\u0ecd\u0ed0-\u0ed9\u0edc-\u0edf\u0f00\u0f18\u0f19\u0f20-\u0f29\u0f35\u0f37\u0f39\u0f3e-\u0f47\u0f49-\u0f6c\u0f71-\u0f84\u0f86-\u0f97\u0f99-\u0fbc\u0fc6\u1000-\u1049\u1050-\u109d\u10a0-\u10c5\u10c7\u10cd\u10d0-\u10fa\u10fc-\u1248\u124a-\u124d\u1250-\u1256\u1258\u125a-\u125d\u1260-\u1288\u128a-\u128d\u1290-\u12b0\u12b2-\u12b5\u12b8-\u12be\u12c0\u12c2-\u12c5\u12c8-\u12d6\u12d8-\u1310\u1312-\u1315\u1318-\u135a\u135d-\u135f\u1380-\u138f\u13a0-\u13f4\u1401-\u166c\u166f-\u167f\u1681-\u169a\u16a0-\u16ea\u16ee-\u16f0\u1700-\u170c\u170e-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176c\u176e-\u1770\u1772\u1773\u1780-\u17d3\u17d7\u17dc\u17dd\u17e0-\u17e9\u180b-\u180d\u1810-\u1819\u1820-\u1877\u1880-\u18aa\u18b0-\u18f5\u1900-\u191c\u1920-\u192b\u1930-\u193b\u1946-\u196d\u1970-\u1974\u1980-\u19ab\u19b0-\u19c9\u19d0-\u19d9\u1a00-\u1a1b\u1a20-\u1a5e\u1a60-\u1a7c\u1a7f-\u1a89\u1a90-\u1a99\u1aa7\u1b00-\u1b4b\u1b50-\u1b59\u1b6b-\u1b73\u1b80-\u1bf3\u1c00-\u1c37\u1c40-\u1c49\u1c4d-\u1c7d\u1cd0-\u1cd2\u1cd4-\u1cf6\u1d00-\u1de6\u1dfc-\u1f15\u1f18-\u1f1d\u1f20-\u1f45\u1f48-\u1f4d\u1f50-\u1f57\u1f59\u1f5b\u1f5d\u1f5f-\u1f7d\u1f80-\u1fb4\u1fb6-\u1fbc\u1fbe\u1fc2-\u1fc4\u1fc6-\u1fcc\u1fd0-\u1fd3\u1fd6-\u1fdb\u1fe0-\u1fec\u1ff2-\u1ff4\u1ff6-\u1ffc\u200c\u200d\u203f\u2040\u2054\u2071\u207f\u2090-\u209c\u20d0-\u20dc\u20e1\u20e5-\u20f0\u2102\u2107\u210a-\u2113\u2115\u2119-\u211d\u2124\u2126\u2128\u212a-\u212d\u212f-\u2139\u213c-\u213f\u2145-\u2149\u214e\u2160-\u2188\u2c00-\u2c2e\u2c30-\u2c5e\u2c60-\u2ce4\u2ceb-\u2cf3\u2d00-\u2d25\u2d27\u2d2d\u2d30-\u2d67\u2d6f\u2d7f-\u2d96\u2da0-\u2da6\u2da8-\u2dae\u2db0-\u2db6\u2db8-\u2dbe\u2dc0-\u2dc6\u2dc8-\u2dce\u2dd0-\u2dd6\u2dd8-\u2dde\u2de0-\u2dff\u2e2f\u3005-\u3007\u3021-\u302f\u3031-\u3035\u3038-\u303c\u3041-\u3096\u3099\u309a\u309d-\u309f\u30a1-\u30fa\u30fc-\u30ff\u3105-\u312d\u3131-\u318e\u31a0-\u31ba\u31f0-\u31ff\u3400-\u4db5\u4e00-\u9fcc\ua000-\ua48c\ua4d0-\ua4fd\ua500-\ua60c\ua610-\ua62b\ua640-\ua66f\ua674-\ua67d\ua67f-\ua697\ua69f-\ua6f1\ua717-\ua71f\ua722-\ua788\ua78b-\ua78e\ua790-\ua793\ua7a0-\ua7aa\ua7f8-\ua827\ua840-\ua873\ua880-\ua8c4\ua8d0-\ua8d9\ua8e0-\ua8f7\ua8fb\ua900-\ua92d\ua930-\ua953\ua960-\ua97c\ua980-\ua9c0\ua9cf-\ua9d9\uaa00-\uaa36\uaa40-\uaa4d\uaa50-\uaa59\uaa60-\uaa76\uaa7a\uaa7b\uaa80-\uaac2\uaadb-\uaadd\uaae0-\uaaef\uaaf2-\uaaf6\uab01-\uab06\uab09-\uab0e\uab11-\uab16\uab20-\uab26\uab28-\uab2e\uabc0-\uabea\uabec\uabed\uabf0-\uabf9\uac00-\ud7a3\ud7b0-\ud7c6\ud7cb-\ud7fb\uf900-\ufa6d\ufa70-\ufad9\ufb00-\ufb06\ufb13-\ufb17\ufb1d-\ufb28\ufb2a-\ufb36\ufb38-\ufb3c\ufb3e\ufb40\ufb41\ufb43\ufb44\ufb46-\ufbb1\ufbd3-\ufd3d\ufd50-\ufd8f\ufd92-\ufdc7\ufdf0-\ufdfb\ufe00-\ufe0f\ufe20-\ufe26\ufe33\ufe34\ufe4d-\ufe4f\ufe70-\ufe74\ufe76-\ufefc\uff10-\uff19\uff21-\uff3a\uff3f\uff41-\uff5a\uff66-\uffbe\uffc2-\uffc7\uffca-\uffcf\uffd2-\uffd7\uffda-\uffdc]'),
            LeadingZeros: new RegExp('^0+(?!$)')
        };
    
        // Ensure the condition is true, otherwise throw an error.
        // This is only to have a better contract semantic, i.e. another safety net
        // to catch a logic error. The condition shall be fulfilled in normal case.
        // Do NOT use this to enforce a certain condition on any user input.
    
        function assert(condition, message) {
            /* istanbul ignore if */
            if (!condition) {
                throw new Error('ASSERT: ' + message);
            }
        }
    
        function StringMap() {
            this.$data = {};
        }
    
        StringMap.prototype.get = function (key) {
            key = '$' + key;
            return this.$data[key];
        };
    
        StringMap.prototype.set = function (key, value) {
            key = '$' + key;
            this.$data[key] = value;
            return this;
        };
    
        StringMap.prototype.has = function (key) {
            key = '$' + key;
            return Object.prototype.hasOwnProperty.call(this.$data, key);
        };
    
        StringMap.prototype.delete = function (key) {
            key = '$' + key;
            return delete this.$data[key];
        };
    
        function isDecimalDigit(ch) {
            return (ch >= 48 && ch <= 57);   // 0..9
        }
    
        function isHexDigit(ch) {
            return '0123456789abcdefABCDEF'.indexOf(ch) >= 0;
        }
    
        function isOctalDigit(ch) {
            return '01234567'.indexOf(ch) >= 0;
        }
    
    
        // 7.2 White Space
    
        function isWhiteSpace(ch) {
            return (ch === 32) ||  // space
                (ch === 9) ||      // tab
                (ch === 0xB) ||
                (ch === 0xC) ||
                (ch === 0xA0) ||
                (ch >= 0x1680 && '\u1680\u180E\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\uFEFF'.indexOf(String.fromCharCode(ch)) > 0);
        }
    
        // 7.3 Line Terminators
    
        function isLineTerminator(ch) {
            return (ch === 10) || (ch === 13) || (ch === 0x2028) || (ch === 0x2029);
        }
    
        // 7.6 Identifier Names and Identifiers
    
        function isIdentifierStart(ch) {
            return (ch === 36) || (ch === 95) ||  // $ (dollar) and _ (underscore)
                (ch >= 65 && ch <= 90) ||         // A..Z
                (ch >= 97 && ch <= 122) ||        // a..z
                (ch === 92) ||                    // \ (backslash)
                ((ch >= 0x80) && Regex.NonAsciiIdentifierStart.test(String.fromCharCode(ch)));
        }
    
        function isIdentifierPart(ch) {
            return (ch === 36) || (ch === 95) ||  // $ (dollar) and _ (underscore)
                (ch >= 65 && ch <= 90) ||         // A..Z
                (ch >= 97 && ch <= 122) ||        // a..z
                (ch >= 48 && ch <= 57) ||         // 0..9
                (ch === 92) ||                    // \ (backslash)
                ((ch >= 0x80) && Regex.NonAsciiIdentifierPart.test(String.fromCharCode(ch)));
        }
    
        // 7.6.1.2 Future Reserved Words
    
        function isFutureReservedWord(id) {
            switch (id) {
            case 'class':
            case 'enum':
            case 'export':
            case 'extends':
            case 'import':
            case 'super':
                return true;
            default:
                return false;
            }
        }
    
        function isStrictModeReservedWord(id) {
            switch (id) {
            case 'implements':
            case 'interface':
            case 'package':
            case 'private':
            case 'protected':
            case 'public':
            case 'static':
            case 'yield':
            case 'let':
                return true;
            default:
                return false;
            }
        }
    
        function isRestrictedWord(id) {
            return id === 'eval' || id === 'arguments';
        }
    
        // 7.6.1.1 Keywords
    
        function isKeyword(id) {
            if (strict && isStrictModeReservedWord(id)) {
                return true;
            }
    
            // 'const' is specialized as Keyword in V8.
            // 'yield' is only treated as a keyword in strict mode.
            // 'let' is for compatiblity with SpiderMonkey and ES.next.
            // Some others are from future reserved words.
    
            switch (id.length) {
            case 2:
                return (id === 'if') || (id === 'in') || (id === 'do');
            case 3:
                return (id === 'var') || (id === 'for') || (id === 'new') ||
                    (id === 'try') || (id === 'let');
            case 4:
                return (id === 'this') || (id === 'else') || (id === 'case') ||
                    (id === 'void') || (id === 'with') || (id === 'enum');
            case 5:
                return (id === 'while') || (id === 'break') || (id === 'catch') ||
                    (id === 'throw') || (id === 'const') ||
                    (id === 'class') || (id === 'super');
            case 6:
                return (id === 'return') || (id === 'typeof') || (id === 'delete') ||
                    (id === 'switch') || (id === 'export') || (id === 'import');
            case 7:
                return (id === 'default') || (id === 'finally') || (id === 'extends');
            case 8:
                return (id === 'function') || (id === 'continue') || (id === 'debugger');
            case 10:
                return (id === 'instanceof');
            default:
                return false;
            }
        }
    
        // 7.4 Comments
    
        function addComment(type, value, start, end, loc) {
            var comment;
            assert(typeof start === 'number', 'Comment must have valid position');
    
            // Because the way the actual token is scanned, often the comments
            // (if any) are skipped twice during the lexical analysis.
            // Thus, we need to skip adding a comment if the comment array already
            // handled it.
            if (state.lastCommentStart >= start) {
                return;
            }
            state.lastCommentStart = start;
    
            comment = {
                type: type,
                value: value
            };
            if (extra.range) {
                comment.range = [start, end];
            }
            if (extra.loc) {
                comment.loc = loc;
            }
            extra.comments.push(comment);
            if (extra.attachComment) {
                extra.leadingComments.push(comment);
                extra.trailingComments.push(comment);
            }
        }
    
        function skipSingleLineComment() {
            var start, loc, ch, comment;
    
            start = index - 2;
            loc = {
                start: {
                    line: lineNumber,
                    column: index - lineStart - 2
                }
            };
    
            while (index < length) {
                ch = source.charCodeAt(index);
                ++index;
                if (isLineTerminator(ch)) {
                    if (extra.comments) {
                        comment = source.slice(start + 2, index - 1);
                        loc.end = {
                            line: lineNumber,
                            column: index - lineStart - 1
                        };
                        addComment('Line', comment, start, index - 1, loc);
                    }
                    if (ch === 13 && source.charCodeAt(index) === 10) {
                        ++index;
                    }
                    ++lineNumber;
                    lineStart = index;
                    return;
                }
            }
    
            if (extra.comments) {
                comment = source.slice(start + 2, index);
                loc.end = {
                    line: lineNumber,
                    column: index - lineStart
                };
                addComment('Line', comment, start, index, loc);
            }
        }
    
        function skipMultiLineComment() {
            var start, loc, ch, comment;
    
            if (extra.comments) {
                start = index - 2;
                loc = {
                    start: {
                        line: lineNumber,
                        column: index - lineStart - 2
                    }
                };
            }
    
            while (index < length) {
                ch = source.charCodeAt(index);
                if (isLineTerminator(ch)) {
                    if (ch === 13 && source.charCodeAt(index + 1) === 10) {
                        ++index;
                    }
                    ++lineNumber;
                    ++index;
                    lineStart = index;
                    if (index >= length) {
                        throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
                    }
                } else if (ch === 42) {
                    // Block comment ends with '*/' (char #42, char #47).
                    if (source.charCodeAt(index + 1) === 47) {
                        ++index;
                        ++index;
                        if (extra.comments) {
                            comment = source.slice(start + 2, index - 2);
                            loc.end = {
                                line: lineNumber,
                                column: index - lineStart
                            };
                            addComment('Block', comment, start, index, loc);
                        }
                        return;
                    }
                    ++index;
                } else {
                    ++index;
                }
            }
    
            throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
        }
    
        function skipComment() {
            var ch;
    
            while (index < length) {
                ch = source.charCodeAt(index);
    
                if (isWhiteSpace(ch)) {
                    ++index;
                } else if (isLineTerminator(ch)) {
                    ++index;
                    if (ch === 13 && source.charCodeAt(index) === 10) {
                        ++index;
                    }
                    ++lineNumber;
                    lineStart = index;
                } else if (ch === 47) { // 47 is '/'
                    ch = source.charCodeAt(index + 1);
                    if (ch === 47) {
                        ++index;
                        ++index;
                        skipSingleLineComment();
                    } else if (ch === 42) {  // 42 is '*'
                        ++index;
                        ++index;
                        skipMultiLineComment();
                    } else {
                        break;
                    }
                } else {
                    break;
                }
            }
        }
    
        function scanHexEscape(prefix) {
            var i, len, ch, code = 0;
    
            len = (prefix === 'u') ? 4 : 2;
            for (i = 0; i < len; ++i) {
                if (index < length && isHexDigit(source[index])) {
                    ch = source[index++];
                    code = code * 16 + '0123456789abcdef'.indexOf(ch.toLowerCase());
                } else {
                    return '';
                }
            }
            return String.fromCharCode(code);
        }
    
        function scanUnicodeCodePointEscape() {
            var ch, code, cu1, cu2;
    
            ch = source[index];
            code = 0;
    
            // At least, one hex digit is required.
            if (ch === '}') {
                throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
            }
    
            while (index < length) {
                ch = source[index++];
                if (!isHexDigit(ch)) {
                    break;
                }
                code = code * 16 + '0123456789abcdef'.indexOf(ch.toLowerCase());
            }
    
            if (code > 0x10FFFF || ch !== '}') {
                throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
            }
    
            // UTF-16 Encoding
            if (code <= 0xFFFF) {
                return String.fromCharCode(code);
            }
            cu1 = ((code - 0x10000) >> 10) + 0xD800;
            cu2 = ((code - 0x10000) & 1023) + 0xDC00;
            return String.fromCharCode(cu1, cu2);
        }
    
        function getEscapedIdentifier() {
            var ch, id;
    
            ch = source.charCodeAt(index++);
            id = String.fromCharCode(ch);
    
            // '\u' (char #92, char #117) denotes an escaped character.
            if (ch === 92) {
                if (source.charCodeAt(index) !== 117) {
                    throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
                }
                ++index;
                ch = scanHexEscape('u');
                if (!ch || ch === '\\' || !isIdentifierStart(ch.charCodeAt(0))) {
                    throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
                }
                id = ch;
            }
    
            while (index < length) {
                ch = source.charCodeAt(index);
                if (!isIdentifierPart(ch)) {
                    break;
                }
                ++index;
                id += String.fromCharCode(ch);
    
                // '\u' (char #92, char #117) denotes an escaped character.
                if (ch === 92) {
                    id = id.substr(0, id.length - 1);
                    if (source.charCodeAt(index) !== 117) {
                        throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
                    }
                    ++index;
                    ch = scanHexEscape('u');
                    if (!ch || ch === '\\' || !isIdentifierPart(ch.charCodeAt(0))) {
                        throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
                    }
                    id += ch;
                }
            }
    
            return id;
        }
    
        function getIdentifier() {
            var start, ch;
    
            start = index++;
            while (index < length) {
                ch = source.charCodeAt(index);
                if (ch === 92) {
                    // Blackslash (char #92) marks Unicode escape sequence.
                    index = start;
                    return getEscapedIdentifier();
                }
                if (isIdentifierPart(ch)) {
                    ++index;
                } else {
                    break;
                }
            }
    
            return source.slice(start, index);
        }
    
        function scanIdentifier() {
            var start, id, type;
    
            start = index;
    
            // Backslash (char #92) starts an escaped character.
            id = (source.charCodeAt(index) === 92) ? getEscapedIdentifier() : getIdentifier();
    
            // There is no keyword or literal with only one character.
            // Thus, it must be an identifier.
            if (id.length === 1) {
                type = Token.Identifier;
            } else if (isKeyword(id)) {
                type = Token.Keyword;
            } else if (id === 'null') {
                type = Token.NullLiteral;
            } else if (id === 'true' || id === 'false') {
                type = Token.BooleanLiteral;
            } else {
                type = Token.Identifier;
            }
    
            return {
                type: type,
                value: id,
                lineNumber: lineNumber,
                lineStart: lineStart,
                range: [start, index]
            };
        }
    
    
        // 7.7 Punctuators
    
        function scanPunctuator() {
            var start = index,
                code = source.charCodeAt(index),
                code2,
                ch1 = source[index],
                ch2,
                ch3,
                ch4;
    
            if (state.inJSXTag || state.inJSXChild) {
                // Don't need to check for '{' and '}' as it's already handled
                // correctly by default.
                switch (code) {
                case 60:  // <
                case 62:  // >
                    ++index;
                    return {
                        type: Token.Punctuator,
                        value: String.fromCharCode(code),
                        lineNumber: lineNumber,
                        lineStart: lineStart,
                        range: [start, index]
                    };
                }
            }
    
            switch (code) {
            // Check for most common single-character punctuators.
            case 40:   // ( open bracket
            case 41:   // ) close bracket
            case 59:   // ; semicolon
            case 44:   // , comma
            case 123:  // { open curly brace
            case 125:  // } close curly brace
            case 91:   // [
            case 93:   // ]
            case 58:   // :
            case 63:   // ?
            case 126:  // ~
                ++index;
                if (extra.tokenize) {
                    if (code === 40) {
                        extra.openParenToken = extra.tokens.length;
                    } else if (code === 123) {
                        extra.openCurlyToken = extra.tokens.length;
                    }
                }
                return {
                    type: Token.Punctuator,
                    value: String.fromCharCode(code),
                    lineNumber: lineNumber,
                    lineStart: lineStart,
                    range: [start, index]
                };
    
            default:
                code2 = source.charCodeAt(index + 1);
    
                // '=' (char #61) marks an assignment or comparison operator.
                if (code2 === 61) {
                    switch (code) {
                    case 37:  // %
                    case 38:  // &
                    case 42:  // *:
                    case 43:  // +
                    case 45:  // -
                    case 47:  // /
                    case 60:  // <
                    case 62:  // >
                    case 94:  // ^
                    case 124: // |
                        index += 2;
                        return {
                            type: Token.Punctuator,
                            value: String.fromCharCode(code) + String.fromCharCode(code2),
                            lineNumber: lineNumber,
                            lineStart: lineStart,
                            range: [start, index]
                        };
    
                    case 33: // !
                    case 61: // =
                        index += 2;
    
                        // !== and ===
                        if (source.charCodeAt(index) === 61) {
                            ++index;
                        }
                        return {
                            type: Token.Punctuator,
                            value: source.slice(start, index),
                            lineNumber: lineNumber,
                            lineStart: lineStart,
                            range: [start, index]
                        };
                    default:
                        break;
                    }
                }
                break;
            }
    
            // Peek more characters.
    
            ch2 = source[index + 1];
            ch3 = source[index + 2];
            ch4 = source[index + 3];
    
            // 4-character punctuator: >>>=
    
            if (ch1 === '>' && ch2 === '>' && ch3 === '>') {
                if (ch4 === '=') {
                    index += 4;
                    return {
                        type: Token.Punctuator,
                        value: '>>>=',
                        lineNumber: lineNumber,
                        lineStart: lineStart,
                        range: [start, index]
                    };
                }
            }
    
            // 3-character punctuators: === !== >>> <<= >>=
    
            if (ch1 === '>' && ch2 === '>' && ch3 === '>' && !state.inType) {
                index += 3;
                return {
                    type: Token.Punctuator,
                    value: '>>>',
                    lineNumber: lineNumber,
                    lineStart: lineStart,
                    range: [start, index]
                };
            }
    
            if (ch1 === '<' && ch2 === '<' && ch3 === '=') {
                index += 3;
                return {
                    type: Token.Punctuator,
                    value: '<<=',
                    lineNumber: lineNumber,
                    lineStart: lineStart,
                    range: [start, index]
                };
            }
    
            if (ch1 === '>' && ch2 === '>' && ch3 === '=') {
                index += 3;
                return {
                    type: Token.Punctuator,
                    value: '>>=',
                    lineNumber: lineNumber,
                    lineStart: lineStart,
                    range: [start, index]
                };
            }
    
            if (ch1 === '.' && ch2 === '.' && ch3 === '.') {
                index += 3;
                return {
                    type: Token.Punctuator,
                    value: '...',
                    lineNumber: lineNumber,
                    lineStart: lineStart,
                    range: [start, index]
                };
            }
    
            // Other 2-character punctuators: ++ -- << >> && ||
    
            // Don't match these tokens if we're in a type, since they never can
            // occur and can mess up types like Map<string, Array<string>>
            if (ch1 === ch2 && ('+-<>&|'.indexOf(ch1) >= 0) && !state.inType) {
                index += 2;
                return {
                    type: Token.Punctuator,
                    value: ch1 + ch2,
                    lineNumber: lineNumber,
                    lineStart: lineStart,
                    range: [start, index]
                };
            }
    
            if (ch1 === '=' && ch2 === '>') {
                index += 2;
                return {
                    type: Token.Punctuator,
                    value: '=>',
                    lineNumber: lineNumber,
                    lineStart: lineStart,
                    range: [start, index]
                };
            }
    
            if ('<>=!+-*%&|^/'.indexOf(ch1) >= 0) {
                ++index;
                return {
                    type: Token.Punctuator,
                    value: ch1,
                    lineNumber: lineNumber,
                    lineStart: lineStart,
                    range: [start, index]
                };
            }
    
            if (ch1 === '.') {
                ++index;
                return {
                    type: Token.Punctuator,
                    value: ch1,
                    lineNumber: lineNumber,
                    lineStart: lineStart,
                    range: [start, index]
                };
            }
    
            throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
        }
    
        // 7.8.3 Numeric Literals
    
        function scanHexLiteral(start) {
            var number = '';
    
            while (index < length) {
                if (!isHexDigit(source[index])) {
                    break;
                }
                number += source[index++];
            }
    
            if (number.length === 0) {
                throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
            }
    
            if (isIdentifierStart(source.charCodeAt(index))) {
                throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
            }
    
            return {
                type: Token.NumericLiteral,
                value: parseInt('0x' + number, 16),
                lineNumber: lineNumber,
                lineStart: lineStart,
                range: [start, index]
            };
        }
    
        function scanBinaryLiteral(start) {
            var ch, number;
    
            number = '';
    
            while (index < length) {
                ch = source[index];
                if (ch !== '0' && ch !== '1') {
                    break;
                }
                number += source[index++];
            }
    
            if (number.length === 0) {
                // only 0b or 0B
                throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
            }
    
            if (index < length) {
                ch = source.charCodeAt(index);
                /* istanbul ignore else */
                if (isIdentifierStart(ch) || isDecimalDigit(ch)) {
                    throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
                }
            }
    
            return {
                type: Token.NumericLiteral,
                value: parseInt(number, 2),
                lineNumber: lineNumber,
                lineStart: lineStart,
                range: [start, index]
            };
        }
    
        function scanOctalLiteral(prefix, start) {
            var number, octal;
    
            if (isOctalDigit(prefix)) {
                octal = true;
                number = '0' + source[index++];
            } else {
                octal = false;
                ++index;
                number = '';
            }
    
            while (index < length) {
                if (!isOctalDigit(source[index])) {
                    break;
                }
                number += source[index++];
            }
    
            if (!octal && number.length === 0) {
                // only 0o or 0O
                throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
            }
    
            if (isIdentifierStart(source.charCodeAt(index)) || isDecimalDigit(source.charCodeAt(index))) {
                throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
            }
    
            return {
                type: Token.NumericLiteral,
                value: parseInt(number, 8),
                octal: octal,
                lineNumber: lineNumber,
                lineStart: lineStart,
                range: [start, index]
            };
        }
    
        function scanNumericLiteral() {
            var number, start, ch;
    
            ch = source[index];
            assert(isDecimalDigit(ch.charCodeAt(0)) || (ch === '.'),
                'Numeric literal must start with a decimal digit or a decimal point');
    
            start = index;
            number = '';
            if (ch !== '.') {
                number = source[index++];
                ch = source[index];
    
                // Hex number starts with '0x'.
                // Octal number starts with '0'.
                // Octal number in ES6 starts with '0o'.
                // Binary number in ES6 starts with '0b'.
                if (number === '0') {
                    if (ch === 'x' || ch === 'X') {
                        ++index;
                        return scanHexLiteral(start);
                    }
                    if (ch === 'b' || ch === 'B') {
                        ++index;
                        return scanBinaryLiteral(start);
                    }
                    if (ch === 'o' || ch === 'O' || isOctalDigit(ch)) {
                        return scanOctalLiteral(ch, start);
                    }
                    // decimal number starts with '0' such as '09' is illegal.
                    if (ch && isDecimalDigit(ch.charCodeAt(0))) {
                        throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
                    }
                }
    
                while (isDecimalDigit(source.charCodeAt(index))) {
                    number += source[index++];
                }
                ch = source[index];
            }
    
            if (ch === '.') {
                number += source[index++];
                while (isDecimalDigit(source.charCodeAt(index))) {
                    number += source[index++];
                }
                ch = source[index];
            }
    
            if (ch === 'e' || ch === 'E') {
                number += source[index++];
    
                ch = source[index];
                if (ch === '+' || ch === '-') {
                    number += source[index++];
                }
                if (isDecimalDigit(source.charCodeAt(index))) {
                    while (isDecimalDigit(source.charCodeAt(index))) {
                        number += source[index++];
                    }
                } else {
                    throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
                }
            }
    
            if (isIdentifierStart(source.charCodeAt(index))) {
                throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
            }
    
            return {
                type: Token.NumericLiteral,
                value: parseFloat(number),
                lineNumber: lineNumber,
                lineStart: lineStart,
                range: [start, index]
            };
        }
    
        // 7.8.4 String Literals
    
        function scanStringLiteral() {
            var str = '', quote, start, ch, code, unescaped, restore, octal = false;
    
            quote = source[index];
            assert((quote === '\'' || quote === '"'),
                'String literal must starts with a quote');
    
            start = index;
            ++index;
    
            while (index < length) {
                ch = source[index++];
    
                if (ch === quote) {
                    quote = '';
                    break;
                } else if (ch === '\\') {
                    ch = source[index++];
                    if (!ch || !isLineTerminator(ch.charCodeAt(0))) {
                        switch (ch) {
                        case 'n':
                            str += '\n';
                            break;
                        case 'r':
                            str += '\r';
                            break;
                        case 't':
                            str += '\t';
                            break;
                        case 'u':
                        case 'x':
                            if (source[index] === '{') {
                                ++index;
                                str += scanUnicodeCodePointEscape();
                            } else {
                                restore = index;
                                unescaped = scanHexEscape(ch);
                                if (unescaped) {
                                    str += unescaped;
                                } else {
                                    index = restore;
                                    str += ch;
                                }
                            }
                            break;
                        case 'b':
                            str += '\b';
                            break;
                        case 'f':
                            str += '\f';
                            break;
                        case 'v':
                            str += '\x0B';
                            break;
    
                        default:
                            if (isOctalDigit(ch)) {
                                code = '01234567'.indexOf(ch);
    
                                // \0 is not octal escape sequence
                                if (code !== 0) {
                                    octal = true;
                                }
    
                                /* istanbul ignore else */
                                if (index < length && isOctalDigit(source[index])) {
                                    octal = true;
                                    code = code * 8 + '01234567'.indexOf(source[index++]);
    
                                    // 3 digits are only allowed when string starts
                                    // with 0, 1, 2, 3
                                    if ('0123'.indexOf(ch) >= 0 &&
                                            index < length &&
                                            isOctalDigit(source[index])) {
                                        code = code * 8 + '01234567'.indexOf(source[index++]);
                                    }
                                }
                                str += String.fromCharCode(code);
                            } else {
                                str += ch;
                            }
                            break;
                        }
                    } else {
                        ++lineNumber;
                        if (ch === '\r' && source[index] === '\n') {
                            ++index;
                        }
                        lineStart = index;
                    }
                } else if (isLineTerminator(ch.charCodeAt(0))) {
                    break;
                } else {
                    str += ch;
                }
            }
    
            if (quote !== '') {
                throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
            }
    
            return {
                type: Token.StringLiteral,
                value: str,
                octal: octal,
                lineNumber: lineNumber,
                lineStart: lineStart,
                range: [start, index]
            };
        }
    
        function scanTemplate() {
            var cooked = '', ch, start, terminated, tail, restore, unescaped, code, octal;
    
            terminated = false;
            tail = false;
            start = index;
    
            ++index;
    
            while (index < length) {
                ch = source[index++];
                if (ch === '`') {
                    tail = true;
                    terminated = true;
                    break;
                } else if (ch === '$') {
                    if (source[index] === '{') {
                        ++index;
                        terminated = true;
                        break;
                    }
                    cooked += ch;
                } else if (ch === '\\') {
                    ch = source[index++];
                    if (!isLineTerminator(ch.charCodeAt(0))) {
                        switch (ch) {
                        case 'n':
                            cooked += '\n';
                            break;
                        case 'r':
                            cooked += '\r';
                            break;
                        case 't':
                            cooked += '\t';
                            break;
                        case 'u':
                        case 'x':
                            if (source[index] === '{') {
                                ++index;
                                cooked += scanUnicodeCodePointEscape();
                            } else {
                                restore = index;
                                unescaped = scanHexEscape(ch);
                                if (unescaped) {
                                    cooked += unescaped;
                                } else {
                                    index = restore;
                                    cooked += ch;
                                }
                            }
                            break;
                        case 'b':
                            cooked += '\b';
                            break;
                        case 'f':
                            cooked += '\f';
                            break;
                        case 'v':
                            cooked += '\v';
                            break;
    
                        default:
                            if (isOctalDigit(ch)) {
                                code = '01234567'.indexOf(ch);
    
                                // \0 is not octal escape sequence
                                if (code !== 0) {
                                    octal = true;
                                }
    
                                /* istanbul ignore else */
                                if (index < length && isOctalDigit(source[index])) {
                                    octal = true;
                                    code = code * 8 + '01234567'.indexOf(source[index++]);
    
                                    // 3 digits are only allowed when string starts
                                    // with 0, 1, 2, 3
                                    if ('0123'.indexOf(ch) >= 0 &&
                                            index < length &&
                                            isOctalDigit(source[index])) {
                                        code = code * 8 + '01234567'.indexOf(source[index++]);
                                    }
                                }
                                cooked += String.fromCharCode(code);
                            } else {
                                cooked += ch;
                            }
                            break;
                        }
                    } else {
                        ++lineNumber;
                        if (ch === '\r' && source[index] === '\n') {
                            ++index;
                        }
                        lineStart = index;
                    }
                } else if (isLineTerminator(ch.charCodeAt(0))) {
                    ++lineNumber;
                    if (ch === '\r' && source[index] === '\n') {
                        ++index;
                    }
                    lineStart = index;
                    cooked += '\n';
                } else {
                    cooked += ch;
                }
            }
    
            if (!terminated) {
                throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
            }
    
            return {
                type: Token.Template,
                value: {
                    cooked: cooked,
                    raw: source.slice(start + 1, index - ((tail) ? 1 : 2))
                },
                tail: tail,
                octal: octal,
                lineNumber: lineNumber,
                lineStart: lineStart,
                range: [start, index]
            };
        }
    
        function scanTemplateElement(option) {
            var startsWith, template;
    
            lookahead = null;
            skipComment();
    
            startsWith = (option.head) ? '`' : '}';
    
            if (source[index] !== startsWith) {
                throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
            }
    
            template = scanTemplate();
    
            peek();
    
            return template;
        }
    
        function testRegExp(pattern, flags) {
            var tmp = pattern,
                value;
    
            if (flags.indexOf('u') >= 0) {
                // Replace each astral symbol and every Unicode code point
                // escape sequence with a single ASCII symbol to avoid throwing on
                // regular expressions that are only valid in combination with the
                // `/u` flag.
                // Note: replacing with the ASCII symbol `x` might cause false
                // negatives in unlikely scenarios. For example, `[\u{61}-b]` is a
                // perfectly valid pattern that is equivalent to `[a-b]`, but it
                // would be replaced by `[x-b]` which throws an error.
                tmp = tmp
                    .replace(/\\u\{([0-9a-fA-F]+)\}/g, function ($0, $1) {
                        if (parseInt($1, 16) <= 0x10FFFF) {
                            return 'x';
                        }
                        throwError({}, Messages.InvalidRegExp);
                    })
                    .replace(/[\uD800-\uDBFF][\uDC00-\uDFFF]/g, 'x');
            }
    
            // First, detect invalid regular expressions.
            try {
                value = new RegExp(tmp);
            } catch (e) {
                throwError({}, Messages.InvalidRegExp);
            }
    
            // Return a regular expression object for this pattern-flag pair, or
            // `null` in case the current environment doesn't support the flags it
            // uses.
            try {
                return new RegExp(pattern, flags);
            } catch (exception) {
                return null;
            }
        }
    
        function scanRegExpBody() {
            var ch, str, classMarker, terminated, body;
    
            ch = source[index];
            assert(ch === '/', 'Regular expression literal must start with a slash');
            str = source[index++];
    
            classMarker = false;
            terminated = false;
            while (index < length) {
                ch = source[index++];
                str += ch;
                if (ch === '\\') {
                    ch = source[index++];
                    // ECMA-262 7.8.5
                    if (isLineTerminator(ch.charCodeAt(0))) {
                        throwError({}, Messages.UnterminatedRegExp);
                    }
                    str += ch;
                } else if (isLineTerminator(ch.charCodeAt(0))) {
                    throwError({}, Messages.UnterminatedRegExp);
                } else if (classMarker) {
                    if (ch === ']') {
                        classMarker = false;
                    }
                } else {
                    if (ch === '/') {
                        terminated = true;
                        break;
                    } else if (ch === '[') {
                        classMarker = true;
                    }
                }
            }
    
            if (!terminated) {
                throwError({}, Messages.UnterminatedRegExp);
            }
    
            // Exclude leading and trailing slash.
            body = str.substr(1, str.length - 2);
            return {
                value: body,
                literal: str
            };
        }
    
        function scanRegExpFlags() {
            var ch, str, flags, restore;
    
            str = '';
            flags = '';
            while (index < length) {
                ch = source[index];
                if (!isIdentifierPart(ch.charCodeAt(0))) {
                    break;
                }
    
                ++index;
                if (ch === '\\' && index < length) {
                    ch = source[index];
                    if (ch === 'u') {
                        ++index;
                        restore = index;
                        ch = scanHexEscape('u');
                        if (ch) {
                            flags += ch;
                            for (str += '\\u'; restore < index; ++restore) {
                                str += source[restore];
                            }
                        } else {
                            index = restore;
                            flags += 'u';
                            str += '\\u';
                        }
                        throwErrorTolerant({}, Messages.UnexpectedToken, 'ILLEGAL');
                    } else {
                        str += '\\';
                        throwErrorTolerant({}, Messages.UnexpectedToken, 'ILLEGAL');
                    }
                } else {
                    flags += ch;
                    str += ch;
                }
            }
    
            return {
                value: flags,
                literal: str
            };
        }
    
        function scanRegExp() {
            var start, body, flags, value;
    
            lookahead = null;
            skipComment();
            start = index;
    
            body = scanRegExpBody();
            flags = scanRegExpFlags();
            value = testRegExp(body.value, flags.value);
    
            if (extra.tokenize) {
                return {
                    type: Token.RegularExpression,
                    value: value,
                    regex: {
                        pattern: body.value,
                        flags: flags.value
                    },
                    lineNumber: lineNumber,
                    lineStart: lineStart,
                    range: [start, index]
                };
            }
    
            return {
                literal: body.literal + flags.literal,
                value: value,
                regex: {
                    pattern: body.value,
                    flags: flags.value
                },
                range: [start, index]
            };
        }
    
        function isIdentifierName(token) {
            return token.type === Token.Identifier ||
                token.type === Token.Keyword ||
                token.type === Token.BooleanLiteral ||
                token.type === Token.NullLiteral;
        }
    
        function advanceSlash() {
            var prevToken,
                checkToken;
            // Using the following algorithm:
            // https://github.com/mozilla/sweet.js/wiki/design
            prevToken = extra.tokens[extra.tokens.length - 1];
            if (!prevToken) {
                // Nothing before that: it cannot be a division.
                return scanRegExp();
            }
            if (prevToken.type === 'Punctuator') {
                if (prevToken.value === ')') {
                    checkToken = extra.tokens[extra.openParenToken - 1];
                    if (checkToken &&
                            checkToken.type === 'Keyword' &&
                            (checkToken.value === 'if' ||
                             checkToken.value === 'while' ||
                             checkToken.value === 'for' ||
                             checkToken.value === 'with')) {
                        return scanRegExp();
                    }
                    return scanPunctuator();
                }
                if (prevToken.value === '}') {
                    // Dividing a function by anything makes little sense,
                    // but we have to check for that.
                    if (extra.tokens[extra.openCurlyToken - 3] &&
                            extra.tokens[extra.openCurlyToken - 3].type === 'Keyword') {
                        // Anonymous function.
                        checkToken = extra.tokens[extra.openCurlyToken - 4];
                        if (!checkToken) {
                            return scanPunctuator();
                        }
                    } else if (extra.tokens[extra.openCurlyToken - 4] &&
                            extra.tokens[extra.openCurlyToken - 4].type === 'Keyword') {
                        // Named function.
                        checkToken = extra.tokens[extra.openCurlyToken - 5];
                        if (!checkToken) {
                            return scanRegExp();
                        }
                    } else {
                        return scanPunctuator();
                    }
                    // checkToken determines whether the function is
                    // a declaration or an expression.
                    if (FnExprTokens.indexOf(checkToken.value) >= 0) {
                        // It is an expression.
                        return scanPunctuator();
                    }
                    // It is a declaration.
                    return scanRegExp();
                }
                return scanRegExp();
            }
            if (prevToken.type === 'Keyword' && prevToken.value !== 'this') {
                return scanRegExp();
            }
            return scanPunctuator();
        }
    
        function advance() {
            var ch;
    
            if (!state.inJSXChild) {
                skipComment();
            }
    
            if (index >= length) {
                return {
                    type: Token.EOF,
                    lineNumber: lineNumber,
                    lineStart: lineStart,
                    range: [index, index]
                };
            }
    
            if (state.inJSXChild) {
                return advanceJSXChild();
            }
    
            ch = source.charCodeAt(index);
    
            // Very common: ( and ) and ;
            if (ch === 40 || ch === 41 || ch === 58) {
                return scanPunctuator();
            }
    
            // String literal starts with single quote (#39) or double quote (#34).
            if (ch === 39 || ch === 34) {
                if (state.inJSXTag) {
                    return scanJSXStringLiteral();
                }
                return scanStringLiteral();
            }
    
            if (state.inJSXTag && isJSXIdentifierStart(ch)) {
                return scanJSXIdentifier();
            }
    
            if (ch === 96) {
                return scanTemplate();
            }
            if (isIdentifierStart(ch)) {
                return scanIdentifier();
            }
    
            // Dot (.) char #46 can also start a floating-point number, hence the need
            // to check the next character.
            if (ch === 46) {
                if (isDecimalDigit(source.charCodeAt(index + 1))) {
                    return scanNumericLiteral();
                }
                return scanPunctuator();
            }
    
            if (isDecimalDigit(ch)) {
                return scanNumericLiteral();
            }
    
            // Slash (/) char #47 can also start a regex.
            if (extra.tokenize && ch === 47) {
                return advanceSlash();
            }
    
            return scanPunctuator();
        }
    
        function lex() {
            var token;
    
            token = lookahead;
            index = token.range[1];
            lineNumber = token.lineNumber;
            lineStart = token.lineStart;
    
            lookahead = advance();
    
            index = token.range[1];
            lineNumber = token.lineNumber;
            lineStart = token.lineStart;
    
            return token;
        }
    
        function peek() {
            var pos, line, start;
    
            pos = index;
            line = lineNumber;
            start = lineStart;
            lookahead = advance();
            index = pos;
            lineNumber = line;
            lineStart = start;
        }
    
        function lookahead2() {
            var adv, pos, line, start, result;
    
            // If we are collecting the tokens, don't grab the next one yet.
            /* istanbul ignore next */
            adv = (typeof extra.advance === 'function') ? extra.advance : advance;
    
            pos = index;
            line = lineNumber;
            start = lineStart;
    
            // Scan for the next immediate token.
            /* istanbul ignore if */
            if (lookahead === null) {
                lookahead = adv();
            }
            index = lookahead.range[1];
            lineNumber = lookahead.lineNumber;
            lineStart = lookahead.lineStart;
    
            // Grab the token right after.
            result = adv();
            index = pos;
            lineNumber = line;
            lineStart = start;
    
            return result;
        }
    
        function rewind(token) {
            index = token.range[0];
            lineNumber = token.lineNumber;
            lineStart = token.lineStart;
            lookahead = token;
        }
    
        function markerCreate() {
            if (!extra.loc && !extra.range) {
                return undefined;
            }
            skipComment();
            return {offset: index, line: lineNumber, col: index - lineStart};
        }
    
        function markerCreatePreserveWhitespace() {
            if (!extra.loc && !extra.range) {
                return undefined;
            }
            return {offset: index, line: lineNumber, col: index - lineStart};
        }
    
        function processComment(node) {
            var lastChild,
                trailingComments,
                bottomRight = extra.bottomRightStack,
                last = bottomRight[bottomRight.length - 1];
    
            if (node.type === Syntax.Program) {
                /* istanbul ignore else */
                if (node.body.length > 0) {
                    return;
                }
            }
    
            if (extra.trailingComments.length > 0) {
                if (extra.trailingComments[0].range[0] >= node.range[1]) {
                    trailingComments = extra.trailingComments;
                    extra.trailingComments = [];
                } else {
                    extra.trailingComments.length = 0;
                }
            } else {
                if (last && last.trailingComments && last.trailingComments[0].range[0] >= node.range[1]) {
                    trailingComments = last.trailingComments;
                    delete last.trailingComments;
                }
            }
    
            // Eating the stack.
            if (last) {
                while (last && last.range[0] >= node.range[0]) {
                    lastChild = last;
                    last = bottomRight.pop();
                }
            }
    
            if (lastChild) {
                if (lastChild.leadingComments && lastChild.leadingComments[lastChild.leadingComments.length - 1].range[1] <= node.range[0]) {
                    node.leadingComments = lastChild.leadingComments;
                    delete lastChild.leadingComments;
                }
            } else if (extra.leadingComments.length > 0 && extra.leadingComments[extra.leadingComments.length - 1].range[1] <= node.range[0]) {
                node.leadingComments = extra.leadingComments;
                extra.leadingComments = [];
            }
    
            if (trailingComments) {
                node.trailingComments = trailingComments;
            }
    
            bottomRight.push(node);
        }
    
        function markerApply(marker, node) {
            if (extra.range) {
                node.range = [marker.offset, index];
            }
            if (extra.loc) {
                node.loc = {
                    start: {
                        line: marker.line,
                        column: marker.col
                    },
                    end: {
                        line: lineNumber,
                        column: index - lineStart
                    }
                };
                node = delegate.postProcess(node);
            }
            if (extra.attachComment) {
                processComment(node);
            }
            return node;
        }
    
        SyntaxTreeDelegate = {
    
            name: 'SyntaxTree',
    
            postProcess: function (node) {
                return node;
            },
    
            createArrayExpression: function (elements) {
                return {
                    type: Syntax.ArrayExpression,
                    elements: elements
                };
            },
    
            createAssignmentExpression: function (operator, left, right) {
                return {
                    type: Syntax.AssignmentExpression,
                    operator: operator,
                    left: left,
                    right: right
                };
            },
    
            createBinaryExpression: function (operator, left, right) {
                var type = (operator === '||' || operator === '&&') ? Syntax.LogicalExpression :
                            Syntax.BinaryExpression;
                return {
                    type: type,
                    operator: operator,
                    left: left,
                    right: right
                };
            },
    
            createBlockStatement: function (body) {
                return {
                    type: Syntax.BlockStatement,
                    body: body
                };
            },
    
            createBreakStatement: function (label) {
                return {
                    type: Syntax.BreakStatement,
                    label: label
                };
            },
    
            createCallExpression: function (callee, args) {
                return {
                    type: Syntax.CallExpression,
                    callee: callee,
                    'arguments': args
                };
            },
    
            createCatchClause: function (param, body) {
                return {
                    type: Syntax.CatchClause,
                    param: param,
                    body: body
                };
            },
    
            createConditionalExpression: function (test, consequent, alternate) {
                return {
                    type: Syntax.ConditionalExpression,
                    test: test,
                    consequent: consequent,
                    alternate: alternate
                };
            },
    
            createContinueStatement: function (label) {
                return {
                    type: Syntax.ContinueStatement,
                    label: label
                };
            },
    
            createDebuggerStatement: function () {
                return {
                    type: Syntax.DebuggerStatement
                };
            },
    
            createDoWhileStatement: function (body, test) {
                return {
                    type: Syntax.DoWhileStatement,
                    body: body,
                    test: test
                };
            },
    
            createEmptyStatement: function () {
                return {
                    type: Syntax.EmptyStatement
                };
            },
    
            createExpressionStatement: function (expression) {
                return {
                    type: Syntax.ExpressionStatement,
                    expression: expression
                };
            },
    
            createForStatement: function (init, test, update, body) {
                return {
                    type: Syntax.ForStatement,
                    init: init,
                    test: test,
                    update: update,
                    body: body
                };
            },
    
            createForInStatement: function (left, right, body) {
                return {
                    type: Syntax.ForInStatement,
                    left: left,
                    right: right,
                    body: body,
                    each: false
                };
            },
    
            createForOfStatement: function (left, right, body) {
                return {
                    type: Syntax.ForOfStatement,
                    left: left,
                    right: right,
                    body: body
                };
            },
    
            createFunctionDeclaration: function (id, params, defaults, body, rest, generator, expression,
                                                 isAsync, returnType, typeParameters) {
                var funDecl = {
                    type: Syntax.FunctionDeclaration,
                    id: id,
                    params: params,
                    defaults: defaults,
                    body: body,
                    rest: rest,
                    generator: generator,
                    expression: expression,
                    returnType: returnType,
                    typeParameters: typeParameters
                };
    
                if (isAsync) {
                    funDecl.async = true;
                }
    
                return funDecl;
            },
    
            createFunctionExpression: function (id, params, defaults, body, rest, generator, expression,
                                                isAsync, returnType, typeParameters) {
                var funExpr = {
                    type: Syntax.FunctionExpression,
                    id: id,
                    params: params,
                    defaults: defaults,
                    body: body,
                    rest: rest,
                    generator: generator,
                    expression: expression,
                    returnType: returnType,
                    typeParameters: typeParameters
                };
    
                if (isAsync) {
                    funExpr.async = true;
                }
    
                return funExpr;
            },
    
            createIdentifier: function (name) {
                return {
                    type: Syntax.Identifier,
                    name: name,
                    // Only here to initialize the shape of the object to ensure
                    // that the 'typeAnnotation' key is ordered before others that
                    // are added later (like 'loc' and 'range'). This just helps
                    // keep the shape of Identifier nodes consistent with everything
                    // else.
                    typeAnnotation: undefined,
                    optional: undefined
                };
            },
    
            createTypeAnnotation: function (typeAnnotation) {
                return {
                    type: Syntax.TypeAnnotation,
                    typeAnnotation: typeAnnotation
                };
            },
    
            createTypeCast: function (expression, typeAnnotation) {
                return {
                    type: Syntax.TypeCastExpression,
                    expression: expression,
                    typeAnnotation: typeAnnotation
                };
            },
    
            createFunctionTypeAnnotation: function (params, returnType, rest, typeParameters) {
                return {
                    type: Syntax.FunctionTypeAnnotation,
                    params: params,
                    returnType: returnType,
                    rest: rest,
                    typeParameters: typeParameters
                };
            },
    
            createFunctionTypeParam: function (name, typeAnnotation, optional) {
                return {
                    type: Syntax.FunctionTypeParam,
                    name: name,
                    typeAnnotation: typeAnnotation,
                    optional: optional
                };
            },
    
            createNullableTypeAnnotation: function (typeAnnotation) {
                return {
                    type: Syntax.NullableTypeAnnotation,
                    typeAnnotation: typeAnnotation
                };
            },
    
            createArrayTypeAnnotation: function (elementType) {
                return {
                    type: Syntax.ArrayTypeAnnotation,
                    elementType: elementType
                };
            },
    
            createGenericTypeAnnotation: function (id, typeParameters) {
                return {
                    type: Syntax.GenericTypeAnnotation,
                    id: id,
                    typeParameters: typeParameters
                };
            },
    
            createQualifiedTypeIdentifier: function (qualification, id) {
                return {
                    type: Syntax.QualifiedTypeIdentifier,
                    qualification: qualification,
                    id: id
                };
            },
    
            createTypeParameterDeclaration: function (params) {
                return {
                    type: Syntax.TypeParameterDeclaration,
                    params: params
                };
            },
    
            createTypeParameterInstantiation: function (params) {
                return {
                    type: Syntax.TypeParameterInstantiation,
                    params: params
                };
            },
    
            createAnyTypeAnnotation: function () {
                return {
                    type: Syntax.AnyTypeAnnotation
                };
            },
    
            createBooleanTypeAnnotation: function () {
                return {
                    type: Syntax.BooleanTypeAnnotation
                };
            },
    
            createNumberTypeAnnotation: function () {
                return {
                    type: Syntax.NumberTypeAnnotation
                };
            },
    
            createStringTypeAnnotation: function () {
                return {
                    type: Syntax.StringTypeAnnotation
                };
            },
    
            createStringLiteralTypeAnnotation: function (token) {
                return {
                    type: Syntax.StringLiteralTypeAnnotation,
                    value: token.value,
                    raw: source.slice(token.range[0], token.range[1])
                };
            },
    
            createVoidTypeAnnotation: function () {
                return {
                    type: Syntax.VoidTypeAnnotation
                };
            },
    
            createTypeofTypeAnnotation: function (argument) {
                return {
                    type: Syntax.TypeofTypeAnnotation,
                    argument: argument
                };
            },
    
            createTupleTypeAnnotation: function (types) {
                return {
                    type: Syntax.TupleTypeAnnotation,
                    types: types
                };
            },
    
            createObjectTypeAnnotation: function (properties, indexers, callProperties) {
                return {
                    type: Syntax.ObjectTypeAnnotation,
                    properties: properties,
                    indexers: indexers,
                    callProperties: callProperties
                };
            },
    
            createObjectTypeIndexer: function (id, key, value, isStatic) {
                return {
                    type: Syntax.ObjectTypeIndexer,
                    id: id,
                    key: key,
                    value: value,
                    static: isStatic
                };
            },
    
            createObjectTypeCallProperty: function (value, isStatic) {
                return {
                    type: Syntax.ObjectTypeCallProperty,
                    value: value,
                    static: isStatic
                };
            },
    
            createObjectTypeProperty: function (key, value, optional, isStatic) {
                return {
                    type: Syntax.ObjectTypeProperty,
                    key: key,
                    value: value,
                    optional: optional,
                    static: isStatic
                };
            },
    
            createUnionTypeAnnotation: function (types) {
                return {
                    type: Syntax.UnionTypeAnnotation,
                    types: types
                };
            },
    
            createIntersectionTypeAnnotation: function (types) {
                return {
                    type: Syntax.IntersectionTypeAnnotation,
                    types: types
                };
            },
    
            createTypeAlias: function (id, typeParameters, right) {
                return {
                    type: Syntax.TypeAlias,
                    id: id,
                    typeParameters: typeParameters,
                    right: right
                };
            },
    
            createInterface: function (id, typeParameters, body, extended) {
                return {
                    type: Syntax.InterfaceDeclaration,
                    id: id,
                    typeParameters: typeParameters,
                    body: body,
                    extends: extended
                };
            },
    
            createInterfaceExtends: function (id, typeParameters) {
                return {
                    type: Syntax.InterfaceExtends,
                    id: id,
                    typeParameters: typeParameters
                };
            },
    
            createDeclareFunction: function (id) {
                return {
                    type: Syntax.DeclareFunction,
                    id: id
                };
            },
    
            createDeclareVariable: function (id) {
                return {
                    type: Syntax.DeclareVariable,
                    id: id
                };
            },
    
            createDeclareModule: function (id, body) {
                return {
                    type: Syntax.DeclareModule,
                    id: id,
                    body: body
                };
            },
    
            createJSXAttribute: function (name, value) {
                return {
                    type: Syntax.JSXAttribute,
                    name: name,
                    value: value || null
                };
            },
    
            createJSXSpreadAttribute: function (argument) {
                return {
                    type: Syntax.JSXSpreadAttribute,
                    argument: argument
                };
            },
    
            createJSXIdentifier: function (name) {
                return {
                    type: Syntax.JSXIdentifier,
                    name: name
                };
            },
    
            createJSXNamespacedName: function (namespace, name) {
                return {
                    type: Syntax.JSXNamespacedName,
                    namespace: namespace,
                    name: name
                };
            },
    
            createJSXMemberExpression: function (object, property) {
                return {
                    type: Syntax.JSXMemberExpression,
                    object: object,
                    property: property
                };
            },
    
            createJSXElement: function (openingElement, closingElement, children) {
                return {
                    type: Syntax.JSXElement,
                    openingElement: openingElement,
                    closingElement: closingElement,
                    children: children
                };
            },
    
            createJSXEmptyExpression: function () {
                return {
                    type: Syntax.JSXEmptyExpression
                };
            },
    
            createJSXExpressionContainer: function (expression) {
                return {
                    type: Syntax.JSXExpressionContainer,
                    expression: expression
                };
            },
    
            createJSXOpeningElement: function (name, attributes, selfClosing) {
                return {
                    type: Syntax.JSXOpeningElement,
                    name: name,
                    selfClosing: selfClosing,
                    attributes: attributes
                };
            },
    
            createJSXClosingElement: function (name) {
                return {
                    type: Syntax.JSXClosingElement,
                    name: name
                };
            },
    
            createIfStatement: function (test, consequent, alternate) {
                return {
                    type: Syntax.IfStatement,
                    test: test,
                    consequent: consequent,
                    alternate: alternate
                };
            },
    
            createLabeledStatement: function (label, body) {
                return {
                    type: Syntax.LabeledStatement,
                    label: label,
                    body: body
                };
            },
    
            createLiteral: function (token) {
                var object = {
                    type: Syntax.Literal,
                    value: token.value,
                    raw: source.slice(token.range[0], token.range[1])
                };
                if (token.regex) {
                    object.regex = token.regex;
                }
                return object;
            },
    
            createMemberExpression: function (accessor, object, property) {
                return {
                    type: Syntax.MemberExpression,
                    computed: accessor === '[',
                    object: object,
                    property: property
                };
            },
    
            createNewExpression: function (callee, args) {
                return {
                    type: Syntax.NewExpression,
                    callee: callee,
                    'arguments': args
                };
            },
    
            createObjectExpression: function (properties) {
                return {
                    type: Syntax.ObjectExpression,
                    properties: properties
                };
            },
    
            createPostfixExpression: function (operator, argument) {
                return {
                    type: Syntax.UpdateExpression,
                    operator: operator,
                    argument: argument,
                    prefix: false
                };
            },
    
            createProgram: function (body) {
                return {
                    type: Syntax.Program,
                    body: body
                };
            },
    
            createProperty: function (kind, key, value, method, shorthand, computed) {
                return {
                    type: Syntax.Property,
                    key: key,
                    value: value,
                    kind: kind,
                    method: method,
                    shorthand: shorthand,
                    computed: computed
                };
            },
    
            createReturnStatement: function (argument) {
                return {
                    type: Syntax.ReturnStatement,
                    argument: argument
                };
            },
    
            createSequenceExpression: function (expressions) {
                return {
                    type: Syntax.SequenceExpression,
                    expressions: expressions
                };
            },
    
            createSwitchCase: function (test, consequent) {
                return {
                    type: Syntax.SwitchCase,
                    test: test,
                    consequent: consequent
                };
            },
    
            createSwitchStatement: function (discriminant, cases) {
                return {
                    type: Syntax.SwitchStatement,
                    discriminant: discriminant,
                    cases: cases
                };
            },
    
            createThisExpression: function () {
                return {
                    type: Syntax.ThisExpression
                };
            },
    
            createThrowStatement: function (argument) {
                return {
                    type: Syntax.ThrowStatement,
                    argument: argument
                };
            },
    
            createTryStatement: function (block, guardedHandlers, handlers, finalizer) {
                return {
                    type: Syntax.TryStatement,
                    block: block,
                    guardedHandlers: guardedHandlers,
                    handlers: handlers,
                    finalizer: finalizer
                };
            },
    
            createUnaryExpression: function (operator, argument) {
                if (operator === '++' || operator === '--') {
                    return {
                        type: Syntax.UpdateExpression,
                        operator: operator,
                        argument: argument,
                        prefix: true
                    };
                }
                return {
                    type: Syntax.UnaryExpression,
                    operator: operator,
                    argument: argument,
                    prefix: true
                };
            },
    
            createVariableDeclaration: function (declarations, kind) {
                return {
                    type: Syntax.VariableDeclaration,
                    declarations: declarations,
                    kind: kind
                };
            },
    
            createVariableDeclarator: function (id, init) {
                return {
                    type: Syntax.VariableDeclarator,
                    id: id,
                    init: init
                };
            },
    
            createWhileStatement: function (test, body) {
                return {
                    type: Syntax.WhileStatement,
                    test: test,
                    body: body
                };
            },
    
            createWithStatement: function (object, body) {
                return {
                    type: Syntax.WithStatement,
                    object: object,
                    body: body
                };
            },
    
            createTemplateElement: function (value, tail) {
                return {
                    type: Syntax.TemplateElement,
                    value: value,
                    tail: tail
                };
            },
    
            createTemplateLiteral: function (quasis, expressions) {
                return {
                    type: Syntax.TemplateLiteral,
                    quasis: quasis,
                    expressions: expressions
                };
            },
    
            createSpreadElement: function (argument) {
                return {
                    type: Syntax.SpreadElement,
                    argument: argument
                };
            },
    
            createSpreadProperty: function (argument) {
                return {
                    type: Syntax.SpreadProperty,
                    argument: argument
                };
            },
    
            createTaggedTemplateExpression: function (tag, quasi) {
                return {
                    type: Syntax.TaggedTemplateExpression,
                    tag: tag,
                    quasi: quasi
                };
            },
    
            createArrowFunctionExpression: function (params, defaults, body, rest, expression, isAsync) {
                var arrowExpr = {
                    type: Syntax.ArrowFunctionExpression,
                    id: null,
                    params: params,
                    defaults: defaults,
                    body: body,
                    rest: rest,
                    generator: false,
                    expression: expression
                };
    
                if (isAsync) {
                    arrowExpr.async = true;
                }
    
                return arrowExpr;
            },
    
            createMethodDefinition: function (propertyType, kind, key, value, computed) {
                return {
                    type: Syntax.MethodDefinition,
                    key: key,
                    value: value,
                    kind: kind,
                    'static': propertyType === ClassPropertyType.static,
                    computed: computed
                };
            },
    
            createClassProperty: function (key, typeAnnotation, computed, isStatic) {
                return {
                    type: Syntax.ClassProperty,
                    key: key,
                    typeAnnotation: typeAnnotation,
                    computed: computed,
                    static: isStatic
                };
            },
    
            createClassBody: function (body) {
                return {
                    type: Syntax.ClassBody,
                    body: body
                };
            },
    
            createClassImplements: function (id, typeParameters) {
                return {
                    type: Syntax.ClassImplements,
                    id: id,
                    typeParameters: typeParameters
                };
            },
    
            createClassExpression: function (id, superClass, body, typeParameters, superTypeParameters, implemented) {
                return {
                    type: Syntax.ClassExpression,
                    id: id,
                    superClass: superClass,
                    body: body,
                    typeParameters: typeParameters,
                    superTypeParameters: superTypeParameters,
                    implements: implemented
                };
            },
    
            createClassDeclaration: function (id, superClass, body, typeParameters, superTypeParameters, implemented) {
                return {
                    type: Syntax.ClassDeclaration,
                    id: id,
                    superClass: superClass,
                    body: body,
                    typeParameters: typeParameters,
                    superTypeParameters: superTypeParameters,
                    implements: implemented
                };
            },
    
            createModuleSpecifier: function (token) {
                return {
                    type: Syntax.ModuleSpecifier,
                    value: token.value,
                    raw: source.slice(token.range[0], token.range[1])
                };
            },
    
            createExportSpecifier: function (id, name) {
                return {
                    type: Syntax.ExportSpecifier,
                    id: id,
                    name: name
                };
            },
    
            createExportBatchSpecifier: function () {
                return {
                    type: Syntax.ExportBatchSpecifier
                };
            },
    
            createImportDefaultSpecifier: function (id) {
                return {
                    type: Syntax.ImportDefaultSpecifier,
                    id: id
                };
            },
    
            createImportNamespaceSpecifier: function (id) {
                return {
                    type: Syntax.ImportNamespaceSpecifier,
                    id: id
                };
            },
    
            createExportDeclaration: function (isDefault, declaration, specifiers, src) {
                return {
                    type: Syntax.ExportDeclaration,
                    'default': !!isDefault,
                    declaration: declaration,
                    specifiers: specifiers,
                    source: src
                };
            },
    
            createImportSpecifier: function (id, name) {
                return {
                    type: Syntax.ImportSpecifier,
                    id: id,
                    name: name
                };
            },
    
            createImportDeclaration: function (specifiers, src, isType) {
                return {
                    type: Syntax.ImportDeclaration,
                    specifiers: specifiers,
                    source: src,
                    isType: isType
                };
            },
    
            createYieldExpression: function (argument, dlg) {
                return {
                    type: Syntax.YieldExpression,
                    argument: argument,
                    delegate: dlg
                };
            },
    
            createAwaitExpression: function (argument) {
                return {
                    type: Syntax.AwaitExpression,
                    argument: argument
                };
            },
    
            createComprehensionExpression: function (filter, blocks, body) {
                return {
                    type: Syntax.ComprehensionExpression,
                    filter: filter,
                    blocks: blocks,
                    body: body
                };
            }
    
        };
    
        // Return true if there is a line terminator before the next token.
    
        function peekLineTerminator() {
            var pos, line, start, found;
    
            pos = index;
            line = lineNumber;
            start = lineStart;
            skipComment();
            found = lineNumber !== line;
            index = pos;
            lineNumber = line;
            lineStart = start;
    
            return found;
        }
    
        // Throw an exception
    
        function throwError(token, messageFormat) {
            var error,
                args = Array.prototype.slice.call(arguments, 2),
                msg = messageFormat.replace(
                    /%(\d)/g,
                    function (whole, idx) {
                        assert(idx < args.length, 'Message reference must be in range');
                        return args[idx];
                    }
                );
    
            if (typeof token.lineNumber === 'number') {
                error = new Error('Line ' + token.lineNumber + ': ' + msg);
                error.index = token.range[0];
                error.lineNumber = token.lineNumber;
                error.column = token.range[0] - lineStart + 1;
            } else {
                error = new Error('Line ' + lineNumber + ': ' + msg);
                error.index = index;
                error.lineNumber = lineNumber;
                error.column = index - lineStart + 1;
            }
    
            error.description = msg;
            throw error;
        }
    
        function throwErrorTolerant() {
            try {
                throwError.apply(null, arguments);
            } catch (e) {
                if (extra.errors) {
                    extra.errors.push(e);
                } else {
                    throw e;
                }
            }
        }
    
    
        // Throw an exception because of the token.
    
        function throwUnexpected(token) {
            if (token.type === Token.EOF) {
                throwError(token, Messages.UnexpectedEOS);
            }
    
            if (token.type === Token.NumericLiteral) {
                throwError(token, Messages.UnexpectedNumber);
            }
    
            if (token.type === Token.StringLiteral || token.type === Token.JSXText) {
                throwError(token, Messages.UnexpectedString);
            }
    
            if (token.type === Token.Identifier) {
                throwError(token, Messages.UnexpectedIdentifier);
            }
    
            if (token.type === Token.Keyword) {
                if (isFutureReservedWord(token.value)) {
                    throwError(token, Messages.UnexpectedReserved);
                } else if (strict && isStrictModeReservedWord(token.value)) {
                    throwErrorTolerant(token, Messages.StrictReservedWord);
                    return;
                }
                throwError(token, Messages.UnexpectedToken, token.value);
            }
    
            if (token.type === Token.Template) {
                throwError(token, Messages.UnexpectedTemplate, token.value.raw);
            }
    
            // BooleanLiteral, NullLiteral, or Punctuator.
            throwError(token, Messages.UnexpectedToken, token.value);
        }
    
        // Expect the next token to match the specified punctuator.
        // If not, an exception will be thrown.
    
        function expect(value) {
            var token = lex();
            if (token.type !== Token.Punctuator || token.value !== value) {
                throwUnexpected(token);
            }
        }
    
        // Expect the next token to match the specified keyword.
        // If not, an exception will be thrown.
    
        function expectKeyword(keyword, contextual) {
            var token = lex();
            if (token.type !== (contextual ? Token.Identifier : Token.Keyword) ||
                    token.value !== keyword) {
                throwUnexpected(token);
            }
        }
    
        // Expect the next token to match the specified contextual keyword.
        // If not, an exception will be thrown.
    
        function expectContextualKeyword(keyword) {
            return expectKeyword(keyword, true);
        }
    
        // Return true if the next token matches the specified punctuator.
    
        function match(value) {
            return lookahead.type === Token.Punctuator && lookahead.value === value;
        }
    
        // Return true if the next token matches the specified keyword
    
        function matchKeyword(keyword, contextual) {
            var expectedType = contextual ? Token.Identifier : Token.Keyword;
            return lookahead.type === expectedType && lookahead.value === keyword;
        }
    
        // Return true if the next token matches the specified contextual keyword
    
        function matchContextualKeyword(keyword) {
            return matchKeyword(keyword, true);
        }
    
        // Return true if the next token is an assignment operator
    
        function matchAssign() {
            var op;
    
            if (lookahead.type !== Token.Punctuator) {
                return false;
            }
            op = lookahead.value;
            return op === '=' ||
                op === '*=' ||
                op === '/=' ||
                op === '%=' ||
                op === '+=' ||
                op === '-=' ||
                op === '<<=' ||
                op === '>>=' ||
                op === '>>>=' ||
                op === '&=' ||
                op === '^=' ||
                op === '|=';
        }
    
        // Note that 'yield' is treated as a keyword in strict mode, but a
        // contextual keyword (identifier) in non-strict mode, so we need to
        // use matchKeyword('yield', false) and matchKeyword('yield', true)
        // (i.e. matchContextualKeyword) appropriately.
        function matchYield() {
            return state.yieldAllowed && matchKeyword('yield', !strict);
        }
    
        function matchAsync() {
            var backtrackToken = lookahead, matches = false;
    
            if (matchContextualKeyword('async')) {
                lex(); // Make sure peekLineTerminator() starts after 'async'.
                matches = !peekLineTerminator();
                rewind(backtrackToken); // Revert the lex().
            }
    
            return matches;
        }
    
        function matchAwait() {
            return state.awaitAllowed && matchContextualKeyword('await');
        }
    
        function consumeSemicolon() {
            var line, oldIndex = index, oldLineNumber = lineNumber,
                oldLineStart = lineStart, oldLookahead = lookahead;
    
            // Catch the very common case first: immediately a semicolon (char #59).
            if (source.charCodeAt(index) === 59) {
                lex();
                return;
            }
    
            line = lineNumber;
            skipComment();
            if (lineNumber !== line) {
                index = oldIndex;
                lineNumber = oldLineNumber;
                lineStart = oldLineStart;
                lookahead = oldLookahead;
                return;
            }
    
            if (match(';')) {
                lex();
                return;
            }
    
            if (lookahead.type !== Token.EOF && !match('}')) {
                throwUnexpected(lookahead);
            }
        }
    
        // Return true if provided expression is LeftHandSideExpression
    
        function isLeftHandSide(expr) {
            return expr.type === Syntax.Identifier || expr.type === Syntax.MemberExpression;
        }
    
        function isAssignableLeftHandSide(expr) {
            return isLeftHandSide(expr) || expr.type === Syntax.ObjectPattern || expr.type === Syntax.ArrayPattern;
        }
    
        // 11.1.4 Array Initialiser
    
        function parseArrayInitialiser() {
            var elements = [], blocks = [], filter = null, tmp, possiblecomprehension = true,
                marker = markerCreate();
    
            expect('[');
            while (!match(']')) {
                if (lookahead.value === 'for' &&
                        lookahead.type === Token.Keyword) {
                    if (!possiblecomprehension) {
                        throwError({}, Messages.ComprehensionError);
                    }
                    matchKeyword('for');
                    tmp = parseForStatement({ignoreBody: true});
                    tmp.of = tmp.type === Syntax.ForOfStatement;
                    tmp.type = Syntax.ComprehensionBlock;
                    if (tmp.left.kind) { // can't be let or const
                        throwError({}, Messages.ComprehensionError);
                    }
                    blocks.push(tmp);
                } else if (lookahead.value === 'if' &&
                               lookahead.type === Token.Keyword) {
                    if (!possiblecomprehension) {
                        throwError({}, Messages.ComprehensionError);
                    }
                    expectKeyword('if');
                    expect('(');
                    filter = parseExpression();
                    expect(')');
                } else if (lookahead.value === ',' &&
                               lookahead.type === Token.Punctuator) {
                    possiblecomprehension = false; // no longer allowed.
                    lex();
                    elements.push(null);
                } else {
                    tmp = parseSpreadOrAssignmentExpression();
                    elements.push(tmp);
                    if (tmp && tmp.type === Syntax.SpreadElement) {
                        if (!match(']')) {
                            throwError({}, Messages.ElementAfterSpreadElement);
                        }
                    } else if (!(match(']') || matchKeyword('for') || matchKeyword('if'))) {
                        expect(','); // this lexes.
                        possiblecomprehension = false;
                    }
                }
            }
    
            expect(']');
    
            if (filter && !blocks.length) {
                throwError({}, Messages.ComprehensionRequiresBlock);
            }
    
            if (blocks.length) {
                if (elements.length !== 1) {
                    throwError({}, Messages.ComprehensionError);
                }
                return markerApply(marker, delegate.createComprehensionExpression(filter, blocks, elements[0]));
            }
            return markerApply(marker, delegate.createArrayExpression(elements));
        }
    
        // 11.1.5 Object Initialiser
    
        function parsePropertyFunction(options) {
            var previousStrict, previousYieldAllowed, previousAwaitAllowed,
                params, defaults, body, marker = markerCreate();
    
            previousStrict = strict;
            previousYieldAllowed = state.yieldAllowed;
            state.yieldAllowed = options.generator;
            previousAwaitAllowed = state.awaitAllowed;
            state.awaitAllowed = options.async;
            params = options.params || [];
            defaults = options.defaults || [];
    
            body = parseConciseBody();
            if (options.name && strict && isRestrictedWord(params[0].name)) {
                throwErrorTolerant(options.name, Messages.StrictParamName);
            }
            strict = previousStrict;
            state.yieldAllowed = previousYieldAllowed;
            state.awaitAllowed = previousAwaitAllowed;
    
            return markerApply(marker, delegate.createFunctionExpression(
                null,
                params,
                defaults,
                body,
                options.rest || null,
                options.generator,
                body.type !== Syntax.BlockStatement,
                options.async,
                options.returnType,
                options.typeParameters
            ));
        }
    
    
        function parsePropertyMethodFunction(options) {
            var previousStrict, tmp, method;
    
            previousStrict = strict;
            strict = true;
    
            tmp = parseParams();
    
            if (tmp.stricted) {
                throwErrorTolerant(tmp.stricted, tmp.message);
            }
    
            method = parsePropertyFunction({
                params: tmp.params,
                defaults: tmp.defaults,
                rest: tmp.rest,
                generator: options.generator,
                async: options.async,
                returnType: tmp.returnType,
                typeParameters: options.typeParameters
            });
    
            strict = previousStrict;
    
            return method;
        }
    
    
        function parseObjectPropertyKey() {
            var marker = markerCreate(),
                token = lex(),
                propertyKey,
                result;
    
            // Note: This function is called only from parseObjectProperty(), where
            // EOF and Punctuator tokens are already filtered out.
    
            if (token.type === Token.StringLiteral || token.type === Token.NumericLiteral) {
                if (strict && token.octal) {
                    throwErrorTolerant(token, Messages.StrictOctalLiteral);
                }
                return markerApply(marker, delegate.createLiteral(token));
            }
    
            if (token.type === Token.Punctuator && token.value === '[') {
                // For computed properties we should skip the [ and ], and
                // capture in marker only the assignment expression itself.
                marker = markerCreate();
                propertyKey = parseAssignmentExpression();
                result = markerApply(marker, propertyKey);
                expect(']');
                return result;
            }
    
            return markerApply(marker, delegate.createIdentifier(token.value));
        }
    
        function parseObjectProperty() {
            var token, key, id, param, computed,
                marker = markerCreate(), returnType, typeParameters;
    
            token = lookahead;
            computed = (token.value === '[' && token.type === Token.Punctuator);
    
            if (token.type === Token.Identifier || computed || matchAsync()) {
                id = parseObjectPropertyKey();
    
                if (match(':')) {
                    lex();
    
                    return markerApply(
                        marker,
                        delegate.createProperty(
                            'init',
                            id,
                            parseAssignmentExpression(),
                            false,
                            false,
                            computed
                        )
                    );
                }
    
                if (match('(') || match('<')) {
                    if (match('<')) {
                        typeParameters = parseTypeParameterDeclaration();
                    }
                    return markerApply(
                        marker,
                        delegate.createProperty(
                            'init',
                            id,
                            parsePropertyMethodFunction({
                                generator: false,
                                async: false,
                                typeParameters: typeParameters
                            }),
                            true,
                            false,
                            computed
                        )
                    );
                }
    
                // Property Assignment: Getter and Setter.
    
                if (token.value === 'get') {
                    computed = (lookahead.value === '[');
                    key = parseObjectPropertyKey();
    
                    expect('(');
                    expect(')');
                    if (match(':')) {
                        returnType = parseTypeAnnotation();
                    }
    
                    return markerApply(
                        marker,
                        delegate.createProperty(
                            'get',
                            key,
                            parsePropertyFunction({
                                generator: false,
                                async: false,
                                returnType: returnType
                            }),
                            false,
                            false,
                            computed
                        )
                    );
                }
    
                if (token.value === 'set') {
                    computed = (lookahead.value === '[');
                    key = parseObjectPropertyKey();
    
                    expect('(');
                    token = lookahead;
                    param = [ parseTypeAnnotatableIdentifier() ];
                    expect(')');
                    if (match(':')) {
                        returnType = parseTypeAnnotation();
                    }
    
                    return markerApply(
                        marker,
                        delegate.createProperty(
                            'set',
                            key,
                            parsePropertyFunction({
                                params: param,
                                generator: false,
                                async: false,
                                name: token,
                                returnType: returnType
                            }),
                            false,
                            false,
                            computed
                        )
                    );
                }
    
                if (token.value === 'async') {
                    computed = (lookahead.value === '[');
                    key = parseObjectPropertyKey();
    
                    if (match('<')) {
                        typeParameters = parseTypeParameterDeclaration();
                    }
    
                    return markerApply(
                        marker,
                        delegate.createProperty(
                            'init',
                            key,
                            parsePropertyMethodFunction({
                                generator: false,
                                async: true,
                                typeParameters: typeParameters
                            }),
                            true,
                            false,
                            computed
                        )
                    );
                }
    
                if (computed) {
                    // Computed properties can only be used with full notation.
                    throwUnexpected(lookahead);
                }
    
                return markerApply(
                    marker,
                    delegate.createProperty('init', id, id, false, true, false)
                );
            }
    
            if (token.type === Token.EOF || token.type === Token.Punctuator) {
                if (!match('*')) {
                    throwUnexpected(token);
                }
                lex();
    
                computed = (lookahead.type === Token.Punctuator && lookahead.value === '[');
    
                id = parseObjectPropertyKey();
    
                if (match('<')) {
                    typeParameters = parseTypeParameterDeclaration();
                }
    
                if (!match('(')) {
                    throwUnexpected(lex());
                }
    
                return markerApply(marker, delegate.createProperty(
                    'init',
                    id,
                    parsePropertyMethodFunction({
                        generator: true,
                        typeParameters: typeParameters
                    }),
                    true,
                    false,
                    computed
                ));
            }
            key = parseObjectPropertyKey();
            if (match(':')) {
                lex();
                return markerApply(marker, delegate.createProperty('init', key, parseAssignmentExpression(), false, false, false));
            }
            if (match('(') || match('<')) {
                if (match('<')) {
                    typeParameters = parseTypeParameterDeclaration();
                }
                return markerApply(marker, delegate.createProperty(
                    'init',
                    key,
                    parsePropertyMethodFunction({
                        generator: false,
                        typeParameters: typeParameters
                    }),
                    true,
                    false,
                    false
                ));
            }
            throwUnexpected(lex());
        }
    
        function parseObjectSpreadProperty() {
            var marker = markerCreate();
            expect('...');
            return markerApply(marker, delegate.createSpreadProperty(parseAssignmentExpression()));
        }
    
        function getFieldName(key) {
            var toString = String;
            if (key.type === Syntax.Identifier) {
                return key.name;
            }
            return toString(key.value);
        }
    
        function parseObjectInitialiser() {
            var properties = [], property, name, kind, storedKind, map = new StringMap(),
                marker = markerCreate(), toString = String;
    
            expect('{');
    
            while (!match('}')) {
                if (match('...')) {
                    property = parseObjectSpreadProperty();
                } else {
                    property = parseObjectProperty();
    
                    if (property.key.type === Syntax.Identifier) {
                        name = property.key.name;
                    } else {
                        name = toString(property.key.value);
                    }
                    kind = (property.kind === 'init') ? PropertyKind.Data : (property.kind === 'get') ? PropertyKind.Get : PropertyKind.Set;
    
                    if (map.has(name)) {
                        storedKind = map.get(name);
                        if (storedKind === PropertyKind.Data) {
                            if (strict && kind === PropertyKind.Data) {
                                throwErrorTolerant({}, Messages.StrictDuplicateProperty);
                            } else if (kind !== PropertyKind.Data) {
                                throwErrorTolerant({}, Messages.AccessorDataProperty);
                            }
                        } else {
                            if (kind === PropertyKind.Data) {
                                throwErrorTolerant({}, Messages.AccessorDataProperty);
                            } else if (storedKind & kind) {
                                throwErrorTolerant({}, Messages.AccessorGetSet);
                            }
                        }
                        map.set(name, storedKind | kind);
                    } else {
                        map.set(name, kind);
                    }
                }
    
                properties.push(property);
    
                if (!match('}')) {
                    expect(',');
                }
            }
    
            expect('}');
    
            return markerApply(marker, delegate.createObjectExpression(properties));
        }
    
        function parseTemplateElement(option) {
            var marker = markerCreate(),
                token = scanTemplateElement(option);
            if (strict && token.octal) {
                throwError(token, Messages.StrictOctalLiteral);
            }
            return markerApply(marker, delegate.createTemplateElement({ raw: token.value.raw, cooked: token.value.cooked }, token.tail));
        }
    
        function parseTemplateLiteral() {
            var quasi, quasis, expressions, marker = markerCreate();
    
            quasi = parseTemplateElement({ head: true });
            quasis = [ quasi ];
            expressions = [];
    
            while (!quasi.tail) {
                expressions.push(parseExpression());
                quasi = parseTemplateElement({ head: false });
                quasis.push(quasi);
            }
    
            return markerApply(marker, delegate.createTemplateLiteral(quasis, expressions));
        }
    
        // 11.1.6 The Grouping Operator
    
        function parseGroupExpression() {
            var expr, marker, typeAnnotation;
    
            expect('(');
    
            ++state.parenthesizedCount;
    
            marker = markerCreate();
    
            expr = parseExpression();
    
            if (match(':')) {
                typeAnnotation = parseTypeAnnotation();
                expr = markerApply(marker, delegate.createTypeCast(
                    expr,
                    typeAnnotation
                ));
            }
    
            expect(')');
    
            return expr;
        }
    
        function matchAsyncFuncExprOrDecl() {
            var token;
    
            if (matchAsync()) {
                token = lookahead2();
                if (token.type === Token.Keyword && token.value === 'function') {
                    return true;
                }
            }
    
            return false;
        }
    
        // 11.1 Primary Expressions
    
        function parsePrimaryExpression() {
            var marker, type, token, expr;
    
            type = lookahead.type;
    
            if (type === Token.Identifier) {
                marker = markerCreate();
                return markerApply(marker, delegate.createIdentifier(lex().value));
            }
    
            if (type === Token.StringLiteral || type === Token.NumericLiteral) {
                if (strict && lookahead.octal) {
                    throwErrorTolerant(lookahead, Messages.StrictOctalLiteral);
                }
                marker = markerCreate();
                return markerApply(marker, delegate.createLiteral(lex()));
            }
    
            if (type === Token.Keyword) {
                if (matchKeyword('this')) {
                    marker = markerCreate();
                    lex();
                    return markerApply(marker, delegate.createThisExpression());
                }
    
                if (matchKeyword('function')) {
                    return parseFunctionExpression();
                }
    
                if (matchKeyword('class')) {
                    return parseClassExpression();
                }
    
                if (matchKeyword('super')) {
                    marker = markerCreate();
                    lex();
                    return markerApply(marker, delegate.createIdentifier('super'));
                }
            }
    
            if (type === Token.BooleanLiteral) {
                marker = markerCreate();
                token = lex();
                token.value = (token.value === 'true');
                return markerApply(marker, delegate.createLiteral(token));
            }
    
            if (type === Token.NullLiteral) {
                marker = markerCreate();
                token = lex();
                token.value = null;
                return markerApply(marker, delegate.createLiteral(token));
            }
    
            if (match('[')) {
                return parseArrayInitialiser();
            }
    
            if (match('{')) {
                return parseObjectInitialiser();
            }
    
            if (match('(')) {
                return parseGroupExpression();
            }
    
            if (match('/') || match('/=')) {
                marker = markerCreate();
                expr = delegate.createLiteral(scanRegExp());
                peek();
                return markerApply(marker, expr);
            }
    
            if (type === Token.Template) {
                return parseTemplateLiteral();
            }
    
            if (match('<')) {
                return parseJSXElement();
            }
    
            throwUnexpected(lex());
        }
    
        // 11.2 Left-Hand-Side Expressions
    
        function parseArguments() {
            var args = [], arg;
    
            expect('(');
    
            if (!match(')')) {
                while (index < length) {
                    arg = parseSpreadOrAssignmentExpression();
                    args.push(arg);
    
                    if (match(')')) {
                        break;
                    } else if (arg.type === Syntax.SpreadElement) {
                        throwError({}, Messages.ElementAfterSpreadElement);
                    }
    
                    expect(',');
                }
            }
    
            expect(')');
    
            return args;
        }
    
        function parseSpreadOrAssignmentExpression() {
            if (match('...')) {
                var marker = markerCreate();
                lex();
                return markerApply(marker, delegate.createSpreadElement(parseAssignmentExpression()));
            }
            return parseAssignmentExpression();
        }
    
        function parseNonComputedProperty() {
            var marker = markerCreate(),
                token = lex();
    
            if (!isIdentifierName(token)) {
                throwUnexpected(token);
            }
    
            return markerApply(marker, delegate.createIdentifier(token.value));
        }
    
        function parseNonComputedMember() {
            expect('.');
    
            return parseNonComputedProperty();
        }
    
        function parseComputedMember() {
            var expr;
    
            expect('[');
    
            expr = parseExpression();
    
            expect(']');
    
            return expr;
        }
    
        function parseNewExpression() {
            var callee, args, marker = markerCreate();
    
            expectKeyword('new');
            callee = parseLeftHandSideExpression();
            args = match('(') ? parseArguments() : [];
    
            return markerApply(marker, delegate.createNewExpression(callee, args));
        }
    
        function parseLeftHandSideExpressionAllowCall() {
            var expr, args, marker = markerCreate();
    
            expr = matchKeyword('new') ? parseNewExpression() : parsePrimaryExpression();
    
            while (match('.') || match('[') || match('(') || lookahead.type === Token.Template) {
                if (match('(')) {
                    args = parseArguments();
                    expr = markerApply(marker, delegate.createCallExpression(expr, args));
                } else if (match('[')) {
                    expr = markerApply(marker, delegate.createMemberExpression('[', expr, parseComputedMember()));
                } else if (match('.')) {
                    expr = markerApply(marker, delegate.createMemberExpression('.', expr, parseNonComputedMember()));
                } else {
                    expr = markerApply(marker, delegate.createTaggedTemplateExpression(expr, parseTemplateLiteral()));
                }
            }
    
            return expr;
        }
    
        function parseLeftHandSideExpression() {
            var expr, marker = markerCreate();
    
            expr = matchKeyword('new') ? parseNewExpression() : parsePrimaryExpression();
    
            while (match('.') || match('[') || lookahead.type === Token.Template) {
                if (match('[')) {
                    expr = markerApply(marker, delegate.createMemberExpression('[', expr, parseComputedMember()));
                } else if (match('.')) {
                    expr = markerApply(marker, delegate.createMemberExpression('.', expr, parseNonComputedMember()));
                } else {
                    expr = markerApply(marker, delegate.createTaggedTemplateExpression(expr, parseTemplateLiteral()));
                }
            }
    
            return expr;
        }
    
        // 11.3 Postfix Expressions
    
        function parsePostfixExpression() {
            var marker = markerCreate(),
                expr = parseLeftHandSideExpressionAllowCall(),
                token;
    
            if (lookahead.type !== Token.Punctuator) {
                return expr;
            }
    
            if ((match('++') || match('--')) && !peekLineTerminator()) {
                // 11.3.1, 11.3.2
                if (strict && expr.type === Syntax.Identifier && isRestrictedWord(expr.name)) {
                    throwErrorTolerant({}, Messages.StrictLHSPostfix);
                }
    
                if (!isLeftHandSide(expr)) {
                    throwError({}, Messages.InvalidLHSInAssignment);
                }
    
                token = lex();
                expr = markerApply(marker, delegate.createPostfixExpression(token.value, expr));
            }
    
            return expr;
        }
    
        // 11.4 Unary Operators
    
        function parseUnaryExpression() {
            var marker, token, expr;
    
            if (lookahead.type !== Token.Punctuator && lookahead.type !== Token.Keyword) {
                return parsePostfixExpression();
            }
    
            if (match('++') || match('--')) {
                marker = markerCreate();
                token = lex();
                expr = parseUnaryExpression();
                // 11.4.4, 11.4.5
                if (strict && expr.type === Syntax.Identifier && isRestrictedWord(expr.name)) {
                    throwErrorTolerant({}, Messages.StrictLHSPrefix);
                }
    
                if (!isLeftHandSide(expr)) {
                    throwError({}, Messages.InvalidLHSInAssignment);
                }
    
                return markerApply(marker, delegate.createUnaryExpression(token.value, expr));
            }
    
            if (match('+') || match('-') || match('~') || match('!')) {
                marker = markerCreate();
                token = lex();
                expr = parseUnaryExpression();
                return markerApply(marker, delegate.createUnaryExpression(token.value, expr));
            }
    
            if (matchKeyword('delete') || matchKeyword('void') || matchKeyword('typeof')) {
                marker = markerCreate();
                token = lex();
                expr = parseUnaryExpression();
                expr = markerApply(marker, delegate.createUnaryExpression(token.value, expr));
                if (strict && expr.operator === 'delete' && expr.argument.type === Syntax.Identifier) {
                    throwErrorTolerant({}, Messages.StrictDelete);
                }
                return expr;
            }
    
            return parsePostfixExpression();
        }
    
        function binaryPrecedence(token, allowIn) {
            var prec = 0;
    
            if (token.type !== Token.Punctuator && token.type !== Token.Keyword) {
                return 0;
            }
    
            switch (token.value) {
            case '||':
                prec = 1;
                break;
    
            case '&&':
                prec = 2;
                break;
    
            case '|':
                prec = 3;
                break;
    
            case '^':
                prec = 4;
                break;
    
            case '&':
                prec = 5;
                break;
    
            case '==':
            case '!=':
            case '===':
            case '!==':
                prec = 6;
                break;
    
            case '<':
            case '>':
            case '<=':
            case '>=':
            case 'instanceof':
                prec = 7;
                break;
    
            case 'in':
                prec = allowIn ? 7 : 0;
                break;
    
            case '<<':
            case '>>':
            case '>>>':
                prec = 8;
                break;
    
            case '+':
            case '-':
                prec = 9;
                break;
    
            case '*':
            case '/':
            case '%':
                prec = 11;
                break;
    
            default:
                break;
            }
    
            return prec;
        }
    
        // 11.5 Multiplicative Operators
        // 11.6 Additive Operators
        // 11.7 Bitwise Shift Operators
        // 11.8 Relational Operators
        // 11.9 Equality Operators
        // 11.10 Binary Bitwise Operators
        // 11.11 Binary Logical Operators
    
        function parseBinaryExpression() {
            var expr, token, prec, previousAllowIn, stack, right, operator, left, i,
                marker, markers;
    
            previousAllowIn = state.allowIn;
            state.allowIn = true;
    
            marker = markerCreate();
            left = parseUnaryExpression();
    
            token = lookahead;
            prec = binaryPrecedence(token, previousAllowIn);
            if (prec === 0) {
                return left;
            }
            token.prec = prec;
            lex();
    
            markers = [marker, markerCreate()];
            right = parseUnaryExpression();
    
            stack = [left, token, right];
    
            while ((prec = binaryPrecedence(lookahead, previousAllowIn)) > 0) {
    
                // Reduce: make a binary expression from the three topmost entries.
                while ((stack.length > 2) && (prec <= stack[stack.length - 2].prec)) {
                    right = stack.pop();
                    operator = stack.pop().value;
                    left = stack.pop();
                    expr = delegate.createBinaryExpression(operator, left, right);
                    markers.pop();
                    marker = markers.pop();
                    markerApply(marker, expr);
                    stack.push(expr);
                    markers.push(marker);
                }
    
                // Shift.
                token = lex();
                token.prec = prec;
                stack.push(token);
                markers.push(markerCreate());
                expr = parseUnaryExpression();
                stack.push(expr);
            }
    
            state.allowIn = previousAllowIn;
    
            // Final reduce to clean-up the stack.
            i = stack.length - 1;
            expr = stack[i];
            markers.pop();
            while (i > 1) {
                expr = delegate.createBinaryExpression(stack[i - 1].value, stack[i - 2], expr);
                i -= 2;
                marker = markers.pop();
                markerApply(marker, expr);
            }
    
            return expr;
        }
    
    
        // 11.12 Conditional Operator
    
        function parseConditionalExpression() {
            var expr, previousAllowIn, consequent, alternate, marker = markerCreate();
            expr = parseBinaryExpression();
    
            if (match('?')) {
                lex();
                previousAllowIn = state.allowIn;
                state.allowIn = true;
                consequent = parseAssignmentExpression();
                state.allowIn = previousAllowIn;
                expect(':');
                alternate = parseAssignmentExpression();
    
                expr = markerApply(marker, delegate.createConditionalExpression(expr, consequent, alternate));
            }
    
            return expr;
        }
    
        // 11.13 Assignment Operators
    
        // 12.14.5 AssignmentPattern
    
        function reinterpretAsAssignmentBindingPattern(expr) {
            var i, len, property, element;
    
            if (expr.type === Syntax.ObjectExpression) {
                expr.type = Syntax.ObjectPattern;
                for (i = 0, len = expr.properties.length; i < len; i += 1) {
                    property = expr.properties[i];
                    if (property.type === Syntax.SpreadProperty) {
                        if (i < len - 1) {
                            throwError({}, Messages.PropertyAfterSpreadProperty);
                        }
                        reinterpretAsAssignmentBindingPattern(property.argument);
                    } else {
                        if (property.kind !== 'init') {
                            throwError({}, Messages.InvalidLHSInAssignment);
                        }
                        reinterpretAsAssignmentBindingPattern(property.value);
                    }
                }
            } else if (expr.type === Syntax.ArrayExpression) {
                expr.type = Syntax.ArrayPattern;
                for (i = 0, len = expr.elements.length; i < len; i += 1) {
                    element = expr.elements[i];
                    /* istanbul ignore else */
                    if (element) {
                        reinterpretAsAssignmentBindingPattern(element);
                    }
                }
            } else if (expr.type === Syntax.Identifier) {
                if (isRestrictedWord(expr.name)) {
                    throwError({}, Messages.InvalidLHSInAssignment);
                }
            } else if (expr.type === Syntax.SpreadElement) {
                reinterpretAsAssignmentBindingPattern(expr.argument);
                if (expr.argument.type === Syntax.ObjectPattern) {
                    throwError({}, Messages.ObjectPatternAsSpread);
                }
            } else {
                /* istanbul ignore else */
                if (expr.type !== Syntax.MemberExpression && expr.type !== Syntax.CallExpression && expr.type !== Syntax.NewExpression) {
                    throwError({}, Messages.InvalidLHSInAssignment);
                }
            }
        }
    
        // 13.2.3 BindingPattern
    
        function reinterpretAsDestructuredParameter(options, expr) {
            var i, len, property, element;
    
            if (expr.type === Syntax.ObjectExpression) {
                expr.type = Syntax.ObjectPattern;
                for (i = 0, len = expr.properties.length; i < len; i += 1) {
                    property = expr.properties[i];
                    if (property.type === Syntax.SpreadProperty) {
                        if (i < len - 1) {
                            throwError({}, Messages.PropertyAfterSpreadProperty);
                        }
                        reinterpretAsDestructuredParameter(options, property.argument);
                    } else {
                        if (property.kind !== 'init') {
                            throwError({}, Messages.InvalidLHSInFormalsList);
                        }
                        reinterpretAsDestructuredParameter(options, property.value);
                    }
                }
            } else if (expr.type === Syntax.ArrayExpression) {
                expr.type = Syntax.ArrayPattern;
                for (i = 0, len = expr.elements.length; i < len; i += 1) {
                    element = expr.elements[i];
                    if (element) {
                        reinterpretAsDestructuredParameter(options, element);
                    }
                }
            } else if (expr.type === Syntax.Identifier) {
                validateParam(options, expr, expr.name);
            } else if (expr.type === Syntax.SpreadElement) {
                // BindingRestElement only allows BindingIdentifier
                if (expr.argument.type !== Syntax.Identifier) {
                    throwError({}, Messages.InvalidLHSInFormalsList);
                }
                validateParam(options, expr.argument, expr.argument.name);
            } else {
                throwError({}, Messages.InvalidLHSInFormalsList);
            }
        }
    
        function reinterpretAsCoverFormalsList(expressions) {
            var i, len, param, params, defaults, defaultCount, options, rest;
    
            params = [];
            defaults = [];
            defaultCount = 0;
            rest = null;
            options = {
                paramSet: new StringMap()
            };
    
            for (i = 0, len = expressions.length; i < len; i += 1) {
                param = expressions[i];
                if (param.type === Syntax.Identifier) {
                    params.push(param);
                    defaults.push(null);
                    validateParam(options, param, param.name);
                } else if (param.type === Syntax.ObjectExpression || param.type === Syntax.ArrayExpression) {
                    reinterpretAsDestructuredParameter(options, param);
                    params.push(param);
                    defaults.push(null);
                } else if (param.type === Syntax.SpreadElement) {
                    assert(i === len - 1, 'It is guaranteed that SpreadElement is last element by parseExpression');
                    if (param.argument.type !== Syntax.Identifier) {
                        throwError({}, Messages.InvalidLHSInFormalsList);
                    }
                    reinterpretAsDestructuredParameter(options, param.argument);
                    rest = param.argument;
                } else if (param.type === Syntax.AssignmentExpression) {
                    params.push(param.left);
                    defaults.push(param.right);
                    ++defaultCount;
                    validateParam(options, param.left, param.left.name);
                } else {
                    return null;
                }
            }
    
            if (options.message === Messages.StrictParamDupe) {
                throwError(
                    strict ? options.stricted : options.firstRestricted,
                    options.message
                );
            }
    
            if (defaultCount === 0) {
                defaults = [];
            }
    
            return {
                params: params,
                defaults: defaults,
                rest: rest,
                stricted: options.stricted,
                firstRestricted: options.firstRestricted,
                message: options.message
            };
        }
    
        function parseArrowFunctionExpression(options, marker) {
            var previousStrict, previousYieldAllowed, previousAwaitAllowed, body;
    
            expect('=>');
    
            previousStrict = strict;
            previousYieldAllowed = state.yieldAllowed;
            state.yieldAllowed = false;
            previousAwaitAllowed = state.awaitAllowed;
            state.awaitAllowed = !!options.async;
            body = parseConciseBody();
    
            if (strict && options.firstRestricted) {
                throwError(options.firstRestricted, options.message);
            }
            if (strict && options.stricted) {
                throwErrorTolerant(options.stricted, options.message);
            }
    
            strict = previousStrict;
            state.yieldAllowed = previousYieldAllowed;
            state.awaitAllowed = previousAwaitAllowed;
    
            return markerApply(marker, delegate.createArrowFunctionExpression(
                options.params,
                options.defaults,
                body,
                options.rest,
                body.type !== Syntax.BlockStatement,
                !!options.async
            ));
        }
    
        function parseAssignmentExpression() {
            var marker, expr, token, params, oldParenthesizedCount,
                startsWithParen = false, backtrackToken = lookahead,
                possiblyAsync = false;
    
            if (matchYield()) {
                return parseYieldExpression();
            }
    
            if (matchAwait()) {
                return parseAwaitExpression();
            }
    
            oldParenthesizedCount = state.parenthesizedCount;
    
            marker = markerCreate();
    
            if (matchAsyncFuncExprOrDecl()) {
                return parseFunctionExpression();
            }
    
            if (matchAsync()) {
                // We can't be completely sure that this 'async' token is
                // actually a contextual keyword modifying a function
                // expression, so we might have to un-lex() it later by
                // calling rewind(backtrackToken).
                possiblyAsync = true;
                lex();
            }
    
            if (match('(')) {
                token = lookahead2();
                if ((token.type === Token.Punctuator && token.value === ')') || token.value === '...') {
                    params = parseParams();
                    if (!match('=>')) {
                        throwUnexpected(lex());
                    }
                    params.async = possiblyAsync;
                    return parseArrowFunctionExpression(params, marker);
                }
                startsWithParen = true;
            }
    
            token = lookahead;
    
            // If the 'async' keyword is not followed by a '(' character or an
            // identifier, then it can't be an arrow function modifier, and we
            // should interpret it as a normal identifer.
            if (possiblyAsync && !match('(') && token.type !== Token.Identifier) {
                possiblyAsync = false;
                rewind(backtrackToken);
            }
    
            expr = parseConditionalExpression();
    
            if (match('=>') &&
                    (state.parenthesizedCount === oldParenthesizedCount ||
                    state.parenthesizedCount === (oldParenthesizedCount + 1))) {
                if (expr.type === Syntax.Identifier) {
                    params = reinterpretAsCoverFormalsList([ expr ]);
                } else if (expr.type === Syntax.AssignmentExpression ||
                        expr.type === Syntax.ArrayExpression ||
                        expr.type === Syntax.ObjectExpression) {
                    if (!startsWithParen) {
                        throwUnexpected(lex());
                    }
                    params = reinterpretAsCoverFormalsList([ expr ]);
                } else if (expr.type === Syntax.SequenceExpression) {
                    params = reinterpretAsCoverFormalsList(expr.expressions);
                }
                if (params) {
                    params.async = possiblyAsync;
                    return parseArrowFunctionExpression(params, marker);
                }
            }
    
            // If we haven't returned by now, then the 'async' keyword was not
            // a function modifier, and we should rewind and interpret it as a
            // normal identifier.
            if (possiblyAsync) {
                possiblyAsync = false;
                rewind(backtrackToken);
                expr = parseConditionalExpression();
            }
    
            if (matchAssign()) {
                // 11.13.1
                if (strict && expr.type === Syntax.Identifier && isRestrictedWord(expr.name)) {
                    throwErrorTolerant(token, Messages.StrictLHSAssignment);
                }
    
                // ES.next draf 11.13 Runtime Semantics step 1
                if (match('=') && (expr.type === Syntax.ObjectExpression || expr.type === Syntax.ArrayExpression)) {
                    reinterpretAsAssignmentBindingPattern(expr);
                } else if (!isLeftHandSide(expr)) {
                    throwError({}, Messages.InvalidLHSInAssignment);
                }
    
                expr = markerApply(marker, delegate.createAssignmentExpression(lex().value, expr, parseAssignmentExpression()));
            }
    
            return expr;
        }
    
        // 11.14 Comma Operator
    
        function parseExpression() {
            var marker, expr, expressions, sequence, spreadFound;
    
            marker = markerCreate();
            expr = parseAssignmentExpression();
            expressions = [ expr ];
    
            if (match(',')) {
                while (index < length) {
                    if (!match(',')) {
                        break;
                    }
    
                    lex();
                    expr = parseSpreadOrAssignmentExpression();
                    expressions.push(expr);
    
                    if (expr.type === Syntax.SpreadElement) {
                        spreadFound = true;
                        if (!match(')')) {
                            throwError({}, Messages.ElementAfterSpreadElement);
                        }
                        break;
                    }
                }
    
                sequence = markerApply(marker, delegate.createSequenceExpression(expressions));
            }
    
            if (spreadFound && lookahead2().value !== '=>') {
                throwError({}, Messages.IllegalSpread);
            }
    
            return sequence || expr;
        }
    
        // 12.1 Block
    
        function parseStatementList() {
            var list = [],
                statement;
    
            while (index < length) {
                if (match('}')) {
                    break;
                }
                statement = parseSourceElement();
                if (typeof statement === 'undefined') {
                    break;
                }
                list.push(statement);
            }
    
            return list;
        }
    
        function parseBlock() {
            var block, marker = markerCreate();
    
            expect('{');
    
            block = parseStatementList();
    
            expect('}');
    
            return markerApply(marker, delegate.createBlockStatement(block));
        }
    
        // 12.2 Variable Statement
    
        function parseTypeParameterDeclaration() {
            var marker = markerCreate(), paramTypes = [];
    
            expect('<');
            while (!match('>')) {
                paramTypes.push(parseTypeAnnotatableIdentifier());
                if (!match('>')) {
                    expect(',');
                }
            }
            expect('>');
    
            return markerApply(marker, delegate.createTypeParameterDeclaration(
                paramTypes
            ));
        }
    
        function parseTypeParameterInstantiation() {
            var marker = markerCreate(), oldInType = state.inType, paramTypes = [];
    
            state.inType = true;
    
            expect('<');
            while (!match('>')) {
                paramTypes.push(parseType());
                if (!match('>')) {
                    expect(',');
                }
            }
            expect('>');
    
            state.inType = oldInType;
    
            return markerApply(marker, delegate.createTypeParameterInstantiation(
                paramTypes
            ));
        }
    
        function parseObjectTypeIndexer(marker, isStatic) {
            var id, key, value;
    
            expect('[');
            id = parseObjectPropertyKey();
            expect(':');
            key = parseType();
            expect(']');
            expect(':');
            value = parseType();
    
            return markerApply(marker, delegate.createObjectTypeIndexer(
                id,
                key,
                value,
                isStatic
            ));
        }
    
        function parseObjectTypeMethodish(marker) {
            var params = [], rest = null, returnType, typeParameters = null;
            if (match('<')) {
                typeParameters = parseTypeParameterDeclaration();
            }
    
            expect('(');
            while (lookahead.type === Token.Identifier) {
                params.push(parseFunctionTypeParam());
                if (!match(')')) {
                    expect(',');
                }
            }
    
            if (match('...')) {
                lex();
                rest = parseFunctionTypeParam();
            }
            expect(')');
            expect(':');
            returnType = parseType();
    
            return markerApply(marker, delegate.createFunctionTypeAnnotation(
                params,
                returnType,
                rest,
                typeParameters
            ));
        }
    
        function parseObjectTypeMethod(marker, isStatic, key) {
            var optional = false, value;
            value = parseObjectTypeMethodish(marker);
    
            return markerApply(marker, delegate.createObjectTypeProperty(
                key,
                value,
                optional,
                isStatic
            ));
        }
    
        function parseObjectTypeCallProperty(marker, isStatic) {
            var valueMarker = markerCreate();
            return markerApply(marker, delegate.createObjectTypeCallProperty(
                parseObjectTypeMethodish(valueMarker),
                isStatic
            ));
        }
    
        function parseObjectType(allowStatic) {
            var callProperties = [], indexers = [], marker, optional = false,
                properties = [], propertyKey, propertyTypeAnnotation,
                token, isStatic, matchStatic;
    
            expect('{');
    
            while (!match('}')) {
                marker = markerCreate();
                matchStatic =
                       strict
                       ? matchKeyword('static')
                       : matchContextualKeyword('static');
    
                if (allowStatic && matchStatic) {
                    token = lex();
                    isStatic = true;
                }
    
                if (match('[')) {
                    indexers.push(parseObjectTypeIndexer(marker, isStatic));
                } else if (match('(') || match('<')) {
                    callProperties.push(parseObjectTypeCallProperty(marker, allowStatic));
                } else {
                    if (isStatic && match(':')) {
                        propertyKey = markerApply(marker, delegate.createIdentifier(token));
                        throwErrorTolerant(token, Messages.StrictReservedWord);
                    } else {
                        propertyKey = parseObjectPropertyKey();
                    }
                    if (match('<') || match('(')) {
                        // This is a method property
                        properties.push(parseObjectTypeMethod(marker, isStatic, propertyKey));
                    } else {
                        if (match('?')) {
                            lex();
                            optional = true;
                        }
                        expect(':');
                        propertyTypeAnnotation = parseType();
                        properties.push(markerApply(marker, delegate.createObjectTypeProperty(
                            propertyKey,
                            propertyTypeAnnotation,
                            optional,
                            isStatic
                        )));
                    }
                }
    
                if (match(';')) {
                    lex();
                } else if (!match('}')) {
                    throwUnexpected(lookahead);
                }
            }
    
            expect('}');
    
            return delegate.createObjectTypeAnnotation(
                properties,
                indexers,
                callProperties
            );
        }
    
        function parseGenericType() {
            var marker = markerCreate(),
                typeParameters = null, typeIdentifier;
    
            typeIdentifier = parseVariableIdentifier();
    
            while (match('.')) {
                expect('.');
                typeIdentifier = markerApply(marker, delegate.createQualifiedTypeIdentifier(
                    typeIdentifier,
                    parseVariableIdentifier()
                ));
            }
    
            if (match('<')) {
                typeParameters = parseTypeParameterInstantiation();
            }
    
            return markerApply(marker, delegate.createGenericTypeAnnotation(
                typeIdentifier,
                typeParameters
            ));
        }
    
        function parseVoidType() {
            var marker = markerCreate();
            expectKeyword('void');
            return markerApply(marker, delegate.createVoidTypeAnnotation());
        }
    
        function parseTypeofType() {
            var argument, marker = markerCreate();
            expectKeyword('typeof');
            argument = parsePrimaryType();
            return markerApply(marker, delegate.createTypeofTypeAnnotation(
                argument
            ));
        }
    
        function parseTupleType() {
            var marker = markerCreate(), types = [];
            expect('[');
            // We allow trailing commas
            while (index < length && !match(']')) {
                types.push(parseType());
                if (match(']')) {
                    break;
                }
                expect(',');
            }
            expect(']');
            return markerApply(marker, delegate.createTupleTypeAnnotation(
                types
            ));
        }
    
        function parseFunctionTypeParam() {
            var marker = markerCreate(), name, optional = false, typeAnnotation;
            name = parseVariableIdentifier();
            if (match('?')) {
                lex();
                optional = true;
            }
            expect(':');
            typeAnnotation = parseType();
            return markerApply(marker, delegate.createFunctionTypeParam(
                name,
                typeAnnotation,
                optional
            ));
        }
    
        function parseFunctionTypeParams() {
            var ret = { params: [], rest: null };
            while (lookahead.type === Token.Identifier) {
                ret.params.push(parseFunctionTypeParam());
                if (!match(')')) {
                    expect(',');
                }
            }
    
            if (match('...')) {
                lex();
                ret.rest = parseFunctionTypeParam();
            }
            return ret;
        }
    
        // The parsing of types roughly parallels the parsing of expressions, and
        // primary types are kind of like primary expressions...they're the
        // primitives with which other types are constructed.
        function parsePrimaryType() {
            var params = null, returnType = null,
                marker = markerCreate(), rest = null, tmp,
                typeParameters, token, type, isGroupedType = false;
    
            switch (lookahead.type) {
            case Token.Identifier:
                switch (lookahead.value) {
                case 'any':
                    lex();
                    return markerApply(marker, delegate.createAnyTypeAnnotation());
                case 'bool':  // fallthrough
                case 'boolean':
                    lex();
                    return markerApply(marker, delegate.createBooleanTypeAnnotation());
                case 'number':
                    lex();
                    return markerApply(marker, delegate.createNumberTypeAnnotation());
                case 'string':
                    lex();
                    return markerApply(marker, delegate.createStringTypeAnnotation());
                }
                return markerApply(marker, parseGenericType());
            case Token.Punctuator:
                switch (lookahead.value) {
                case '{':
                    return markerApply(marker, parseObjectType());
                case '[':
                    return parseTupleType();
                case '<':
                    typeParameters = parseTypeParameterDeclaration();
                    expect('(');
                    tmp = parseFunctionTypeParams();
                    params = tmp.params;
                    rest = tmp.rest;
                    expect(')');
    
                    expect('=>');
    
                    returnType = parseType();
    
                    return markerApply(marker, delegate.createFunctionTypeAnnotation(
                        params,
                        returnType,
                        rest,
                        typeParameters
                    ));
                case '(':
                    lex();
                    // Check to see if this is actually a grouped type
                    if (!match(')') && !match('...')) {
                        if (lookahead.type === Token.Identifier) {
                            token = lookahead2();
                            isGroupedType = token.value !== '?' && token.value !== ':';
                        } else {
                            isGroupedType = true;
                        }
                    }
    
                    if (isGroupedType) {
                        type = parseType();
                        expect(')');
    
                        // If we see a => next then someone was probably confused about
                        // function types, so we can provide a better error message
                        if (match('=>')) {
                            throwError({}, Messages.ConfusedAboutFunctionType);
                        }
    
                        return type;
                    }
    
                    tmp = parseFunctionTypeParams();
                    params = tmp.params;
                    rest = tmp.rest;
    
                    expect(')');
    
                    expect('=>');
    
                    returnType = parseType();
    
                    return markerApply(marker, delegate.createFunctionTypeAnnotation(
                        params,
                        returnType,
                        rest,
                        null /* typeParameters */
                    ));
                }
                break;
            case Token.Keyword:
                switch (lookahead.value) {
                case 'void':
                    return markerApply(marker, parseVoidType());
                case 'typeof':
                    return markerApply(marker, parseTypeofType());
                }
                break;
            case Token.StringLiteral:
                token = lex();
                if (token.octal) {
                    throwError(token, Messages.StrictOctalLiteral);
                }
                return markerApply(marker, delegate.createStringLiteralTypeAnnotation(
                    token
                ));
            }
    
            throwUnexpected(lookahead);
        }
    
        function parsePostfixType() {
            var marker = markerCreate(), t = parsePrimaryType();
            if (match('[')) {
                expect('[');
                expect(']');
                return markerApply(marker, delegate.createArrayTypeAnnotation(t));
            }
            return t;
        }
    
        function parsePrefixType() {
            var marker = markerCreate();
            if (match('?')) {
                lex();
                return markerApply(marker, delegate.createNullableTypeAnnotation(
                    parsePrefixType()
                ));
            }
            return parsePostfixType();
        }
    
    
        function parseIntersectionType() {
            var marker = markerCreate(), type, types;
            type = parsePrefixType();
            types = [type];
            while (match('&')) {
                lex();
                types.push(parsePrefixType());
            }
    
            return types.length === 1 ?
                    type :
                    markerApply(marker, delegate.createIntersectionTypeAnnotation(
                        types
                    ));
        }
    
        function parseUnionType() {
            var marker = markerCreate(), type, types;
            type = parseIntersectionType();
            types = [type];
            while (match('|')) {
                lex();
                types.push(parseIntersectionType());
            }
            return types.length === 1 ?
                    type :
                    markerApply(marker, delegate.createUnionTypeAnnotation(
                        types
                    ));
        }
    
        function parseType() {
            var oldInType = state.inType, type;
            state.inType = true;
    
            type = parseUnionType();
    
            state.inType = oldInType;
            return type;
        }
    
        function parseTypeAnnotation() {
            var marker = markerCreate(), type;
    
            expect(':');
            type = parseType();
    
            return markerApply(marker, delegate.createTypeAnnotation(type));
        }
    
        function parseVariableIdentifier() {
            var marker = markerCreate(),
                token = lex();
    
            if (token.type !== Token.Identifier) {
                throwUnexpected(token);
            }
    
            return markerApply(marker, delegate.createIdentifier(token.value));
        }
    
        function parseTypeAnnotatableIdentifier(requireTypeAnnotation, canBeOptionalParam) {
            var marker = markerCreate(),
                ident = parseVariableIdentifier(),
                isOptionalParam = false;
    
            if (canBeOptionalParam && match('?')) {
                expect('?');
                isOptionalParam = true;
            }
    
            if (requireTypeAnnotation || match(':')) {
                ident.typeAnnotation = parseTypeAnnotation();
                ident = markerApply(marker, ident);
            }
    
            if (isOptionalParam) {
                ident.optional = true;
                ident = markerApply(marker, ident);
            }
    
            return ident;
        }
    
        function parseVariableDeclaration(kind) {
            var id,
                marker = markerCreate(),
                init = null,
                typeAnnotationMarker = markerCreate();
            if (match('{')) {
                id = parseObjectInitialiser();
                reinterpretAsAssignmentBindingPattern(id);
                if (match(':')) {
                    id.typeAnnotation = parseTypeAnnotation();
                    markerApply(typeAnnotationMarker, id);
                }
            } else if (match('[')) {
                id = parseArrayInitialiser();
                reinterpretAsAssignmentBindingPattern(id);
                if (match(':')) {
                    id.typeAnnotation = parseTypeAnnotation();
                    markerApply(typeAnnotationMarker, id);
                }
            } else {
                /* istanbul ignore next */
                id = state.allowKeyword ? parseNonComputedProperty() : parseTypeAnnotatableIdentifier();
                // 12.2.1
                if (strict && isRestrictedWord(id.name)) {
                    throwErrorTolerant({}, Messages.StrictVarName);
                }
            }
    
            if (kind === 'const') {
                if (!match('=')) {
                    throwError({}, Messages.NoUninitializedConst);
                }
                expect('=');
                init = parseAssignmentExpression();
            } else if (match('=')) {
                lex();
                init = parseAssignmentExpression();
            }
    
            return markerApply(marker, delegate.createVariableDeclarator(id, init));
        }
    
        function parseVariableDeclarationList(kind) {
            var list = [];
    
            do {
                list.push(parseVariableDeclaration(kind));
                if (!match(',')) {
                    break;
                }
                lex();
            } while (index < length);
    
            return list;
        }
    
        function parseVariableStatement() {
            var declarations, marker = markerCreate();
    
            expectKeyword('var');
    
            declarations = parseVariableDeclarationList();
    
            consumeSemicolon();
    
            return markerApply(marker, delegate.createVariableDeclaration(declarations, 'var'));
        }
    
        // kind may be `const` or `let`
        // Both are experimental and not in the specification yet.
        // see http://wiki.ecmascript.org/doku.php?id=harmony:const
        // and http://wiki.ecmascript.org/doku.php?id=harmony:let
        function parseConstLetDeclaration(kind) {
            var declarations, marker = markerCreate();
    
            expectKeyword(kind);
    
            declarations = parseVariableDeclarationList(kind);
    
            consumeSemicolon();
    
            return markerApply(marker, delegate.createVariableDeclaration(declarations, kind));
        }
    
        // people.mozilla.org/~jorendorff/es6-draft.html
    
        function parseModuleSpecifier() {
            var marker = markerCreate(),
                specifier;
    
            if (lookahead.type !== Token.StringLiteral) {
                throwError({}, Messages.InvalidModuleSpecifier);
            }
            specifier = delegate.createModuleSpecifier(lookahead);
            lex();
            return markerApply(marker, specifier);
        }
    
        function parseExportBatchSpecifier() {
            var marker = markerCreate();
            expect('*');
            return markerApply(marker, delegate.createExportBatchSpecifier());
        }
    
        function parseExportSpecifier() {
            var id, name = null, marker = markerCreate(), from;
            if (matchKeyword('default')) {
                lex();
                id = markerApply(marker, delegate.createIdentifier('default'));
                // export {default} from "something";
            } else {
                id = parseVariableIdentifier();
            }
            if (matchContextualKeyword('as')) {
                lex();
                name = parseNonComputedProperty();
            }
    
            return markerApply(marker, delegate.createExportSpecifier(id, name));
        }
    
        function parseExportDeclaration() {
            var declaration = null,
                possibleIdentifierToken, sourceElement,
                isExportFromIdentifier,
                src = null, specifiers = [],
                marker = markerCreate();
    
            expectKeyword('export');
    
            if (matchKeyword('default')) {
                // covers:
                // export default ...
                lex();
                if (matchKeyword('function') || matchKeyword('class')) {
                    possibleIdentifierToken = lookahead2();
                    if (isIdentifierName(possibleIdentifierToken)) {
                        // covers:
                        // export default function foo () {}
                        // export default class foo {}
                        sourceElement = parseSourceElement();
                        return markerApply(marker, delegate.createExportDeclaration(true, sourceElement, [sourceElement.id], null));
                    }
                    // covers:
                    // export default function () {}
                    // export default class {}
                    switch (lookahead.value) {
                    case 'class':
                        return markerApply(marker, delegate.createExportDeclaration(true, parseClassExpression(), [], null));
                    case 'function':
                        return markerApply(marker, delegate.createExportDeclaration(true, parseFunctionExpression(), [], null));
                    }
                }
    
                if (matchContextualKeyword('from')) {
                    throwError({}, Messages.UnexpectedToken, lookahead.value);
                }
    
                // covers:
                // export default {};
                // export default [];
                if (match('{')) {
                    declaration = parseObjectInitialiser();
                } else if (match('[')) {
                    declaration = parseArrayInitialiser();
                } else {
                    declaration = parseAssignmentExpression();
                }
                consumeSemicolon();
                return markerApply(marker, delegate.createExportDeclaration(true, declaration, [], null));
            }
    
            // non-default export
            if (lookahead.type === Token.Keyword || matchContextualKeyword('type')) {
                // covers:
                // export var f = 1;
                switch (lookahead.value) {
                case 'type':
                case 'let':
                case 'const':
                case 'var':
                case 'class':
                case 'function':
                    return markerApply(marker, delegate.createExportDeclaration(false, parseSourceElement(), specifiers, null));
                }
            }
    
            if (match('*')) {
                // covers:
                // export * from "foo";
                specifiers.push(parseExportBatchSpecifier());
    
                if (!matchContextualKeyword('from')) {
                    throwError({}, lookahead.value ?
                            Messages.UnexpectedToken : Messages.MissingFromClause, lookahead.value);
                }
                lex();
                src = parseModuleSpecifier();
                consumeSemicolon();
    
                return markerApply(marker, delegate.createExportDeclaration(false, null, specifiers, src));
            }
    
            expect('{');
            if (!match('}')) {
                do {
                    isExportFromIdentifier = isExportFromIdentifier || matchKeyword('default');
                    specifiers.push(parseExportSpecifier());
                } while (match(',') && lex());
            }
            expect('}');
    
            if (matchContextualKeyword('from')) {
                // covering:
                // export {default} from "foo";
                // export {foo} from "foo";
                lex();
                src = parseModuleSpecifier();
                consumeSemicolon();
            } else if (isExportFromIdentifier) {
                // covering:
                // export {default}; // missing fromClause
                throwError({}, lookahead.value ?
                        Messages.UnexpectedToken : Messages.MissingFromClause, lookahead.value);
            } else {
                // cover
                // export {foo};
                consumeSemicolon();
            }
            return markerApply(marker, delegate.createExportDeclaration(false, declaration, specifiers, src));
        }
    
    
        function parseImportSpecifier() {
            // import {<foo as bar>} ...;
            var id, name = null, marker = markerCreate();
    
            id = parseNonComputedProperty();
            if (matchContextualKeyword('as')) {
                lex();
                name = parseVariableIdentifier();
            }
    
            return markerApply(marker, delegate.createImportSpecifier(id, name));
        }
    
        function parseNamedImports() {
            var specifiers = [];
            // {foo, bar as bas}
            expect('{');
            if (!match('}')) {
                do {
                    specifiers.push(parseImportSpecifier());
                } while (match(',') && lex());
            }
            expect('}');
            return specifiers;
        }
    
        function parseImportDefaultSpecifier() {
            // import <foo> ...;
            var id, marker = markerCreate();
    
            id = parseNonComputedProperty();
    
            return markerApply(marker, delegate.createImportDefaultSpecifier(id));
        }
    
        function parseImportNamespaceSpecifier() {
            // import <* as foo> ...;
            var id, marker = markerCreate();
    
            expect('*');
            if (!matchContextualKeyword('as')) {
                throwError({}, Messages.NoAsAfterImportNamespace);
            }
            lex();
            id = parseNonComputedProperty();
    
            return markerApply(marker, delegate.createImportNamespaceSpecifier(id));
        }
    
        function parseImportDeclaration() {
            var specifiers, src, marker = markerCreate(), isType = false, token2;
    
            expectKeyword('import');
    
            if (matchContextualKeyword('type')) {
                token2 = lookahead2();
                if ((token2.type === Token.Identifier && token2.value !== 'from') ||
                        (token2.type === Token.Punctuator &&
                            (token2.value === '{' || token2.value === '*'))) {
                    isType = true;
                    lex();
                }
            }
    
            specifiers = [];
    
            if (lookahead.type === Token.StringLiteral) {
                // covers:
                // import "foo";
                src = parseModuleSpecifier();
                consumeSemicolon();
                return markerApply(marker, delegate.createImportDeclaration(specifiers, src, isType));
            }
    
            if (!matchKeyword('default') && isIdentifierName(lookahead)) {
                // covers:
                // import foo
                // import foo, ...
                specifiers.push(parseImportDefaultSpecifier());
                if (match(',')) {
                    lex();
                }
            }
            if (match('*')) {
                // covers:
                // import foo, * as foo
                // import * as foo
                specifiers.push(parseImportNamespaceSpecifier());
            } else if (match('{')) {
                // covers:
                // import foo, {bar}
                // import {bar}
                specifiers = specifiers.concat(parseNamedImports());
            }
    
            if (!matchContextualKeyword('from')) {
                throwError({}, lookahead.value ?
                        Messages.UnexpectedToken : Messages.MissingFromClause, lookahead.value);
            }
            lex();
            src = parseModuleSpecifier();
            consumeSemicolon();
    
            return markerApply(marker, delegate.createImportDeclaration(specifiers, src, isType));
        }
    
        // 12.3 Empty Statement
    
        function parseEmptyStatement() {
            var marker = markerCreate();
            expect(';');
            return markerApply(marker, delegate.createEmptyStatement());
        }
    
        // 12.4 Expression Statement
    
        function parseExpressionStatement() {
            var marker = markerCreate(), expr = parseExpression();
            consumeSemicolon();
            return markerApply(marker, delegate.createExpressionStatement(expr));
        }
    
        // 12.5 If statement
    
        function parseIfStatement() {
            var test, consequent, alternate, marker = markerCreate();
    
            expectKeyword('if');
    
            expect('(');
    
            test = parseExpression();
    
            expect(')');
    
            consequent = parseStatement();
    
            if (matchKeyword('else')) {
                lex();
                alternate = parseStatement();
            } else {
                alternate = null;
            }
    
            return markerApply(marker, delegate.createIfStatement(test, consequent, alternate));
        }
    
        // 12.6 Iteration Statements
    
        function parseDoWhileStatement() {
            var body, test, oldInIteration, marker = markerCreate();
    
            expectKeyword('do');
    
            oldInIteration = state.inIteration;
            state.inIteration = true;
    
            body = parseStatement();
    
            state.inIteration = oldInIteration;
    
            expectKeyword('while');
    
            expect('(');
    
            test = parseExpression();
    
            expect(')');
    
            if (match(';')) {
                lex();
            }
    
            return markerApply(marker, delegate.createDoWhileStatement(body, test));
        }
    
        function parseWhileStatement() {
            var test, body, oldInIteration, marker = markerCreate();
    
            expectKeyword('while');
    
            expect('(');
    
            test = parseExpression();
    
            expect(')');
    
            oldInIteration = state.inIteration;
            state.inIteration = true;
    
            body = parseStatement();
    
            state.inIteration = oldInIteration;
    
            return markerApply(marker, delegate.createWhileStatement(test, body));
        }
    
        function parseForVariableDeclaration() {
            var marker = markerCreate(),
                token = lex(),
                declarations = parseVariableDeclarationList();
    
            return markerApply(marker, delegate.createVariableDeclaration(declarations, token.value));
        }
    
        function parseForStatement(opts) {
            var init, test, update, left, right, body, operator, oldInIteration,
                marker = markerCreate();
            init = test = update = null;
            expectKeyword('for');
    
            // http://wiki.ecmascript.org/doku.php?id=proposals:iterators_and_generators&s=each
            if (matchContextualKeyword('each')) {
                throwError({}, Messages.EachNotAllowed);
            }
    
            expect('(');
    
            if (match(';')) {
                lex();
            } else {
                if (matchKeyword('var') || matchKeyword('let') || matchKeyword('const')) {
                    state.allowIn = false;
                    init = parseForVariableDeclaration();
                    state.allowIn = true;
    
                    if (init.declarations.length === 1) {
                        if (matchKeyword('in') || matchContextualKeyword('of')) {
                            operator = lookahead;
                            if (!((operator.value === 'in' || init.kind !== 'var') && init.declarations[0].init)) {
                                lex();
                                left = init;
                                right = parseExpression();
                                init = null;
                            }
                        }
                    }
                } else {
                    state.allowIn = false;
                    init = parseExpression();
                    state.allowIn = true;
    
                    if (matchContextualKeyword('of')) {
                        operator = lex();
                        left = init;
                        right = parseExpression();
                        init = null;
                    } else if (matchKeyword('in')) {
                        // LeftHandSideExpression
                        if (!isAssignableLeftHandSide(init)) {
                            throwError({}, Messages.InvalidLHSInForIn);
                        }
                        operator = lex();
                        left = init;
                        right = parseExpression();
                        init = null;
                    }
                }
    
                if (typeof left === 'undefined') {
                    expect(';');
                }
            }
    
            if (typeof left === 'undefined') {
    
                if (!match(';')) {
                    test = parseExpression();
                }
                expect(';');
    
                if (!match(')')) {
                    update = parseExpression();
                }
            }
    
            expect(')');
    
            oldInIteration = state.inIteration;
            state.inIteration = true;
    
            if (!(opts !== undefined && opts.ignoreBody)) {
                body = parseStatement();
            }
    
            state.inIteration = oldInIteration;
    
            if (typeof left === 'undefined') {
                return markerApply(marker, delegate.createForStatement(init, test, update, body));
            }
    
            if (operator.value === 'in') {
                return markerApply(marker, delegate.createForInStatement(left, right, body));
            }
            return markerApply(marker, delegate.createForOfStatement(left, right, body));
        }
    
        // 12.7 The continue statement
    
        function parseContinueStatement() {
            var label = null, marker = markerCreate();
    
            expectKeyword('continue');
    
            // Optimize the most common form: 'continue;'.
            if (source.charCodeAt(index) === 59) {
                lex();
    
                if (!state.inIteration) {
                    throwError({}, Messages.IllegalContinue);
                }
    
                return markerApply(marker, delegate.createContinueStatement(null));
            }
    
            if (peekLineTerminator()) {
                if (!state.inIteration) {
                    throwError({}, Messages.IllegalContinue);
                }
    
                return markerApply(marker, delegate.createContinueStatement(null));
            }
    
            if (lookahead.type === Token.Identifier) {
                label = parseVariableIdentifier();
    
                if (!state.labelSet.has(label.name)) {
                    throwError({}, Messages.UnknownLabel, label.name);
                }
            }
    
            consumeSemicolon();
    
            if (label === null && !state.inIteration) {
                throwError({}, Messages.IllegalContinue);
            }
    
            return markerApply(marker, delegate.createContinueStatement(label));
        }
    
        // 12.8 The break statement
    
        function parseBreakStatement() {
            var label = null, marker = markerCreate();
    
            expectKeyword('break');
    
            // Catch the very common case first: immediately a semicolon (char #59).
            if (source.charCodeAt(index) === 59) {
                lex();
    
                if (!(state.inIteration || state.inSwitch)) {
                    throwError({}, Messages.IllegalBreak);
                }
    
                return markerApply(marker, delegate.createBreakStatement(null));
            }
    
            if (peekLineTerminator()) {
                if (!(state.inIteration || state.inSwitch)) {
                    throwError({}, Messages.IllegalBreak);
                }
    
                return markerApply(marker, delegate.createBreakStatement(null));
            }
    
            if (lookahead.type === Token.Identifier) {
                label = parseVariableIdentifier();
    
                if (!state.labelSet.has(label.name)) {
                    throwError({}, Messages.UnknownLabel, label.name);
                }
            }
    
            consumeSemicolon();
    
            if (label === null && !(state.inIteration || state.inSwitch)) {
                throwError({}, Messages.IllegalBreak);
            }
    
            return markerApply(marker, delegate.createBreakStatement(label));
        }
    
        // 12.9 The return statement
    
        function parseReturnStatement() {
            var argument = null, marker = markerCreate();
    
            expectKeyword('return');
    
            if (!state.inFunctionBody) {
                throwErrorTolerant({}, Messages.IllegalReturn);
            }
    
            // 'return' followed by a space and an identifier is very common.
            if (source.charCodeAt(index) === 32) {
                if (isIdentifierStart(source.charCodeAt(index + 1))) {
                    argument = parseExpression();
                    consumeSemicolon();
                    return markerApply(marker, delegate.createReturnStatement(argument));
                }
            }
    
            if (peekLineTerminator()) {
                return markerApply(marker, delegate.createReturnStatement(null));
            }
    
            if (!match(';')) {
                if (!match('}') && lookahead.type !== Token.EOF) {
                    argument = parseExpression();
                }
            }
    
            consumeSemicolon();
    
            return markerApply(marker, delegate.createReturnStatement(argument));
        }
    
        // 12.10 The with statement
    
        function parseWithStatement() {
            var object, body, marker = markerCreate();
    
            if (strict) {
                throwErrorTolerant({}, Messages.StrictModeWith);
            }
    
            expectKeyword('with');
    
            expect('(');
    
            object = parseExpression();
    
            expect(')');
    
            body = parseStatement();
    
            return markerApply(marker, delegate.createWithStatement(object, body));
        }
    
        // 12.10 The swith statement
    
        function parseSwitchCase() {
            var test,
                consequent = [],
                sourceElement,
                marker = markerCreate();
    
            if (matchKeyword('default')) {
                lex();
                test = null;
            } else {
                expectKeyword('case');
                test = parseExpression();
            }
            expect(':');
    
            while (index < length) {
                if (match('}') || matchKeyword('default') || matchKeyword('case')) {
                    break;
                }
                sourceElement = parseSourceElement();
                if (typeof sourceElement === 'undefined') {
                    break;
                }
                consequent.push(sourceElement);
            }
    
            return markerApply(marker, delegate.createSwitchCase(test, consequent));
        }
    
        function parseSwitchStatement() {
            var discriminant, cases, clause, oldInSwitch, defaultFound, marker = markerCreate();
    
            expectKeyword('switch');
    
            expect('(');
    
            discriminant = parseExpression();
    
            expect(')');
    
            expect('{');
    
            cases = [];
    
            if (match('}')) {
                lex();
                return markerApply(marker, delegate.createSwitchStatement(discriminant, cases));
            }
    
            oldInSwitch = state.inSwitch;
            state.inSwitch = true;
            defaultFound = false;
    
            while (index < length) {
                if (match('}')) {
                    break;
                }
                clause = parseSwitchCase();
                if (clause.test === null) {
                    if (defaultFound) {
                        throwError({}, Messages.MultipleDefaultsInSwitch);
                    }
                    defaultFound = true;
                }
                cases.push(clause);
            }
    
            state.inSwitch = oldInSwitch;
    
            expect('}');
    
            return markerApply(marker, delegate.createSwitchStatement(discriminant, cases));
        }
    
        // 12.13 The throw statement
    
        function parseThrowStatement() {
            var argument, marker = markerCreate();
    
            expectKeyword('throw');
    
            if (peekLineTerminator()) {
                throwError({}, Messages.NewlineAfterThrow);
            }
    
            argument = parseExpression();
    
            consumeSemicolon();
    
            return markerApply(marker, delegate.createThrowStatement(argument));
        }
    
        // 12.14 The try statement
    
        function parseCatchClause() {
            var param, body, marker = markerCreate();
    
            expectKeyword('catch');
    
            expect('(');
            if (match(')')) {
                throwUnexpected(lookahead);
            }
    
            param = parseExpression();
            // 12.14.1
            if (strict && param.type === Syntax.Identifier && isRestrictedWord(param.name)) {
                throwErrorTolerant({}, Messages.StrictCatchVariable);
            }
    
            expect(')');
            body = parseBlock();
            return markerApply(marker, delegate.createCatchClause(param, body));
        }
    
        function parseTryStatement() {
            var block, handlers = [], finalizer = null, marker = markerCreate();
    
            expectKeyword('try');
    
            block = parseBlock();
    
            if (matchKeyword('catch')) {
                handlers.push(parseCatchClause());
            }
    
            if (matchKeyword('finally')) {
                lex();
                finalizer = parseBlock();
            }
    
            if (handlers.length === 0 && !finalizer) {
                throwError({}, Messages.NoCatchOrFinally);
            }
    
            return markerApply(marker, delegate.createTryStatement(block, [], handlers, finalizer));
        }
    
        // 12.15 The debugger statement
    
        function parseDebuggerStatement() {
            var marker = markerCreate();
            expectKeyword('debugger');
    
            consumeSemicolon();
    
            return markerApply(marker, delegate.createDebuggerStatement());
        }
    
        // 12 Statements
    
        function parseStatement() {
            var type = lookahead.type,
                marker,
                expr,
                labeledBody;
    
            if (type === Token.EOF) {
                throwUnexpected(lookahead);
            }
    
            if (type === Token.Punctuator) {
                switch (lookahead.value) {
                case ';':
                    return parseEmptyStatement();
                case '{':
                    return parseBlock();
                case '(':
                    return parseExpressionStatement();
                default:
                    break;
                }
            }
    
            if (type === Token.Keyword) {
                switch (lookahead.value) {
                case 'break':
                    return parseBreakStatement();
                case 'continue':
                    return parseContinueStatement();
                case 'debugger':
                    return parseDebuggerStatement();
                case 'do':
                    return parseDoWhileStatement();
                case 'for':
                    return parseForStatement();
                case 'function':
                    return parseFunctionDeclaration();
                case 'class':
                    return parseClassDeclaration();
                case 'if':
                    return parseIfStatement();
                case 'return':
                    return parseReturnStatement();
                case 'switch':
                    return parseSwitchStatement();
                case 'throw':
                    return parseThrowStatement();
                case 'try':
                    return parseTryStatement();
                case 'var':
                    return parseVariableStatement();
                case 'while':
                    return parseWhileStatement();
                case 'with':
                    return parseWithStatement();
                default:
                    break;
                }
            }
    
            if (matchAsyncFuncExprOrDecl()) {
                return parseFunctionDeclaration();
            }
    
            marker = markerCreate();
            expr = parseExpression();
    
            // 12.12 Labelled Statements
            if ((expr.type === Syntax.Identifier) && match(':')) {
                lex();
    
                if (state.labelSet.has(expr.name)) {
                    throwError({}, Messages.Redeclaration, 'Label', expr.name);
                }
    
                state.labelSet.set(expr.name, true);
                labeledBody = parseStatement();
                state.labelSet.delete(expr.name);
                return markerApply(marker, delegate.createLabeledStatement(expr, labeledBody));
            }
    
            consumeSemicolon();
    
            return markerApply(marker, delegate.createExpressionStatement(expr));
        }
    
        // 13 Function Definition
    
        function parseConciseBody() {
            if (match('{')) {
                return parseFunctionSourceElements();
            }
            return parseAssignmentExpression();
        }
    
        function parseFunctionSourceElements() {
            var sourceElement, sourceElements = [], token, directive, firstRestricted,
                oldLabelSet, oldInIteration, oldInSwitch, oldInFunctionBody, oldParenthesizedCount,
                marker = markerCreate();
    
            expect('{');
    
            while (index < length) {
                if (lookahead.type !== Token.StringLiteral) {
                    break;
                }
                token = lookahead;
    
                sourceElement = parseSourceElement();
                sourceElements.push(sourceElement);
                if (sourceElement.expression.type !== Syntax.Literal) {
                    // this is not directive
                    break;
                }
                directive = source.slice(token.range[0] + 1, token.range[1] - 1);
                if (directive === 'use strict') {
                    strict = true;
                    if (firstRestricted) {
                        throwErrorTolerant(firstRestricted, Messages.StrictOctalLiteral);
                    }
                } else {
                    if (!firstRestricted && token.octal) {
                        firstRestricted = token;
                    }
                }
            }
    
            oldLabelSet = state.labelSet;
            oldInIteration = state.inIteration;
            oldInSwitch = state.inSwitch;
            oldInFunctionBody = state.inFunctionBody;
            oldParenthesizedCount = state.parenthesizedCount;
    
            state.labelSet = new StringMap();
            state.inIteration = false;
            state.inSwitch = false;
            state.inFunctionBody = true;
            state.parenthesizedCount = 0;
    
            while (index < length) {
                if (match('}')) {
                    break;
                }
                sourceElement = parseSourceElement();
                if (typeof sourceElement === 'undefined') {
                    break;
                }
                sourceElements.push(sourceElement);
            }
    
            expect('}');
    
            state.labelSet = oldLabelSet;
            state.inIteration = oldInIteration;
            state.inSwitch = oldInSwitch;
            state.inFunctionBody = oldInFunctionBody;
            state.parenthesizedCount = oldParenthesizedCount;
    
            return markerApply(marker, delegate.createBlockStatement(sourceElements));
        }
    
        function validateParam(options, param, name) {
            if (strict) {
                if (isRestrictedWord(name)) {
                    options.stricted = param;
                    options.message = Messages.StrictParamName;
                }
                if (options.paramSet.has(name)) {
                    options.stricted = param;
                    options.message = Messages.StrictParamDupe;
                }
            } else if (!options.firstRestricted) {
                if (isRestrictedWord(name)) {
                    options.firstRestricted = param;
                    options.message = Messages.StrictParamName;
                } else if (isStrictModeReservedWord(name)) {
                    options.firstRestricted = param;
                    options.message = Messages.StrictReservedWord;
                } else if (options.paramSet.has(name)) {
                    options.firstRestricted = param;
                    options.message = Messages.StrictParamDupe;
                }
            }
            options.paramSet.set(name, true);
        }
    
        function parseParam(options) {
            var marker, token, rest, param, def;
    
            token = lookahead;
            if (token.value === '...') {
                token = lex();
                rest = true;
            }
    
            if (match('[')) {
                marker = markerCreate();
                param = parseArrayInitialiser();
                reinterpretAsDestructuredParameter(options, param);
                if (match(':')) {
                    param.typeAnnotation = parseTypeAnnotation();
                    markerApply(marker, param);
                }
            } else if (match('{')) {
                marker = markerCreate();
                if (rest) {
                    throwError({}, Messages.ObjectPatternAsRestParameter);
                }
                param = parseObjectInitialiser();
                reinterpretAsDestructuredParameter(options, param);
                if (match(':')) {
                    param.typeAnnotation = parseTypeAnnotation();
                    markerApply(marker, param);
                }
            } else {
                param =
                    rest
                    ? parseTypeAnnotatableIdentifier(
                        false, /* requireTypeAnnotation */
                        false /* canBeOptionalParam */
                    )
                    : parseTypeAnnotatableIdentifier(
                        false, /* requireTypeAnnotation */
                        true /* canBeOptionalParam */
                    );
    
                validateParam(options, token, token.value);
            }
    
            if (match('=')) {
                if (rest) {
                    throwErrorTolerant(lookahead, Messages.DefaultRestParameter);
                }
                lex();
                def = parseAssignmentExpression();
                ++options.defaultCount;
            }
    
            if (rest) {
                if (!match(')')) {
                    throwError({}, Messages.ParameterAfterRestParameter);
                }
                options.rest = param;
                return false;
            }
    
            options.params.push(param);
            options.defaults.push(def);
            return !match(')');
        }
    
        function parseParams(firstRestricted) {
            var options, marker = markerCreate();
    
            options = {
                params: [],
                defaultCount: 0,
                defaults: [],
                rest: null,
                firstRestricted: firstRestricted
            };
    
            expect('(');
    
            if (!match(')')) {
                options.paramSet = new StringMap();
                while (index < length) {
                    if (!parseParam(options)) {
                        break;
                    }
                    expect(',');
                }
            }
    
            expect(')');
    
            if (options.defaultCount === 0) {
                options.defaults = [];
            }
    
            if (match(':')) {
                options.returnType = parseTypeAnnotation();
            }
    
            return markerApply(marker, options);
        }
    
        function parseFunctionDeclaration() {
            var id, body, token, tmp, firstRestricted, message, generator, isAsync,
                previousStrict, previousYieldAllowed, previousAwaitAllowed,
                marker = markerCreate(), typeParameters;
    
            isAsync = false;
            if (matchAsync()) {
                lex();
                isAsync = true;
            }
    
            expectKeyword('function');
    
            generator = false;
            if (match('*')) {
                lex();
                generator = true;
            }
    
            token = lookahead;
    
            id = parseVariableIdentifier();
    
            if (match('<')) {
                typeParameters = parseTypeParameterDeclaration();
            }
    
            if (strict) {
                if (isRestrictedWord(token.value)) {
                    throwErrorTolerant(token, Messages.StrictFunctionName);
                }
            } else {
                if (isRestrictedWord(token.value)) {
                    firstRestricted = token;
                    message = Messages.StrictFunctionName;
                } else if (isStrictModeReservedWord(token.value)) {
                    firstRestricted = token;
                    message = Messages.StrictReservedWord;
                }
            }
    
            tmp = parseParams(firstRestricted);
            firstRestricted = tmp.firstRestricted;
            if (tmp.message) {
                message = tmp.message;
            }
    
            previousStrict = strict;
            previousYieldAllowed = state.yieldAllowed;
            state.yieldAllowed = generator;
            previousAwaitAllowed = state.awaitAllowed;
            state.awaitAllowed = isAsync;
    
            body = parseFunctionSourceElements();
    
            if (strict && firstRestricted) {
                throwError(firstRestricted, message);
            }
            if (strict && tmp.stricted) {
                throwErrorTolerant(tmp.stricted, message);
            }
            strict = previousStrict;
            state.yieldAllowed = previousYieldAllowed;
            state.awaitAllowed = previousAwaitAllowed;
    
            return markerApply(
                marker,
                delegate.createFunctionDeclaration(
                    id,
                    tmp.params,
                    tmp.defaults,
                    body,
                    tmp.rest,
                    generator,
                    false,
                    isAsync,
                    tmp.returnType,
                    typeParameters
                )
            );
        }
    
        function parseFunctionExpression() {
            var token, id = null, firstRestricted, message, tmp, body, generator, isAsync,
                previousStrict, previousYieldAllowed, previousAwaitAllowed,
                marker = markerCreate(), typeParameters;
    
            isAsync = false;
            if (matchAsync()) {
                lex();
                isAsync = true;
            }
    
            expectKeyword('function');
    
            generator = false;
    
            if (match('*')) {
                lex();
                generator = true;
            }
    
            if (!match('(')) {
                if (!match('<')) {
                    token = lookahead;
                    id = parseVariableIdentifier();
    
                    if (strict) {
                        if (isRestrictedWord(token.value)) {
                            throwErrorTolerant(token, Messages.StrictFunctionName);
                        }
                    } else {
                        if (isRestrictedWord(token.value)) {
                            firstRestricted = token;
                            message = Messages.StrictFunctionName;
                        } else if (isStrictModeReservedWord(token.value)) {
                            firstRestricted = token;
                            message = Messages.StrictReservedWord;
                        }
                    }
                }
    
                if (match('<')) {
                    typeParameters = parseTypeParameterDeclaration();
                }
            }
    
            tmp = parseParams(firstRestricted);
            firstRestricted = tmp.firstRestricted;
            if (tmp.message) {
                message = tmp.message;
            }
    
            previousStrict = strict;
            previousYieldAllowed = state.yieldAllowed;
            state.yieldAllowed = generator;
            previousAwaitAllowed = state.awaitAllowed;
            state.awaitAllowed = isAsync;
    
            body = parseFunctionSourceElements();
    
            if (strict && firstRestricted) {
                throwError(firstRestricted, message);
            }
            if (strict && tmp.stricted) {
                throwErrorTolerant(tmp.stricted, message);
            }
            strict = previousStrict;
            state.yieldAllowed = previousYieldAllowed;
            state.awaitAllowed = previousAwaitAllowed;
    
            return markerApply(
                marker,
                delegate.createFunctionExpression(
                    id,
                    tmp.params,
                    tmp.defaults,
                    body,
                    tmp.rest,
                    generator,
                    false,
                    isAsync,
                    tmp.returnType,
                    typeParameters
                )
            );
        }
    
        function parseYieldExpression() {
            var delegateFlag, expr, marker = markerCreate();
    
            expectKeyword('yield', !strict);
    
            delegateFlag = false;
            if (match('*')) {
                lex();
                delegateFlag = true;
            }
    
            expr = parseAssignmentExpression();
    
            return markerApply(marker, delegate.createYieldExpression(expr, delegateFlag));
        }
    
        function parseAwaitExpression() {
            var expr, marker = markerCreate();
            expectContextualKeyword('await');
            expr = parseAssignmentExpression();
            return markerApply(marker, delegate.createAwaitExpression(expr));
        }
    
        // 14 Functions and classes
    
        // 14.1 Functions is defined above (13 in ES5)
        // 14.2 Arrow Functions Definitions is defined in (7.3 assignments)
    
        // 14.3 Method Definitions
        // 14.3.7
        function specialMethod(methodDefinition) {
            return methodDefinition.kind === 'get' ||
                   methodDefinition.kind === 'set' ||
                   methodDefinition.value.generator;
        }
    
        function parseMethodDefinition(key, isStatic, generator, computed) {
            var token, param, propType,
                isAsync, typeParameters, tokenValue, returnType;
    
            propType = isStatic ? ClassPropertyType.static : ClassPropertyType.prototype;
    
            if (generator) {
                return delegate.createMethodDefinition(
                    propType,
                    '',
                    key,
                    parsePropertyMethodFunction({ generator: true }),
                    computed
                );
            }
    
            tokenValue = key.type === 'Identifier' && key.name;
    
            if (tokenValue === 'get' && !match('(')) {
                key = parseObjectPropertyKey();
    
                expect('(');
                expect(')');
                if (match(':')) {
                    returnType = parseTypeAnnotation();
                }
                return delegate.createMethodDefinition(
                    propType,
                    'get',
                    key,
                    parsePropertyFunction({ generator: false, returnType: returnType }),
                    computed
                );
            }
            if (tokenValue === 'set' && !match('(')) {
                key = parseObjectPropertyKey();
    
                expect('(');
                token = lookahead;
                param = [ parseTypeAnnotatableIdentifier() ];
                expect(')');
                if (match(':')) {
                    returnType = parseTypeAnnotation();
                }
                return delegate.createMethodDefinition(
                    propType,
                    'set',
                    key,
                    parsePropertyFunction({
                        params: param,
                        generator: false,
                        name: token,
                        returnType: returnType
                    }),
                    computed
                );
            }
    
            if (match('<')) {
                typeParameters = parseTypeParameterDeclaration();
            }
    
            isAsync = tokenValue === 'async' && !match('(');
            if (isAsync) {
                key = parseObjectPropertyKey();
            }
    
            return delegate.createMethodDefinition(
                propType,
                '',
                key,
                parsePropertyMethodFunction({
                    generator: false,
                    async: isAsync,
                    typeParameters: typeParameters
                }),
                computed
            );
        }
    
        function parseClassProperty(key, computed, isStatic) {
            var typeAnnotation;
    
            typeAnnotation = parseTypeAnnotation();
            expect(';');
    
            return delegate.createClassProperty(
                key,
                typeAnnotation,
                computed,
                isStatic
            );
        }
    
        function parseClassElement() {
            var computed = false, generator = false, key, marker = markerCreate(),
                isStatic = false, possiblyOpenBracketToken;
            if (match(';')) {
                lex();
                return undefined;
            }
    
            if (lookahead.value === 'static') {
                lex();
                isStatic = true;
            }
    
            if (match('*')) {
                lex();
                generator = true;
            }
    
            possiblyOpenBracketToken = lookahead;
            if (matchContextualKeyword('get') || matchContextualKeyword('set')) {
                possiblyOpenBracketToken = lookahead2();
            }
    
            if (possiblyOpenBracketToken.type === Token.Punctuator
                    && possiblyOpenBracketToken.value === '[') {
                computed = true;
            }
    
            key = parseObjectPropertyKey();
    
            if (!generator && lookahead.value === ':') {
                return markerApply(marker, parseClassProperty(key, computed, isStatic));
            }
    
            return markerApply(marker, parseMethodDefinition(
                key,
                isStatic,
                generator,
                computed
            ));
        }
    
        function parseClassBody() {
            var classElement, classElements = [], existingProps = {},
                marker = markerCreate(), propName, propType;
    
            existingProps[ClassPropertyType.static] = new StringMap();
            existingProps[ClassPropertyType.prototype] = new StringMap();
    
            expect('{');
    
            while (index < length) {
                if (match('}')) {
                    break;
                }
                classElement = parseClassElement(existingProps);
    
                if (typeof classElement !== 'undefined') {
                    classElements.push(classElement);
    
                    propName = !classElement.computed && getFieldName(classElement.key);
                    if (propName !== false) {
                        propType = classElement.static ?
                                    ClassPropertyType.static :
                                    ClassPropertyType.prototype;
    
                        if (classElement.type === Syntax.MethodDefinition) {
                            if (propName === 'constructor' && !classElement.static) {
                                if (specialMethod(classElement)) {
                                    throwError(classElement, Messages.IllegalClassConstructorProperty);
                                }
                                if (existingProps[ClassPropertyType.prototype].has('constructor')) {
                                    throwError(classElement.key, Messages.IllegalDuplicateClassProperty);
                                }
                            }
                            existingProps[propType].set(propName, true);
                        }
                    }
                }
            }
    
            expect('}');
    
            return markerApply(marker, delegate.createClassBody(classElements));
        }
    
        function parseClassImplements() {
            var id, implemented = [], marker, typeParameters;
            if (strict) {
                expectKeyword('implements');
            } else {
                expectContextualKeyword('implements');
            }
            while (index < length) {
                marker = markerCreate();
                id = parseVariableIdentifier();
                if (match('<')) {
                    typeParameters = parseTypeParameterInstantiation();
                } else {
                    typeParameters = null;
                }
                implemented.push(markerApply(marker, delegate.createClassImplements(
                    id,
                    typeParameters
                )));
                if (!match(',')) {
                    break;
                }
                expect(',');
            }
            return implemented;
        }
    
        function parseClassExpression() {
            var id, implemented, previousYieldAllowed, superClass = null,
                superTypeParameters, marker = markerCreate(), typeParameters,
                matchImplements;
    
            expectKeyword('class');
    
            matchImplements =
                    strict
                    ? matchKeyword('implements')
                    : matchContextualKeyword('implements');
    
            if (!matchKeyword('extends') && !matchImplements && !match('{')) {
                id = parseVariableIdentifier();
            }
    
            if (match('<')) {
                typeParameters = parseTypeParameterDeclaration();
            }
    
            if (matchKeyword('extends')) {
                expectKeyword('extends');
                previousYieldAllowed = state.yieldAllowed;
                state.yieldAllowed = false;
                superClass = parseLeftHandSideExpressionAllowCall();
                if (match('<')) {
                    superTypeParameters = parseTypeParameterInstantiation();
                }
                state.yieldAllowed = previousYieldAllowed;
            }
    
            if (strict ? matchKeyword('implements') : matchContextualKeyword('implements')) {
                implemented = parseClassImplements();
            }
    
            return markerApply(marker, delegate.createClassExpression(
                id,
                superClass,
                parseClassBody(),
                typeParameters,
                superTypeParameters,
                implemented
            ));
        }
    
        function parseClassDeclaration() {
            var id, implemented, previousYieldAllowed, superClass = null,
                superTypeParameters, marker = markerCreate(), typeParameters;
    
            expectKeyword('class');
    
            id = parseVariableIdentifier();
    
            if (match('<')) {
                typeParameters = parseTypeParameterDeclaration();
            }
    
            if (matchKeyword('extends')) {
                expectKeyword('extends');
                previousYieldAllowed = state.yieldAllowed;
                state.yieldAllowed = false;
                superClass = parseLeftHandSideExpressionAllowCall();
                if (match('<')) {
                    superTypeParameters = parseTypeParameterInstantiation();
                }
                state.yieldAllowed = previousYieldAllowed;
            }
    
            if (strict ? matchKeyword('implements') : matchContextualKeyword('implements')) {
                implemented = parseClassImplements();
            }
    
            return markerApply(marker, delegate.createClassDeclaration(
                id,
                superClass,
                parseClassBody(),
                typeParameters,
                superTypeParameters,
                implemented
            ));
        }
    
        // 15 Program
    
        function parseSourceElement() {
            var token;
            if (lookahead.type === Token.Keyword) {
                switch (lookahead.value) {
                case 'const':
                case 'let':
                    return parseConstLetDeclaration(lookahead.value);
                case 'function':
                    return parseFunctionDeclaration();
                case 'export':
                    throwErrorTolerant({}, Messages.IllegalExportDeclaration);
                    return parseExportDeclaration();
                case 'import':
                    throwErrorTolerant({}, Messages.IllegalImportDeclaration);
                    return parseImportDeclaration();
                case 'interface':
                    if (lookahead2().type === Token.Identifier) {
                        return parseInterface();
                    }
                    return parseStatement();
                default:
                    return parseStatement();
                }
            }
    
            if (matchContextualKeyword('type')
                    && lookahead2().type === Token.Identifier) {
                return parseTypeAlias();
            }
    
            if (matchContextualKeyword('interface')
                    && lookahead2().type === Token.Identifier) {
                return parseInterface();
            }
    
            if (matchContextualKeyword('declare')) {
                token = lookahead2();
                if (token.type === Token.Keyword) {
                    switch (token.value) {
                    case 'class':
                        return parseDeclareClass();
                    case 'function':
                        return parseDeclareFunction();
                    case 'var':
                        return parseDeclareVariable();
                    }
                } else if (token.type === Token.Identifier
                        && token.value === 'module') {
                    return parseDeclareModule();
                }
            }
    
            if (lookahead.type !== Token.EOF) {
                return parseStatement();
            }
        }
    
        function parseProgramElement() {
            var isModule = extra.sourceType === 'module' || extra.sourceType === 'nonStrictModule';
    
            if (isModule && lookahead.type === Token.Keyword) {
                switch (lookahead.value) {
                case 'export':
                    return parseExportDeclaration();
                case 'import':
                    return parseImportDeclaration();
                }
            }
    
            return parseSourceElement();
        }
    
        function parseProgramElements() {
            var sourceElement, sourceElements = [], token, directive, firstRestricted;
    
            while (index < length) {
                token = lookahead;
                if (token.type !== Token.StringLiteral) {
                    break;
                }
    
                sourceElement = parseProgramElement();
                sourceElements.push(sourceElement);
                if (sourceElement.expression.type !== Syntax.Literal) {
                    // this is not directive
                    break;
                }
                directive = source.slice(token.range[0] + 1, token.range[1] - 1);
                if (directive === 'use strict') {
                    strict = true;
                    if (firstRestricted) {
                        throwErrorTolerant(firstRestricted, Messages.StrictOctalLiteral);
                    }
                } else {
                    if (!firstRestricted && token.octal) {
                        firstRestricted = token;
                    }
                }
            }
    
            while (index < length) {
                sourceElement = parseProgramElement();
                if (typeof sourceElement === 'undefined') {
                    break;
                }
                sourceElements.push(sourceElement);
            }
            return sourceElements;
        }
    
        function parseProgram() {
            var body, marker = markerCreate();
            strict = extra.sourceType === 'module';
            peek();
            body = parseProgramElements();
            return markerApply(marker, delegate.createProgram(body));
        }
    
        // 16 JSX
    
        XHTMLEntities = {
            quot: '\u0022',
            amp: '&',
            apos: '\u0027',
            lt: '<',
            gt: '>',
            nbsp: '\u00A0',
            iexcl: '\u00A1',
            cent: '\u00A2',
            pound: '\u00A3',
            curren: '\u00A4',
            yen: '\u00A5',
            brvbar: '\u00A6',
            sect: '\u00A7',
            uml: '\u00A8',
            copy: '\u00A9',
            ordf: '\u00AA',
            laquo: '\u00AB',
            not: '\u00AC',
            shy: '\u00AD',
            reg: '\u00AE',
            macr: '\u00AF',
            deg: '\u00B0',
            plusmn: '\u00B1',
            sup2: '\u00B2',
            sup3: '\u00B3',
            acute: '\u00B4',
            micro: '\u00B5',
            para: '\u00B6',
            middot: '\u00B7',
            cedil: '\u00B8',
            sup1: '\u00B9',
            ordm: '\u00BA',
            raquo: '\u00BB',
            frac14: '\u00BC',
            frac12: '\u00BD',
            frac34: '\u00BE',
            iquest: '\u00BF',
            Agrave: '\u00C0',
            Aacute: '\u00C1',
            Acirc: '\u00C2',
            Atilde: '\u00C3',
            Auml: '\u00C4',
            Aring: '\u00C5',
            AElig: '\u00C6',
            Ccedil: '\u00C7',
            Egrave: '\u00C8',
            Eacute: '\u00C9',
            Ecirc: '\u00CA',
            Euml: '\u00CB',
            Igrave: '\u00CC',
            Iacute: '\u00CD',
            Icirc: '\u00CE',
            Iuml: '\u00CF',
            ETH: '\u00D0',
            Ntilde: '\u00D1',
            Ograve: '\u00D2',
            Oacute: '\u00D3',
            Ocirc: '\u00D4',
            Otilde: '\u00D5',
            Ouml: '\u00D6',
            times: '\u00D7',
            Oslash: '\u00D8',
            Ugrave: '\u00D9',
            Uacute: '\u00DA',
            Ucirc: '\u00DB',
            Uuml: '\u00DC',
            Yacute: '\u00DD',
            THORN: '\u00DE',
            szlig: '\u00DF',
            agrave: '\u00E0',
            aacute: '\u00E1',
            acirc: '\u00E2',
            atilde: '\u00E3',
            auml: '\u00E4',
            aring: '\u00E5',
            aelig: '\u00E6',
            ccedil: '\u00E7',
            egrave: '\u00E8',
            eacute: '\u00E9',
            ecirc: '\u00EA',
            euml: '\u00EB',
            igrave: '\u00EC',
            iacute: '\u00ED',
            icirc: '\u00EE',
            iuml: '\u00EF',
            eth: '\u00F0',
            ntilde: '\u00F1',
            ograve: '\u00F2',
            oacute: '\u00F3',
            ocirc: '\u00F4',
            otilde: '\u00F5',
            ouml: '\u00F6',
            divide: '\u00F7',
            oslash: '\u00F8',
            ugrave: '\u00F9',
            uacute: '\u00FA',
            ucirc: '\u00FB',
            uuml: '\u00FC',
            yacute: '\u00FD',
            thorn: '\u00FE',
            yuml: '\u00FF',
            OElig: '\u0152',
            oelig: '\u0153',
            Scaron: '\u0160',
            scaron: '\u0161',
            Yuml: '\u0178',
            fnof: '\u0192',
            circ: '\u02C6',
            tilde: '\u02DC',
            Alpha: '\u0391',
            Beta: '\u0392',
            Gamma: '\u0393',
            Delta: '\u0394',
            Epsilon: '\u0395',
            Zeta: '\u0396',
            Eta: '\u0397',
            Theta: '\u0398',
            Iota: '\u0399',
            Kappa: '\u039A',
            Lambda: '\u039B',
            Mu: '\u039C',
            Nu: '\u039D',
            Xi: '\u039E',
            Omicron: '\u039F',
            Pi: '\u03A0',
            Rho: '\u03A1',
            Sigma: '\u03A3',
            Tau: '\u03A4',
            Upsilon: '\u03A5',
            Phi: '\u03A6',
            Chi: '\u03A7',
            Psi: '\u03A8',
            Omega: '\u03A9',
            alpha: '\u03B1',
            beta: '\u03B2',
            gamma: '\u03B3',
            delta: '\u03B4',
            epsilon: '\u03B5',
            zeta: '\u03B6',
            eta: '\u03B7',
            theta: '\u03B8',
            iota: '\u03B9',
            kappa: '\u03BA',
            lambda: '\u03BB',
            mu: '\u03BC',
            nu: '\u03BD',
            xi: '\u03BE',
            omicron: '\u03BF',
            pi: '\u03C0',
            rho: '\u03C1',
            sigmaf: '\u03C2',
            sigma: '\u03C3',
            tau: '\u03C4',
            upsilon: '\u03C5',
            phi: '\u03C6',
            chi: '\u03C7',
            psi: '\u03C8',
            omega: '\u03C9',
            thetasym: '\u03D1',
            upsih: '\u03D2',
            piv: '\u03D6',
            ensp: '\u2002',
            emsp: '\u2003',
            thinsp: '\u2009',
            zwnj: '\u200C',
            zwj: '\u200D',
            lrm: '\u200E',
            rlm: '\u200F',
            ndash: '\u2013',
            mdash: '\u2014',
            lsquo: '\u2018',
            rsquo: '\u2019',
            sbquo: '\u201A',
            ldquo: '\u201C',
            rdquo: '\u201D',
            bdquo: '\u201E',
            dagger: '\u2020',
            Dagger: '\u2021',
            bull: '\u2022',
            hellip: '\u2026',
            permil: '\u2030',
            prime: '\u2032',
            Prime: '\u2033',
            lsaquo: '\u2039',
            rsaquo: '\u203A',
            oline: '\u203E',
            frasl: '\u2044',
            euro: '\u20AC',
            image: '\u2111',
            weierp: '\u2118',
            real: '\u211C',
            trade: '\u2122',
            alefsym: '\u2135',
            larr: '\u2190',
            uarr: '\u2191',
            rarr: '\u2192',
            darr: '\u2193',
            harr: '\u2194',
            crarr: '\u21B5',
            lArr: '\u21D0',
            uArr: '\u21D1',
            rArr: '\u21D2',
            dArr: '\u21D3',
            hArr: '\u21D4',
            forall: '\u2200',
            part: '\u2202',
            exist: '\u2203',
            empty: '\u2205',
            nabla: '\u2207',
            isin: '\u2208',
            notin: '\u2209',
            ni: '\u220B',
            prod: '\u220F',
            sum: '\u2211',
            minus: '\u2212',
            lowast: '\u2217',
            radic: '\u221A',
            prop: '\u221D',
            infin: '\u221E',
            ang: '\u2220',
            and: '\u2227',
            or: '\u2228',
            cap: '\u2229',
            cup: '\u222A',
            'int': '\u222B',
            there4: '\u2234',
            sim: '\u223C',
            cong: '\u2245',
            asymp: '\u2248',
            ne: '\u2260',
            equiv: '\u2261',
            le: '\u2264',
            ge: '\u2265',
            sub: '\u2282',
            sup: '\u2283',
            nsub: '\u2284',
            sube: '\u2286',
            supe: '\u2287',
            oplus: '\u2295',
            otimes: '\u2297',
            perp: '\u22A5',
            sdot: '\u22C5',
            lceil: '\u2308',
            rceil: '\u2309',
            lfloor: '\u230A',
            rfloor: '\u230B',
            lang: '\u2329',
            rang: '\u232A',
            loz: '\u25CA',
            spades: '\u2660',
            clubs: '\u2663',
            hearts: '\u2665',
            diams: '\u2666'
        };
    
        function getQualifiedJSXName(object) {
            if (object.type === Syntax.JSXIdentifier) {
                return object.name;
            }
            if (object.type === Syntax.JSXNamespacedName) {
                return object.namespace.name + ':' + object.name.name;
            }
            /* istanbul ignore else */
            if (object.type === Syntax.JSXMemberExpression) {
                return (
                    getQualifiedJSXName(object.object) + '.' +
                    getQualifiedJSXName(object.property)
                );
            }
            /* istanbul ignore next */
            throwUnexpected(object);
        }
    
        function isJSXIdentifierStart(ch) {
            // exclude backslash (\)
            return (ch !== 92) && isIdentifierStart(ch);
        }
    
        function isJSXIdentifierPart(ch) {
            // exclude backslash (\) and add hyphen (-)
            return (ch !== 92) && (ch === 45 || isIdentifierPart(ch));
        }
    
        function scanJSXIdentifier() {
            var ch, start, value = '';
    
            start = index;
            while (index < length) {
                ch = source.charCodeAt(index);
                if (!isJSXIdentifierPart(ch)) {
                    break;
                }
                value += source[index++];
            }
    
            return {
                type: Token.JSXIdentifier,
                value: value,
                lineNumber: lineNumber,
                lineStart: lineStart,
                range: [start, index]
            };
        }
    
        function scanJSXEntity() {
            var ch, str = '', start = index, count = 0, code;
            ch = source[index];
            assert(ch === '&', 'Entity must start with an ampersand');
            index++;
            while (index < length && count++ < 10) {
                ch = source[index++];
                if (ch === ';') {
                    break;
                }
                str += ch;
            }
    
            // Well-formed entity (ending was found).
            if (ch === ';') {
                // Numeric entity.
                if (str[0] === '#') {
                    if (str[1] === 'x') {
                        code = +('0' + str.substr(1));
                    } else {
                        // Removing leading zeros in order to avoid treating as octal in old browsers.
                        code = +str.substr(1).replace(Regex.LeadingZeros, '');
                    }
    
                    if (!isNaN(code)) {
                        return String.fromCharCode(code);
                    }
                /* istanbul ignore else */
                } else if (XHTMLEntities[str]) {
                    return XHTMLEntities[str];
                }
            }
    
            // Treat non-entity sequences as regular text.
            index = start + 1;
            return '&';
        }
    
        function scanJSXText(stopChars) {
            var ch, str = '', start;
            start = index;
            while (index < length) {
                ch = source[index];
                if (stopChars.indexOf(ch) !== -1) {
                    break;
                }
                if (ch === '&') {
                    str += scanJSXEntity();
                } else {
                    index++;
                    if (ch === '\r' && source[index] === '\n') {
                        str += ch;
                        ch = source[index];
                        index++;
                    }
                    if (isLineTerminator(ch.charCodeAt(0))) {
                        ++lineNumber;
                        lineStart = index;
                    }
                    str += ch;
                }
            }
            return {
                type: Token.JSXText,
                value: str,
                lineNumber: lineNumber,
                lineStart: lineStart,
                range: [start, index]
            };
        }
    
        function scanJSXStringLiteral() {
            var innerToken, quote, start;
    
            quote = source[index];
            assert((quote === '\'' || quote === '"'),
                'String literal must starts with a quote');
    
            start = index;
            ++index;
    
            innerToken = scanJSXText([quote]);
    
            if (quote !== source[index]) {
                throwError({}, Messages.UnexpectedToken, 'ILLEGAL');
            }
    
            ++index;
    
            innerToken.range = [start, index];
    
            return innerToken;
        }
    
        /**
         * Between JSX opening and closing tags (e.g. <foo>HERE</foo>), anything that
         * is not another JSX tag and is not an expression wrapped by {} is text.
         */
        function advanceJSXChild() {
            var ch = source.charCodeAt(index);
    
            // '<' 60, '>' 62, '{' 123, '}' 125
            if (ch !== 60 && ch !== 62 && ch !== 123 && ch !== 125) {
                return scanJSXText(['<', '>', '{', '}']);
            }
    
            return scanPunctuator();
        }
    
        function parseJSXIdentifier() {
            var token, marker = markerCreate();
    
            if (lookahead.type !== Token.JSXIdentifier) {
                throwUnexpected(lookahead);
            }
    
            token = lex();
            return markerApply(marker, delegate.createJSXIdentifier(token.value));
        }
    
        function parseJSXNamespacedName() {
            var namespace, name, marker = markerCreate();
    
            namespace = parseJSXIdentifier();
            expect(':');
            name = parseJSXIdentifier();
    
            return markerApply(marker, delegate.createJSXNamespacedName(namespace, name));
        }
    
        function parseJSXMemberExpression() {
            var marker = markerCreate(),
                expr = parseJSXIdentifier();
    
            while (match('.')) {
                lex();
                expr = markerApply(marker, delegate.createJSXMemberExpression(expr, parseJSXIdentifier()));
            }
    
            return expr;
        }
    
        function parseJSXElementName() {
            if (lookahead2().value === ':') {
                return parseJSXNamespacedName();
            }
            if (lookahead2().value === '.') {
                return parseJSXMemberExpression();
            }
    
            return parseJSXIdentifier();
        }
    
        function parseJSXAttributeName() {
            if (lookahead2().value === ':') {
                return parseJSXNamespacedName();
            }
    
            return parseJSXIdentifier();
        }
    
        function parseJSXAttributeValue() {
            var value, marker;
            if (match('{')) {
                value = parseJSXExpressionContainer();
                if (value.expression.type === Syntax.JSXEmptyExpression) {
                    throwError(
                        value,
                        'JSX attributes must only be assigned a non-empty ' +
                            'expression'
                    );
                }
            } else if (match('<')) {
                value = parseJSXElement();
            } else if (lookahead.type === Token.JSXText) {
                marker = markerCreate();
                value = markerApply(marker, delegate.createLiteral(lex()));
            } else {
                throwError({}, Messages.InvalidJSXAttributeValue);
            }
            return value;
        }
    
        function parseJSXEmptyExpression() {
            var marker = markerCreatePreserveWhitespace();
            while (source.charAt(index) !== '}') {
                index++;
            }
            return markerApply(marker, delegate.createJSXEmptyExpression());
        }
    
        function parseJSXExpressionContainer() {
            var expression, origInJSXChild, origInJSXTag, marker = markerCreate();
    
            origInJSXChild = state.inJSXChild;
            origInJSXTag = state.inJSXTag;
            state.inJSXChild = false;
            state.inJSXTag = false;
    
            expect('{');
    
            if (match('}')) {
                expression = parseJSXEmptyExpression();
            } else {
                expression = parseExpression();
            }
    
            state.inJSXChild = origInJSXChild;
            state.inJSXTag = origInJSXTag;
    
            expect('}');
    
            return markerApply(marker, delegate.createJSXExpressionContainer(expression));
        }
    
        function parseJSXSpreadAttribute() {
            var expression, origInJSXChild, origInJSXTag, marker = markerCreate();
    
            origInJSXChild = state.inJSXChild;
            origInJSXTag = state.inJSXTag;
            state.inJSXChild = false;
            state.inJSXTag = false;
    
            expect('{');
            expect('...');
    
            expression = parseAssignmentExpression();
    
            state.inJSXChild = origInJSXChild;
            state.inJSXTag = origInJSXTag;
    
            expect('}');
    
            return markerApply(marker, delegate.createJSXSpreadAttribute(expression));
        }
    
        function parseJSXAttribute() {
            var name, marker;
    
            if (match('{')) {
                return parseJSXSpreadAttribute();
            }
    
            marker = markerCreate();
    
            name = parseJSXAttributeName();
    
            // HTML empty attribute
            if (match('=')) {
                lex();
                return markerApply(marker, delegate.createJSXAttribute(name, parseJSXAttributeValue()));
            }
    
            return markerApply(marker, delegate.createJSXAttribute(name));
        }
    
        function parseJSXChild() {
            var token, marker;
            if (match('{')) {
                token = parseJSXExpressionContainer();
            } else if (lookahead.type === Token.JSXText) {
                marker = markerCreatePreserveWhitespace();
                token = markerApply(marker, delegate.createLiteral(lex()));
            } else if (match('<')) {
                token = parseJSXElement();
            } else {
                throwUnexpected(lookahead);
            }
            return token;
        }
    
        function parseJSXClosingElement() {
            var name, origInJSXChild, origInJSXTag, marker = markerCreate();
            origInJSXChild = state.inJSXChild;
            origInJSXTag = state.inJSXTag;
            state.inJSXChild = false;
            state.inJSXTag = true;
            expect('<');
            expect('/');
            name = parseJSXElementName();
            // Because advance() (called by lex() called by expect()) expects there
            // to be a valid token after >, it needs to know whether to look for a
            // standard JS token or an JSX text node
            state.inJSXChild = origInJSXChild;
            state.inJSXTag = origInJSXTag;
            expect('>');
            return markerApply(marker, delegate.createJSXClosingElement(name));
        }
    
        function parseJSXOpeningElement() {
            var name, attributes = [], selfClosing = false, origInJSXChild, origInJSXTag, marker = markerCreate();
    
            origInJSXChild = state.inJSXChild;
            origInJSXTag = state.inJSXTag;
            state.inJSXChild = false;
            state.inJSXTag = true;
    
            expect('<');
    
            name = parseJSXElementName();
    
            while (index < length &&
                    lookahead.value !== '/' &&
                    lookahead.value !== '>') {
                attributes.push(parseJSXAttribute());
            }
    
            state.inJSXTag = origInJSXTag;
    
            if (lookahead.value === '/') {
                expect('/');
                // Because advance() (called by lex() called by expect()) expects
                // there to be a valid token after >, it needs to know whether to
                // look for a standard JS token or an JSX text node
                state.inJSXChild = origInJSXChild;
                expect('>');
                selfClosing = true;
            } else {
                state.inJSXChild = true;
                expect('>');
            }
            return markerApply(marker, delegate.createJSXOpeningElement(name, attributes, selfClosing));
        }
    
        function parseJSXElement() {
            var openingElement, closingElement = null, children = [], origInJSXChild, origInJSXTag, marker = markerCreate();
    
            origInJSXChild = state.inJSXChild;
            origInJSXTag = state.inJSXTag;
            openingElement = parseJSXOpeningElement();
    
            if (!openingElement.selfClosing) {
                while (index < length) {
                    state.inJSXChild = false; // Call lookahead2() with inJSXChild = false because </ should not be considered in the child
                    if (lookahead.value === '<' && lookahead2().value === '/') {
                        break;
                    }
                    state.inJSXChild = true;
                    children.push(parseJSXChild());
                }
                state.inJSXChild = origInJSXChild;
                state.inJSXTag = origInJSXTag;
                closingElement = parseJSXClosingElement();
                if (getQualifiedJSXName(closingElement.name) !== getQualifiedJSXName(openingElement.name)) {
                    throwError({}, Messages.ExpectedJSXClosingTag, getQualifiedJSXName(openingElement.name));
                }
            }
    
            // When (erroneously) writing two adjacent tags like
            //
            //     var x = <div>one</div><div>two</div>;
            //
            // the default error message is a bit incomprehensible. Since it's
            // rarely (never?) useful to write a less-than sign after an JSX
            // element, we disallow it here in the parser in order to provide a
            // better error message. (In the rare case that the less-than operator
            // was intended, the left tag can be wrapped in parentheses.)
            if (!origInJSXChild && match('<')) {
                throwError(lookahead, Messages.AdjacentJSXElements);
            }
    
            return markerApply(marker, delegate.createJSXElement(openingElement, closingElement, children));
        }
    
        function parseTypeAlias() {
            var id, marker = markerCreate(), typeParameters = null, right;
            expectContextualKeyword('type');
            id = parseVariableIdentifier();
            if (match('<')) {
                typeParameters = parseTypeParameterDeclaration();
            }
            expect('=');
            right = parseType();
            consumeSemicolon();
            return markerApply(marker, delegate.createTypeAlias(id, typeParameters, right));
        }
    
        function parseInterfaceExtends() {
            var marker = markerCreate(), id, typeParameters = null;
    
            id = parseVariableIdentifier();
            if (match('<')) {
                typeParameters = parseTypeParameterInstantiation();
            }
    
            return markerApply(marker, delegate.createInterfaceExtends(
                id,
                typeParameters
            ));
        }
    
        function parseInterfaceish(marker, allowStatic) {
            var body, bodyMarker, extended = [], id,
                typeParameters = null;
    
            id = parseVariableIdentifier();
            if (match('<')) {
                typeParameters = parseTypeParameterDeclaration();
            }
    
            if (matchKeyword('extends')) {
                expectKeyword('extends');
    
                while (index < length) {
                    extended.push(parseInterfaceExtends());
                    if (!match(',')) {
                        break;
                    }
                    expect(',');
                }
            }
    
            bodyMarker = markerCreate();
            body = markerApply(bodyMarker, parseObjectType(allowStatic));
    
            return markerApply(marker, delegate.createInterface(
                id,
                typeParameters,
                body,
                extended
            ));
        }
    
        function parseInterface() {
            var marker = markerCreate();
    
            if (strict) {
                expectKeyword('interface');
            } else {
                expectContextualKeyword('interface');
            }
    
            return parseInterfaceish(marker, /* allowStatic */false);
        }
    
        function parseDeclareClass() {
            var marker = markerCreate(), ret;
            expectContextualKeyword('declare');
            expectKeyword('class');
    
            ret = parseInterfaceish(marker, /* allowStatic */true);
            ret.type = Syntax.DeclareClass;
            return ret;
        }
    
        function parseDeclareFunction() {
            var id, idMarker,
                marker = markerCreate(), params, returnType, rest, tmp,
                typeParameters = null, value, valueMarker;
    
            expectContextualKeyword('declare');
            expectKeyword('function');
            idMarker = markerCreate();
            id = parseVariableIdentifier();
    
            valueMarker = markerCreate();
            if (match('<')) {
                typeParameters = parseTypeParameterDeclaration();
            }
            expect('(');
            tmp = parseFunctionTypeParams();
            params = tmp.params;
            rest = tmp.rest;
            expect(')');
    
            expect(':');
            returnType = parseType();
    
            value = markerApply(valueMarker, delegate.createFunctionTypeAnnotation(
                params,
                returnType,
                rest,
                typeParameters
            ));
    
            id.typeAnnotation = markerApply(valueMarker, delegate.createTypeAnnotation(
                value
            ));
            markerApply(idMarker, id);
    
            consumeSemicolon();
    
            return markerApply(marker, delegate.createDeclareFunction(
                id
            ));
        }
    
        function parseDeclareVariable() {
            var id, marker = markerCreate();
            expectContextualKeyword('declare');
            expectKeyword('var');
            id = parseTypeAnnotatableIdentifier();
    
            consumeSemicolon();
    
            return markerApply(marker, delegate.createDeclareVariable(
                id
            ));
        }
    
        function parseDeclareModule() {
            var body = [], bodyMarker, id, idMarker, marker = markerCreate(), token;
            expectContextualKeyword('declare');
            expectContextualKeyword('module');
    
            if (lookahead.type === Token.StringLiteral) {
                if (strict && lookahead.octal) {
                    throwErrorTolerant(lookahead, Messages.StrictOctalLiteral);
                }
                idMarker = markerCreate();
                id = markerApply(idMarker, delegate.createLiteral(lex()));
            } else {
                id = parseVariableIdentifier();
            }
    
            bodyMarker = markerCreate();
            expect('{');
            while (index < length && !match('}')) {
                token = lookahead2();
                switch (token.value) {
                case 'class':
                    body.push(parseDeclareClass());
                    break;
                case 'function':
                    body.push(parseDeclareFunction());
                    break;
                case 'var':
                    body.push(parseDeclareVariable());
                    break;
                default:
                    throwUnexpected(lookahead);
                }
            }
            expect('}');
    
            return markerApply(marker, delegate.createDeclareModule(
                id,
                markerApply(bodyMarker, delegate.createBlockStatement(body))
            ));
        }
    
        function collectToken() {
            var loc, token, range, value, entry;
    
            /* istanbul ignore else */
            if (!state.inJSXChild) {
                skipComment();
            }
    
            loc = {
                start: {
                    line: lineNumber,
                    column: index - lineStart
                }
            };
    
            token = extra.advance();
            loc.end = {
                line: lineNumber,
                column: index - lineStart
            };
    
            if (token.type !== Token.EOF) {
                range = [token.range[0], token.range[1]];
                value = source.slice(token.range[0], token.range[1]);
                entry = {
                    type: TokenName[token.type],
                    value: value,
                    range: range,
                    loc: loc
                };
                if (token.regex) {
                    entry.regex = {
                        pattern: token.regex.pattern,
                        flags: token.regex.flags
                    };
                }
                extra.tokens.push(entry);
            }
    
            return token;
        }
    
        function collectRegex() {
            var pos, loc, regex, token;
    
            skipComment();
    
            pos = index;
            loc = {
                start: {
                    line: lineNumber,
                    column: index - lineStart
                }
            };
    
            regex = extra.scanRegExp();
            loc.end = {
                line: lineNumber,
                column: index - lineStart
            };
    
            if (!extra.tokenize) {
                /* istanbul ignore next */
                // Pop the previous token, which is likely '/' or '/='
                if (extra.tokens.length > 0) {
                    token = extra.tokens[extra.tokens.length - 1];
                    if (token.range[0] === pos && token.type === 'Punctuator') {
                        if (token.value === '/' || token.value === '/=') {
                            extra.tokens.pop();
                        }
                    }
                }
    
                extra.tokens.push({
                    type: 'RegularExpression',
                    value: regex.literal,
                    regex: regex.regex,
                    range: [pos, index],
                    loc: loc
                });
            }
    
            return regex;
        }
    
        function filterTokenLocation() {
            var i, entry, token, tokens = [];
    
            for (i = 0; i < extra.tokens.length; ++i) {
                entry = extra.tokens[i];
                token = {
                    type: entry.type,
                    value: entry.value
                };
                if (entry.regex) {
                    token.regex = {
                        pattern: entry.regex.pattern,
                        flags: entry.regex.flags
                    };
                }
                if (extra.range) {
                    token.range = entry.range;
                }
                if (extra.loc) {
                    token.loc = entry.loc;
                }
                tokens.push(token);
            }
    
            extra.tokens = tokens;
        }
    
        function patch() {
            if (typeof extra.tokens !== 'undefined') {
                extra.advance = advance;
                extra.scanRegExp = scanRegExp;
    
                advance = collectToken;
                scanRegExp = collectRegex;
            }
        }
    
        function unpatch() {
            if (typeof extra.scanRegExp === 'function') {
                advance = extra.advance;
                scanRegExp = extra.scanRegExp;
            }
        }
    
        // This is used to modify the delegate.
    
        function extend(object, properties) {
            var entry, result = {};
    
            for (entry in object) {
                /* istanbul ignore else */
                if (object.hasOwnProperty(entry)) {
                    result[entry] = object[entry];
                }
            }
    
            for (entry in properties) {
                /* istanbul ignore else */
                if (properties.hasOwnProperty(entry)) {
                    result[entry] = properties[entry];
                }
            }
    
            return result;
        }
    
        function tokenize(code, options) {
            var toString,
                token,
                tokens;
    
            toString = String;
            if (typeof code !== 'string' && !(code instanceof String)) {
                code = toString(code);
            }
    
            delegate = SyntaxTreeDelegate;
            source = code;
            index = 0;
            lineNumber = (source.length > 0) ? 1 : 0;
            lineStart = 0;
            length = source.length;
            lookahead = null;
            state = {
                allowKeyword: true,
                allowIn: true,
                labelSet: new StringMap(),
                inFunctionBody: false,
                inIteration: false,
                inSwitch: false,
                lastCommentStart: -1
            };
    
            extra = {};
    
            // Options matching.
            options = options || {};
    
            // Of course we collect tokens here.
            options.tokens = true;
            extra.tokens = [];
            extra.tokenize = true;
            // The following two fields are necessary to compute the Regex tokens.
            extra.openParenToken = -1;
            extra.openCurlyToken = -1;
    
            extra.range = (typeof options.range === 'boolean') && options.range;
            extra.loc = (typeof options.loc === 'boolean') && options.loc;
    
            if (typeof options.comment === 'boolean' && options.comment) {
                extra.comments = [];
            }
            if (typeof options.tolerant === 'boolean' && options.tolerant) {
                extra.errors = [];
            }
    
            patch();
    
            try {
                peek();
                if (lookahead.type === Token.EOF) {
                    return extra.tokens;
                }
    
                token = lex();
                while (lookahead.type !== Token.EOF) {
                    try {
                        token = lex();
                    } catch (lexError) {
                        token = lookahead;
                        if (extra.errors) {
                            extra.errors.push(lexError);
                            // We have to break on the first error
                            // to avoid infinite loops.
                            break;
                        } else {
                            throw lexError;
                        }
                    }
                }
    
                filterTokenLocation();
                tokens = extra.tokens;
                if (typeof extra.comments !== 'undefined') {
                    tokens.comments = extra.comments;
                }
                if (typeof extra.errors !== 'undefined') {
                    tokens.errors = extra.errors;
                }
            } catch (e) {
                throw e;
            } finally {
                unpatch();
                extra = {};
            }
            return tokens;
        }
    
        function parse(code, options) {
            var program, toString;
    
            toString = String;
            if (typeof code !== 'string' && !(code instanceof String)) {
                code = toString(code);
            }
    
            delegate = SyntaxTreeDelegate;
            source = code;
            index = 0;
            lineNumber = (source.length > 0) ? 1 : 0;
            lineStart = 0;
            length = source.length;
            lookahead = null;
            state = {
                allowKeyword: false,
                allowIn: true,
                labelSet: new StringMap(),
                parenthesizedCount: 0,
                inFunctionBody: false,
                inIteration: false,
                inSwitch: false,
                inJSXChild: false,
                inJSXTag: false,
                inType: false,
                lastCommentStart: -1,
                yieldAllowed: false,
                awaitAllowed: false
            };
    
            extra = {};
            if (typeof options !== 'undefined') {
                extra.range = (typeof options.range === 'boolean') && options.range;
                extra.loc = (typeof options.loc === 'boolean') && options.loc;
                extra.attachComment = (typeof options.attachComment === 'boolean') && options.attachComment;
    
                if (extra.loc && options.source !== null && options.source !== undefined) {
                    delegate = extend(delegate, {
                        'postProcess': function (node) {
                            node.loc.source = toString(options.source);
                            return node;
                        }
                    });
                }
    
                extra.sourceType = options.sourceType;
                if (typeof options.tokens === 'boolean' && options.tokens) {
                    extra.tokens = [];
                }
                if (typeof options.comment === 'boolean' && options.comment) {
                    extra.comments = [];
                }
                if (typeof options.tolerant === 'boolean' && options.tolerant) {
                    extra.errors = [];
                }
                if (extra.attachComment) {
                    extra.range = true;
                    extra.comments = [];
                    extra.bottomRightStack = [];
                    extra.trailingComments = [];
                    extra.leadingComments = [];
                }
            }
    
            patch();
            try {
                program = parseProgram();
                if (typeof extra.comments !== 'undefined') {
                    program.comments = extra.comments;
                }
                if (typeof extra.tokens !== 'undefined') {
                    filterTokenLocation();
                    program.tokens = extra.tokens;
                }
                if (typeof extra.errors !== 'undefined') {
                    program.errors = extra.errors;
                }
            } catch (e) {
                throw e;
            } finally {
                unpatch();
                extra = {};
            }
    
            return program;
        }
    
        // Sync with *.json manifests.
        exports.version = '13001.1001.0-dev-harmony-fb';
    
        exports.tokenize = tokenize;
    
        exports.parse = parse;
    
        // Deep copy.
       /* istanbul ignore next */
        exports.Syntax = (function () {
            var name, types = {};
    
            if (typeof Object.create === 'function') {
                types = Object.create(null);
            }
    
            for (name in Syntax) {
                if (Syntax.hasOwnProperty(name)) {
                    types[name] = Syntax[name];
                }
            }
    
            if (typeof Object.freeze === 'function') {
                Object.freeze(types);
            }
    
            return types;
        }());
    
    }));
    /* vim: set sw=4 ts=4 et tw=80 : */
    
  provide("esprima-fb", module.exports);
}(global));

// pakmanager:source-map/source-map/base64
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /* -*- Mode: js; js-indent-level: 2; -*- */
    /*
     * Copyright 2011 Mozilla Foundation and contributors
     * Licensed under the New BSD license. See LICENSE or:
     * http://opensource.org/licenses/BSD-3-Clause
     */
    if (typeof define !== 'function') {
        var define = require('amdefine')(module, require);
    }
    define(function (require, exports, module) {
    
      var charToIntMap = {};
      var intToCharMap = {};
    
      'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
        .split('')
        .forEach(function (ch, index) {
          charToIntMap[ch] = index;
          intToCharMap[index] = ch;
        });
    
      /**
       * Encode an integer in the range of 0 to 63 to a single base 64 digit.
       */
      exports.encode = function base64_encode(aNumber) {
        if (aNumber in intToCharMap) {
          return intToCharMap[aNumber];
        }
        throw new TypeError("Must be between 0 and 63: " + aNumber);
      };
    
      /**
       * Decode a single base 64 digit to an integer.
       */
      exports.decode = function base64_decode(aChar) {
        if (aChar in charToIntMap) {
          return charToIntMap[aChar];
        }
        throw new TypeError("Not a valid base 64 digit: " + aChar);
      };
    
    });
    
  provide("source-map/source-map/base64", module.exports);
}(global));

// pakmanager:source-map/source-map/util
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /* -*- Mode: js; js-indent-level: 2; -*- */
    /*
     * Copyright 2011 Mozilla Foundation and contributors
     * Licensed under the New BSD license. See LICENSE or:
     * http://opensource.org/licenses/BSD-3-Clause
     */
    if (typeof define !== 'function') {
        var define = require('amdefine')(module, require);
    }
    define(function (require, exports, module) {
    
      /**
       * This is a helper function for getting values from parameter/options
       * objects.
       *
       * @param args The object we are extracting values from
       * @param name The name of the property we are getting.
       * @param defaultValue An optional value to return if the property is missing
       * from the object. If this is not specified and the property is missing, an
       * error will be thrown.
       */
      function getArg(aArgs, aName, aDefaultValue) {
        if (aName in aArgs) {
          return aArgs[aName];
        } else if (arguments.length === 3) {
          return aDefaultValue;
        } else {
          throw new Error('"' + aName + '" is a required argument.');
        }
      }
      exports.getArg = getArg;
    
      var urlRegexp = /([\w+\-.]+):\/\/((\w+:\w+)@)?([\w.]+)?(:(\d+))?(\S+)?/;
      var dataUrlRegexp = /^data:.+\,.+/;
    
      function urlParse(aUrl) {
        var match = aUrl.match(urlRegexp);
        if (!match) {
          return null;
        }
        return {
          scheme: match[1],
          auth: match[3],
          host: match[4],
          port: match[6],
          path: match[7]
        };
      }
      exports.urlParse = urlParse;
    
      function urlGenerate(aParsedUrl) {
        var url = aParsedUrl.scheme + "://";
        if (aParsedUrl.auth) {
          url += aParsedUrl.auth + "@"
        }
        if (aParsedUrl.host) {
          url += aParsedUrl.host;
        }
        if (aParsedUrl.port) {
          url += ":" + aParsedUrl.port
        }
        if (aParsedUrl.path) {
          url += aParsedUrl.path;
        }
        return url;
      }
      exports.urlGenerate = urlGenerate;
    
      function join(aRoot, aPath) {
        var url;
    
        if (aPath.match(urlRegexp) || aPath.match(dataUrlRegexp)) {
          return aPath;
        }
    
        if (aPath.charAt(0) === '/' && (url = urlParse(aRoot))) {
          url.path = aPath;
          return urlGenerate(url);
        }
    
        return aRoot.replace(/\/$/, '') + '/' + aPath;
      }
      exports.join = join;
    
      /**
       * Because behavior goes wacky when you set `__proto__` on objects, we
       * have to prefix all the strings in our set with an arbitrary character.
       *
       * See https://github.com/mozilla/source-map/pull/31 and
       * https://github.com/mozilla/source-map/issues/30
       *
       * @param String aStr
       */
      function toSetString(aStr) {
        return '$' + aStr;
      }
      exports.toSetString = toSetString;
    
      function fromSetString(aStr) {
        return aStr.substr(1);
      }
      exports.fromSetString = fromSetString;
    
      function relative(aRoot, aPath) {
        aRoot = aRoot.replace(/\/$/, '');
    
        var url = urlParse(aRoot);
        if (aPath.charAt(0) == "/" && url && url.path == "/") {
          return aPath.slice(1);
        }
    
        return aPath.indexOf(aRoot + '/') === 0
          ? aPath.substr(aRoot.length + 1)
          : aPath;
      }
      exports.relative = relative;
    
      function strcmp(aStr1, aStr2) {
        var s1 = aStr1 || "";
        var s2 = aStr2 || "";
        return (s1 > s2) - (s1 < s2);
      }
    
      /**
       * Comparator between two mappings where the original positions are compared.
       *
       * Optionally pass in `true` as `onlyCompareGenerated` to consider two
       * mappings with the same original source/line/column, but different generated
       * line and column the same. Useful when searching for a mapping with a
       * stubbed out mapping.
       */
      function compareByOriginalPositions(mappingA, mappingB, onlyCompareOriginal) {
        var cmp;
    
        cmp = strcmp(mappingA.source, mappingB.source);
        if (cmp) {
          return cmp;
        }
    
        cmp = mappingA.originalLine - mappingB.originalLine;
        if (cmp) {
          return cmp;
        }
    
        cmp = mappingA.originalColumn - mappingB.originalColumn;
        if (cmp || onlyCompareOriginal) {
          return cmp;
        }
    
        cmp = strcmp(mappingA.name, mappingB.name);
        if (cmp) {
          return cmp;
        }
    
        cmp = mappingA.generatedLine - mappingB.generatedLine;
        if (cmp) {
          return cmp;
        }
    
        return mappingA.generatedColumn - mappingB.generatedColumn;
      };
      exports.compareByOriginalPositions = compareByOriginalPositions;
    
      /**
       * Comparator between two mappings where the generated positions are
       * compared.
       *
       * Optionally pass in `true` as `onlyCompareGenerated` to consider two
       * mappings with the same generated line and column, but different
       * source/name/original line and column the same. Useful when searching for a
       * mapping with a stubbed out mapping.
       */
      function compareByGeneratedPositions(mappingA, mappingB, onlyCompareGenerated) {
        var cmp;
    
        cmp = mappingA.generatedLine - mappingB.generatedLine;
        if (cmp) {
          return cmp;
        }
    
        cmp = mappingA.generatedColumn - mappingB.generatedColumn;
        if (cmp || onlyCompareGenerated) {
          return cmp;
        }
    
        cmp = strcmp(mappingA.source, mappingB.source);
        if (cmp) {
          return cmp;
        }
    
        cmp = mappingA.originalLine - mappingB.originalLine;
        if (cmp) {
          return cmp;
        }
    
        cmp = mappingA.originalColumn - mappingB.originalColumn;
        if (cmp) {
          return cmp;
        }
    
        return strcmp(mappingA.name, mappingB.name);
      };
      exports.compareByGeneratedPositions = compareByGeneratedPositions;
    
    });
    
  provide("source-map/source-map/util", module.exports);
}(global));

// pakmanager:source-map/source-map/base64-vlq
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /* -*- Mode: js; js-indent-level: 2; -*- */
    /*
     * Copyright 2011 Mozilla Foundation and contributors
     * Licensed under the New BSD license. See LICENSE or:
     * http://opensource.org/licenses/BSD-3-Clause
     *
     * Based on the Base 64 VLQ implementation in Closure Compiler:
     * https://code.google.com/p/closure-compiler/source/browse/trunk/src/com/google/debugging/sourcemap/Base64VLQ.java
     *
     * Copyright 2011 The Closure Compiler Authors. All rights reserved.
     * Redistribution and use in source and binary forms, with or without
     * modification, are permitted provided that the following conditions are
     * met:
     *
     *  * Redistributions of source code must retain the above copyright
     *    notice, this list of conditions and the following disclaimer.
     *  * Redistributions in binary form must reproduce the above
     *    copyright notice, this list of conditions and the following
     *    disclaimer in the documentation and/or other materials provided
     *    with the distribution.
     *  * Neither the name of Google Inc. nor the names of its
     *    contributors may be used to endorse or promote products derived
     *    from this software without specific prior written permission.
     *
     * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
     * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
     * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
     * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
     * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
     * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
     * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
     * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
     * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
     * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
     * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
     */
    if (typeof define !== 'function') {
        var define = require('amdefine')(module, require);
    }
    define(function (require, exports, module) {
    
      var base64 =  require('source-map/source-map/base64');
    
      // A single base 64 digit can contain 6 bits of data. For the base 64 variable
      // length quantities we use in the source map spec, the first bit is the sign,
      // the next four bits are the actual value, and the 6th bit is the
      // continuation bit. The continuation bit tells us whether there are more
      // digits in this value following this digit.
      //
      //   Continuation
      //   |    Sign
      //   |    |
      //   V    V
      //   101011
    
      var VLQ_BASE_SHIFT = 5;
    
      // binary: 100000
      var VLQ_BASE = 1 << VLQ_BASE_SHIFT;
    
      // binary: 011111
      var VLQ_BASE_MASK = VLQ_BASE - 1;
    
      // binary: 100000
      var VLQ_CONTINUATION_BIT = VLQ_BASE;
    
      /**
       * Converts from a two-complement value to a value where the sign bit is
       * is placed in the least significant bit.  For example, as decimals:
       *   1 becomes 2 (10 binary), -1 becomes 3 (11 binary)
       *   2 becomes 4 (100 binary), -2 becomes 5 (101 binary)
       */
      function toVLQSigned(aValue) {
        return aValue < 0
          ? ((-aValue) << 1) + 1
          : (aValue << 1) + 0;
      }
    
      /**
       * Converts to a two-complement value from a value where the sign bit is
       * is placed in the least significant bit.  For example, as decimals:
       *   2 (10 binary) becomes 1, 3 (11 binary) becomes -1
       *   4 (100 binary) becomes 2, 5 (101 binary) becomes -2
       */
      function fromVLQSigned(aValue) {
        var isNegative = (aValue & 1) === 1;
        var shifted = aValue >> 1;
        return isNegative
          ? -shifted
          : shifted;
      }
    
      /**
       * Returns the base 64 VLQ encoded value.
       */
      exports.encode = function base64VLQ_encode(aValue) {
        var encoded = "";
        var digit;
    
        var vlq = toVLQSigned(aValue);
    
        do {
          digit = vlq & VLQ_BASE_MASK;
          vlq >>>= VLQ_BASE_SHIFT;
          if (vlq > 0) {
            // There are still more digits in this value, so we must make sure the
            // continuation bit is marked.
            digit |= VLQ_CONTINUATION_BIT;
          }
          encoded += base64.encode(digit);
        } while (vlq > 0);
    
        return encoded;
      };
    
      /**
       * Decodes the next base 64 VLQ value from the given string and returns the
       * value and the rest of the string.
       */
      exports.decode = function base64VLQ_decode(aStr) {
        var i = 0;
        var strLen = aStr.length;
        var result = 0;
        var shift = 0;
        var continuation, digit;
    
        do {
          if (i >= strLen) {
            throw new Error("Expected more digits in base 64 VLQ value.");
          }
          digit = base64.decode(aStr.charAt(i++));
          continuation = !!(digit & VLQ_CONTINUATION_BIT);
          digit &= VLQ_BASE_MASK;
          result = result + (digit << shift);
          shift += VLQ_BASE_SHIFT;
        } while (continuation);
    
        return {
          value: fromVLQSigned(result),
          rest: aStr.slice(i)
        };
      };
    
    });
    
  provide("source-map/source-map/base64-vlq", module.exports);
}(global));

// pakmanager:source-map/source-map/array-set
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /* -*- Mode: js; js-indent-level: 2; -*- */
    /*
     * Copyright 2011 Mozilla Foundation and contributors
     * Licensed under the New BSD license. See LICENSE or:
     * http://opensource.org/licenses/BSD-3-Clause
     */
    if (typeof define !== 'function') {
        var define = require('amdefine')(module, require);
    }
    define(function (require, exports, module) {
    
      var util =  require('source-map/source-map/util');
    
      /**
       * A data structure which is a combination of an array and a set. Adding a new
       * member is O(1), testing for membership is O(1), and finding the index of an
       * element is O(1). Removing elements from the set is not supported. Only
       * strings are supported for membership.
       */
      function ArraySet() {
        this._array = [];
        this._set = {};
      }
    
      /**
       * Static method for creating ArraySet instances from an existing array.
       */
      ArraySet.fromArray = function ArraySet_fromArray(aArray, aAllowDuplicates) {
        var set = new ArraySet();
        for (var i = 0, len = aArray.length; i < len; i++) {
          set.add(aArray[i], aAllowDuplicates);
        }
        return set;
      };
    
      /**
       * Add the given string to this set.
       *
       * @param String aStr
       */
      ArraySet.prototype.add = function ArraySet_add(aStr, aAllowDuplicates) {
        var isDuplicate = this.has(aStr);
        var idx = this._array.length;
        if (!isDuplicate || aAllowDuplicates) {
          this._array.push(aStr);
        }
        if (!isDuplicate) {
          this._set[util.toSetString(aStr)] = idx;
        }
      };
    
      /**
       * Is the given string a member of this set?
       *
       * @param String aStr
       */
      ArraySet.prototype.has = function ArraySet_has(aStr) {
        return Object.prototype.hasOwnProperty.call(this._set,
                                                    util.toSetString(aStr));
      };
    
      /**
       * What is the index of the given string in the array?
       *
       * @param String aStr
       */
      ArraySet.prototype.indexOf = function ArraySet_indexOf(aStr) {
        if (this.has(aStr)) {
          return this._set[util.toSetString(aStr)];
        }
        throw new Error('"' + aStr + '" is not in the set.');
      };
    
      /**
       * What is the element at the given index?
       *
       * @param Number aIdx
       */
      ArraySet.prototype.at = function ArraySet_at(aIdx) {
        if (aIdx >= 0 && aIdx < this._array.length) {
          return this._array[aIdx];
        }
        throw new Error('No element indexed by ' + aIdx);
      };
    
      /**
       * Returns the array representation of this set (which has the proper indices
       * indicated by indexOf). Note that this is a copy of the internal array used
       * for storing the members so that no one can mess with internal state.
       */
      ArraySet.prototype.toArray = function ArraySet_toArray() {
        return this._array.slice();
      };
    
      exports.ArraySet = ArraySet;
    
    });
    
  provide("source-map/source-map/array-set", module.exports);
}(global));

// pakmanager:source-map/source-map/binary-search
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /* -*- Mode: js; js-indent-level: 2; -*- */
    /*
     * Copyright 2011 Mozilla Foundation and contributors
     * Licensed under the New BSD license. See LICENSE or:
     * http://opensource.org/licenses/BSD-3-Clause
     */
    if (typeof define !== 'function') {
        var define = require('amdefine')(module, require);
    }
    define(function (require, exports, module) {
    
      /**
       * Recursive implementation of binary search.
       *
       * @param aLow Indices here and lower do not contain the needle.
       * @param aHigh Indices here and higher do not contain the needle.
       * @param aNeedle The element being searched for.
       * @param aHaystack The non-empty array being searched.
       * @param aCompare Function which takes two elements and returns -1, 0, or 1.
       */
      function recursiveSearch(aLow, aHigh, aNeedle, aHaystack, aCompare) {
        // This function terminates when one of the following is true:
        //
        //   1. We find the exact element we are looking for.
        //
        //   2. We did not find the exact element, but we can return the next
        //      closest element that is less than that element.
        //
        //   3. We did not find the exact element, and there is no next-closest
        //      element which is less than the one we are searching for, so we
        //      return null.
        var mid = Math.floor((aHigh - aLow) / 2) + aLow;
        var cmp = aCompare(aNeedle, aHaystack[mid], true);
        if (cmp === 0) {
          // Found the element we are looking for.
          return aHaystack[mid];
        }
        else if (cmp > 0) {
          // aHaystack[mid] is greater than our needle.
          if (aHigh - mid > 1) {
            // The element is in the upper half.
            return recursiveSearch(mid, aHigh, aNeedle, aHaystack, aCompare);
          }
          // We did not find an exact match, return the next closest one
          // (termination case 2).
          return aHaystack[mid];
        }
        else {
          // aHaystack[mid] is less than our needle.
          if (mid - aLow > 1) {
            // The element is in the lower half.
            return recursiveSearch(aLow, mid, aNeedle, aHaystack, aCompare);
          }
          // The exact needle element was not found in this haystack. Determine if
          // we are in termination case (2) or (3) and return the appropriate thing.
          return aLow < 0
            ? null
            : aHaystack[aLow];
        }
      }
    
      /**
       * This is an implementation of binary search which will always try and return
       * the next lowest value checked if there is no exact hit. This is because
       * mappings between original and generated line/col pairs are single points,
       * and there is an implicit region between each of them, so a miss just means
       * that you aren't on the very start of a region.
       *
       * @param aNeedle The element you are looking for.
       * @param aHaystack The array that is being searched.
       * @param aCompare A function which takes the needle and an element in the
       *     array and returns -1, 0, or 1 depending on whether the needle is less
       *     than, equal to, or greater than the element, respectively.
       */
      exports.search = function search(aNeedle, aHaystack, aCompare) {
        return aHaystack.length > 0
          ? recursiveSearch(-1, aHaystack.length, aNeedle, aHaystack, aCompare)
          : null;
      };
    
    });
    
  provide("source-map/source-map/binary-search", module.exports);
}(global));

// pakmanager:source-map/source-map/source-map-generator
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /* -*- Mode: js; js-indent-level: 2; -*- */
    /*
     * Copyright 2011 Mozilla Foundation and contributors
     * Licensed under the New BSD license. See LICENSE or:
     * http://opensource.org/licenses/BSD-3-Clause
     */
    if (typeof define !== 'function') {
        var define = require('amdefine')(module, require);
    }
    define(function (require, exports, module) {
    
      var base64VLQ =  require('source-map/source-map/base64-vlq');
      var util =  require('source-map/source-map/util');
      var ArraySet =  require('source-map/source-map/array-set').ArraySet;
    
      /**
       * An instance of the SourceMapGenerator represents a source map which is
       * being built incrementally. To create a new one, you must pass an object
       * with the following properties:
       *
       *   - file: The filename of the generated source.
       *   - sourceRoot: An optional root for all URLs in this source map.
       */
      function SourceMapGenerator(aArgs) {
        this._file = util.getArg(aArgs, 'file');
        this._sourceRoot = util.getArg(aArgs, 'sourceRoot', null);
        this._sources = new ArraySet();
        this._names = new ArraySet();
        this._mappings = [];
        this._sourcesContents = null;
      }
    
      SourceMapGenerator.prototype._version = 3;
    
      /**
       * Creates a new SourceMapGenerator based on a SourceMapConsumer
       *
       * @param aSourceMapConsumer The SourceMap.
       */
      SourceMapGenerator.fromSourceMap =
        function SourceMapGenerator_fromSourceMap(aSourceMapConsumer) {
          var sourceRoot = aSourceMapConsumer.sourceRoot;
          var generator = new SourceMapGenerator({
            file: aSourceMapConsumer.file,
            sourceRoot: sourceRoot
          });
          aSourceMapConsumer.eachMapping(function (mapping) {
            var newMapping = {
              generated: {
                line: mapping.generatedLine,
                column: mapping.generatedColumn
              }
            };
    
            if (mapping.source) {
              newMapping.source = mapping.source;
              if (sourceRoot) {
                newMapping.source = util.relative(sourceRoot, newMapping.source);
              }
    
              newMapping.original = {
                line: mapping.originalLine,
                column: mapping.originalColumn
              };
    
              if (mapping.name) {
                newMapping.name = mapping.name;
              }
            }
    
            generator.addMapping(newMapping);
          });
          aSourceMapConsumer.sources.forEach(function (sourceFile) {
            var content = aSourceMapConsumer.sourceContentFor(sourceFile);
            if (content) {
              generator.setSourceContent(sourceFile, content);
            }
          });
          return generator;
        };
    
      /**
       * Add a single mapping from original source line and column to the generated
       * source's line and column for this source map being created. The mapping
       * object should have the following properties:
       *
       *   - generated: An object with the generated line and column positions.
       *   - original: An object with the original line and column positions.
       *   - source: The original source file (relative to the sourceRoot).
       *   - name: An optional original token name for this mapping.
       */
      SourceMapGenerator.prototype.addMapping =
        function SourceMapGenerator_addMapping(aArgs) {
          var generated = util.getArg(aArgs, 'generated');
          var original = util.getArg(aArgs, 'original', null);
          var source = util.getArg(aArgs, 'source', null);
          var name = util.getArg(aArgs, 'name', null);
    
          this._validateMapping(generated, original, source, name);
    
          if (source && !this._sources.has(source)) {
            this._sources.add(source);
          }
    
          if (name && !this._names.has(name)) {
            this._names.add(name);
          }
    
          this._mappings.push({
            generatedLine: generated.line,
            generatedColumn: generated.column,
            originalLine: original != null && original.line,
            originalColumn: original != null && original.column,
            source: source,
            name: name
          });
        };
    
      /**
       * Set the source content for a source file.
       */
      SourceMapGenerator.prototype.setSourceContent =
        function SourceMapGenerator_setSourceContent(aSourceFile, aSourceContent) {
          var source = aSourceFile;
          if (this._sourceRoot) {
            source = util.relative(this._sourceRoot, source);
          }
    
          if (aSourceContent !== null) {
            // Add the source content to the _sourcesContents map.
            // Create a new _sourcesContents map if the property is null.
            if (!this._sourcesContents) {
              this._sourcesContents = {};
            }
            this._sourcesContents[util.toSetString(source)] = aSourceContent;
          } else {
            // Remove the source file from the _sourcesContents map.
            // If the _sourcesContents map is empty, set the property to null.
            delete this._sourcesContents[util.toSetString(source)];
            if (Object.keys(this._sourcesContents).length === 0) {
              this._sourcesContents = null;
            }
          }
        };
    
      /**
       * Applies the mappings of a sub-source-map for a specific source file to the
       * source map being generated. Each mapping to the supplied source file is
       * rewritten using the supplied source map. Note: The resolution for the
       * resulting mappings is the minimium of this map and the supplied map.
       *
       * @param aSourceMapConsumer The source map to be applied.
       * @param aSourceFile Optional. The filename of the source file.
       *        If omitted, SourceMapConsumer's file property will be used.
       */
      SourceMapGenerator.prototype.applySourceMap =
        function SourceMapGenerator_applySourceMap(aSourceMapConsumer, aSourceFile) {
          // If aSourceFile is omitted, we will use the file property of the SourceMap
          if (!aSourceFile) {
            aSourceFile = aSourceMapConsumer.file;
          }
          var sourceRoot = this._sourceRoot;
          // Make "aSourceFile" relative if an absolute Url is passed.
          if (sourceRoot) {
            aSourceFile = util.relative(sourceRoot, aSourceFile);
          }
          // Applying the SourceMap can add and remove items from the sources and
          // the names array.
          var newSources = new ArraySet();
          var newNames = new ArraySet();
    
          // Find mappings for the "aSourceFile"
          this._mappings.forEach(function (mapping) {
            if (mapping.source === aSourceFile && mapping.originalLine) {
              // Check if it can be mapped by the source map, then update the mapping.
              var original = aSourceMapConsumer.originalPositionFor({
                line: mapping.originalLine,
                column: mapping.originalColumn
              });
              if (original.source !== null) {
                // Copy mapping
                if (sourceRoot) {
                  mapping.source = util.relative(sourceRoot, original.source);
                } else {
                  mapping.source = original.source;
                }
                mapping.originalLine = original.line;
                mapping.originalColumn = original.column;
                if (original.name !== null && mapping.name !== null) {
                  // Only use the identifier name if it's an identifier
                  // in both SourceMaps
                  mapping.name = original.name;
                }
              }
            }
    
            var source = mapping.source;
            if (source && !newSources.has(source)) {
              newSources.add(source);
            }
    
            var name = mapping.name;
            if (name && !newNames.has(name)) {
              newNames.add(name);
            }
    
          }, this);
          this._sources = newSources;
          this._names = newNames;
    
          // Copy sourcesContents of applied map.
          aSourceMapConsumer.sources.forEach(function (sourceFile) {
            var content = aSourceMapConsumer.sourceContentFor(sourceFile);
            if (content) {
              if (sourceRoot) {
                sourceFile = util.relative(sourceRoot, sourceFile);
              }
              this.setSourceContent(sourceFile, content);
            }
          }, this);
        };
    
      /**
       * A mapping can have one of the three levels of data:
       *
       *   1. Just the generated position.
       *   2. The Generated position, original position, and original source.
       *   3. Generated and original position, original source, as well as a name
       *      token.
       *
       * To maintain consistency, we validate that any new mapping being added falls
       * in to one of these categories.
       */
      SourceMapGenerator.prototype._validateMapping =
        function SourceMapGenerator_validateMapping(aGenerated, aOriginal, aSource,
                                                    aName) {
          if (aGenerated && 'line' in aGenerated && 'column' in aGenerated
              && aGenerated.line > 0 && aGenerated.column >= 0
              && !aOriginal && !aSource && !aName) {
            // Case 1.
            return;
          }
          else if (aGenerated && 'line' in aGenerated && 'column' in aGenerated
                   && aOriginal && 'line' in aOriginal && 'column' in aOriginal
                   && aGenerated.line > 0 && aGenerated.column >= 0
                   && aOriginal.line > 0 && aOriginal.column >= 0
                   && aSource) {
            // Cases 2 and 3.
            return;
          }
          else {
            throw new Error('Invalid mapping: ' + JSON.stringify({
              generated: aGenerated,
              source: aSource,
              orginal: aOriginal,
              name: aName
            }));
          }
        };
    
      /**
       * Serialize the accumulated mappings in to the stream of base 64 VLQs
       * specified by the source map format.
       */
      SourceMapGenerator.prototype._serializeMappings =
        function SourceMapGenerator_serializeMappings() {
          var previousGeneratedColumn = 0;
          var previousGeneratedLine = 1;
          var previousOriginalColumn = 0;
          var previousOriginalLine = 0;
          var previousName = 0;
          var previousSource = 0;
          var result = '';
          var mapping;
    
          // The mappings must be guaranteed to be in sorted order before we start
          // serializing them or else the generated line numbers (which are defined
          // via the ';' separators) will be all messed up. Note: it might be more
          // performant to maintain the sorting as we insert them, rather than as we
          // serialize them, but the big O is the same either way.
          this._mappings.sort(util.compareByGeneratedPositions);
    
          for (var i = 0, len = this._mappings.length; i < len; i++) {
            mapping = this._mappings[i];
    
            if (mapping.generatedLine !== previousGeneratedLine) {
              previousGeneratedColumn = 0;
              while (mapping.generatedLine !== previousGeneratedLine) {
                result += ';';
                previousGeneratedLine++;
              }
            }
            else {
              if (i > 0) {
                if (!util.compareByGeneratedPositions(mapping, this._mappings[i - 1])) {
                  continue;
                }
                result += ',';
              }
            }
    
            result += base64VLQ.encode(mapping.generatedColumn
                                       - previousGeneratedColumn);
            previousGeneratedColumn = mapping.generatedColumn;
    
            if (mapping.source) {
              result += base64VLQ.encode(this._sources.indexOf(mapping.source)
                                         - previousSource);
              previousSource = this._sources.indexOf(mapping.source);
    
              // lines are stored 0-based in SourceMap spec version 3
              result += base64VLQ.encode(mapping.originalLine - 1
                                         - previousOriginalLine);
              previousOriginalLine = mapping.originalLine - 1;
    
              result += base64VLQ.encode(mapping.originalColumn
                                         - previousOriginalColumn);
              previousOriginalColumn = mapping.originalColumn;
    
              if (mapping.name) {
                result += base64VLQ.encode(this._names.indexOf(mapping.name)
                                           - previousName);
                previousName = this._names.indexOf(mapping.name);
              }
            }
          }
    
          return result;
        };
    
      SourceMapGenerator.prototype._generateSourcesContent =
        function SourceMapGenerator_generateSourcesContent(aSources, aSourceRoot) {
          return aSources.map(function (source) {
            if (!this._sourcesContents) {
              return null;
            }
            if (aSourceRoot) {
              source = util.relative(aSourceRoot, source);
            }
            var key = util.toSetString(source);
            return Object.prototype.hasOwnProperty.call(this._sourcesContents,
                                                        key)
              ? this._sourcesContents[key]
              : null;
          }, this);
        };
    
      /**
       * Externalize the source map.
       */
      SourceMapGenerator.prototype.toJSON =
        function SourceMapGenerator_toJSON() {
          var map = {
            version: this._version,
            file: this._file,
            sources: this._sources.toArray(),
            names: this._names.toArray(),
            mappings: this._serializeMappings()
          };
          if (this._sourceRoot) {
            map.sourceRoot = this._sourceRoot;
          }
          if (this._sourcesContents) {
            map.sourcesContent = this._generateSourcesContent(map.sources, map.sourceRoot);
          }
    
          return map;
        };
    
      /**
       * Render the source map being generated to a string.
       */
      SourceMapGenerator.prototype.toString =
        function SourceMapGenerator_toString() {
          return JSON.stringify(this);
        };
    
      exports.SourceMapGenerator = SourceMapGenerator;
    
    });
    
  provide("source-map/source-map/source-map-generator", module.exports);
}(global));

// pakmanager:source-map/source-map/source-map-consumer
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /* -*- Mode: js; js-indent-level: 2; -*- */
    /*
     * Copyright 2011 Mozilla Foundation and contributors
     * Licensed under the New BSD license. See LICENSE or:
     * http://opensource.org/licenses/BSD-3-Clause
     */
    if (typeof define !== 'function') {
        var define = require('amdefine')(module, require);
    }
    define(function (require, exports, module) {
    
      var util =  require('source-map/source-map/util');
      var binarySearch =  require('source-map/source-map/binary-search');
      var ArraySet =  require('source-map/source-map/array-set').ArraySet;
      var base64VLQ =  require('source-map/source-map/base64-vlq');
    
      /**
       * A SourceMapConsumer instance represents a parsed source map which we can
       * query for information about the original file positions by giving it a file
       * position in the generated source.
       *
       * The only parameter is the raw source map (either as a JSON string, or
       * already parsed to an object). According to the spec, source maps have the
       * following attributes:
       *
       *   - version: Which version of the source map spec this map is following.
       *   - sources: An array of URLs to the original source files.
       *   - names: An array of identifiers which can be referrenced by individual mappings.
       *   - sourceRoot: Optional. The URL root from which all sources are relative.
       *   - sourcesContent: Optional. An array of contents of the original source files.
       *   - mappings: A string of base64 VLQs which contain the actual mappings.
       *   - file: The generated file this source map is associated with.
       *
       * Here is an example source map, taken from the source map spec[0]:
       *
       *     {
       *       version : 3,
       *       file: "out.js",
       *       sourceRoot : "",
       *       sources: ["foo.js", "bar.js"],
       *       names: ["src", "maps", "are", "fun"],
       *       mappings: "AA,AB;;ABCDE;"
       *     }
       *
       * [0]: https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit?pli=1#
       */
      function SourceMapConsumer(aSourceMap) {
        var sourceMap = aSourceMap;
        if (typeof aSourceMap === 'string') {
          sourceMap = JSON.parse(aSourceMap.replace(/^\)\]\}'/, ''));
        }
    
        var version = util.getArg(sourceMap, 'version');
        var sources = util.getArg(sourceMap, 'sources');
        // Sass 3.3 leaves out the 'names' array, so we deviate from the spec (which
        // requires the array) to play nice here.
        var names = util.getArg(sourceMap, 'names', []);
        var sourceRoot = util.getArg(sourceMap, 'sourceRoot', null);
        var sourcesContent = util.getArg(sourceMap, 'sourcesContent', null);
        var mappings = util.getArg(sourceMap, 'mappings');
        var file = util.getArg(sourceMap, 'file', null);
    
        // Once again, Sass deviates from the spec and supplies the version as a
        // string rather than a number, so we use loose equality checking here.
        if (version != this._version) {
          throw new Error('Unsupported version: ' + version);
        }
    
        // Pass `true` below to allow duplicate names and sources. While source maps
        // are intended to be compressed and deduplicated, the TypeScript compiler
        // sometimes generates source maps with duplicates in them. See Github issue
        // #72 and bugzil.la/889492.
        this._names = ArraySet.fromArray(names, true);
        this._sources = ArraySet.fromArray(sources, true);
    
        this.sourceRoot = sourceRoot;
        this.sourcesContent = sourcesContent;
        this._mappings = mappings;
        this.file = file;
      }
    
      /**
       * Create a SourceMapConsumer from a SourceMapGenerator.
       *
       * @param SourceMapGenerator aSourceMap
       *        The source map that will be consumed.
       * @returns SourceMapConsumer
       */
      SourceMapConsumer.fromSourceMap =
        function SourceMapConsumer_fromSourceMap(aSourceMap) {
          var smc = Object.create(SourceMapConsumer.prototype);
    
          smc._names = ArraySet.fromArray(aSourceMap._names.toArray(), true);
          smc._sources = ArraySet.fromArray(aSourceMap._sources.toArray(), true);
          smc.sourceRoot = aSourceMap._sourceRoot;
          smc.sourcesContent = aSourceMap._generateSourcesContent(smc._sources.toArray(),
                                                                  smc.sourceRoot);
          smc.file = aSourceMap._file;
    
          smc.__generatedMappings = aSourceMap._mappings.slice()
            .sort(util.compareByGeneratedPositions);
          smc.__originalMappings = aSourceMap._mappings.slice()
            .sort(util.compareByOriginalPositions);
    
          return smc;
        };
    
      /**
       * The version of the source mapping spec that we are consuming.
       */
      SourceMapConsumer.prototype._version = 3;
    
      /**
       * The list of original sources.
       */
      Object.defineProperty(SourceMapConsumer.prototype, 'sources', {
        get: function () {
          return this._sources.toArray().map(function (s) {
            return this.sourceRoot ? util.join(this.sourceRoot, s) : s;
          }, this);
        }
      });
    
      // `__generatedMappings` and `__originalMappings` are arrays that hold the
      // parsed mapping coordinates from the source map's "mappings" attribute. They
      // are lazily instantiated, accessed via the `_generatedMappings` and
      // `_originalMappings` getters respectively, and we only parse the mappings
      // and create these arrays once queried for a source location. We jump through
      // these hoops because there can be many thousands of mappings, and parsing
      // them is expensive, so we only want to do it if we must.
      //
      // Each object in the arrays is of the form:
      //
      //     {
      //       generatedLine: The line number in the generated code,
      //       generatedColumn: The column number in the generated code,
      //       source: The path to the original source file that generated this
      //               chunk of code,
      //       originalLine: The line number in the original source that
      //                     corresponds to this chunk of generated code,
      //       originalColumn: The column number in the original source that
      //                       corresponds to this chunk of generated code,
      //       name: The name of the original symbol which generated this chunk of
      //             code.
      //     }
      //
      // All properties except for `generatedLine` and `generatedColumn` can be
      // `null`.
      //
      // `_generatedMappings` is ordered by the generated positions.
      //
      // `_originalMappings` is ordered by the original positions.
    
      SourceMapConsumer.prototype.__generatedMappings = null;
      Object.defineProperty(SourceMapConsumer.prototype, '_generatedMappings', {
        get: function () {
          if (!this.__generatedMappings) {
            this.__generatedMappings = [];
            this.__originalMappings = [];
            this._parseMappings(this._mappings, this.sourceRoot);
          }
    
          return this.__generatedMappings;
        }
      });
    
      SourceMapConsumer.prototype.__originalMappings = null;
      Object.defineProperty(SourceMapConsumer.prototype, '_originalMappings', {
        get: function () {
          if (!this.__originalMappings) {
            this.__generatedMappings = [];
            this.__originalMappings = [];
            this._parseMappings(this._mappings, this.sourceRoot);
          }
    
          return this.__originalMappings;
        }
      });
    
      /**
       * Parse the mappings in a string in to a data structure which we can easily
       * query (the ordered arrays in the `this.__generatedMappings` and
       * `this.__originalMappings` properties).
       */
      SourceMapConsumer.prototype._parseMappings =
        function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {
          var generatedLine = 1;
          var previousGeneratedColumn = 0;
          var previousOriginalLine = 0;
          var previousOriginalColumn = 0;
          var previousSource = 0;
          var previousName = 0;
          var mappingSeparator = /^[,;]/;
          var str = aStr;
          var mapping;
          var temp;
    
          while (str.length > 0) {
            if (str.charAt(0) === ';') {
              generatedLine++;
              str = str.slice(1);
              previousGeneratedColumn = 0;
            }
            else if (str.charAt(0) === ',') {
              str = str.slice(1);
            }
            else {
              mapping = {};
              mapping.generatedLine = generatedLine;
    
              // Generated column.
              temp = base64VLQ.decode(str);
              mapping.generatedColumn = previousGeneratedColumn + temp.value;
              previousGeneratedColumn = mapping.generatedColumn;
              str = temp.rest;
    
              if (str.length > 0 && !mappingSeparator.test(str.charAt(0))) {
                // Original source.
                temp = base64VLQ.decode(str);
                mapping.source = this._sources.at(previousSource + temp.value);
                previousSource += temp.value;
                str = temp.rest;
                if (str.length === 0 || mappingSeparator.test(str.charAt(0))) {
                  throw new Error('Found a source, but no line and column');
                }
    
                // Original line.
                temp = base64VLQ.decode(str);
                mapping.originalLine = previousOriginalLine + temp.value;
                previousOriginalLine = mapping.originalLine;
                // Lines are stored 0-based
                mapping.originalLine += 1;
                str = temp.rest;
                if (str.length === 0 || mappingSeparator.test(str.charAt(0))) {
                  throw new Error('Found a source and line, but no column');
                }
    
                // Original column.
                temp = base64VLQ.decode(str);
                mapping.originalColumn = previousOriginalColumn + temp.value;
                previousOriginalColumn = mapping.originalColumn;
                str = temp.rest;
    
                if (str.length > 0 && !mappingSeparator.test(str.charAt(0))) {
                  // Original name.
                  temp = base64VLQ.decode(str);
                  mapping.name = this._names.at(previousName + temp.value);
                  previousName += temp.value;
                  str = temp.rest;
                }
              }
    
              this.__generatedMappings.push(mapping);
              if (typeof mapping.originalLine === 'number') {
                this.__originalMappings.push(mapping);
              }
            }
          }
    
          this.__originalMappings.sort(util.compareByOriginalPositions);
        };
    
      /**
       * Find the mapping that best matches the hypothetical "needle" mapping that
       * we are searching for in the given "haystack" of mappings.
       */
      SourceMapConsumer.prototype._findMapping =
        function SourceMapConsumer_findMapping(aNeedle, aMappings, aLineName,
                                               aColumnName, aComparator) {
          // To return the position we are searching for, we must first find the
          // mapping for the given position and then return the opposite position it
          // points to. Because the mappings are sorted, we can use binary search to
          // find the best mapping.
    
          if (aNeedle[aLineName] <= 0) {
            throw new TypeError('Line must be greater than or equal to 1, got '
                                + aNeedle[aLineName]);
          }
          if (aNeedle[aColumnName] < 0) {
            throw new TypeError('Column must be greater than or equal to 0, got '
                                + aNeedle[aColumnName]);
          }
    
          return binarySearch.search(aNeedle, aMappings, aComparator);
        };
    
      /**
       * Returns the original source, line, and column information for the generated
       * source's line and column positions provided. The only argument is an object
       * with the following properties:
       *
       *   - line: The line number in the generated source.
       *   - column: The column number in the generated source.
       *
       * and an object is returned with the following properties:
       *
       *   - source: The original source file, or null.
       *   - line: The line number in the original source, or null.
       *   - column: The column number in the original source, or null.
       *   - name: The original identifier, or null.
       */
      SourceMapConsumer.prototype.originalPositionFor =
        function SourceMapConsumer_originalPositionFor(aArgs) {
          var needle = {
            generatedLine: util.getArg(aArgs, 'line'),
            generatedColumn: util.getArg(aArgs, 'column')
          };
    
          var mapping = this._findMapping(needle,
                                          this._generatedMappings,
                                          "generatedLine",
                                          "generatedColumn",
                                          util.compareByGeneratedPositions);
    
          if (mapping) {
            var source = util.getArg(mapping, 'source', null);
            if (source && this.sourceRoot) {
              source = util.join(this.sourceRoot, source);
            }
            return {
              source: source,
              line: util.getArg(mapping, 'originalLine', null),
              column: util.getArg(mapping, 'originalColumn', null),
              name: util.getArg(mapping, 'name', null)
            };
          }
    
          return {
            source: null,
            line: null,
            column: null,
            name: null
          };
        };
    
      /**
       * Returns the original source content. The only argument is the url of the
       * original source file. Returns null if no original source content is
       * availible.
       */
      SourceMapConsumer.prototype.sourceContentFor =
        function SourceMapConsumer_sourceContentFor(aSource) {
          if (!this.sourcesContent) {
            return null;
          }
    
          if (this.sourceRoot) {
            aSource = util.relative(this.sourceRoot, aSource);
          }
    
          if (this._sources.has(aSource)) {
            return this.sourcesContent[this._sources.indexOf(aSource)];
          }
    
          var url;
          if (this.sourceRoot
              && (url = util.urlParse(this.sourceRoot))) {
            // XXX: file:// URIs and absolute paths lead to unexpected behavior for
            // many users. We can help them out when they expect file:// URIs to
            // behave like it would if they were running a local HTTP server. See
            // https://bugzilla.mozilla.org/show_bug.cgi?id=885597.
            var fileUriAbsPath = aSource.replace(/^file:\/\//, "");
            if (url.scheme == "file"
                && this._sources.has(fileUriAbsPath)) {
              return this.sourcesContent[this._sources.indexOf(fileUriAbsPath)]
            }
    
            if ((!url.path || url.path == "/")
                && this._sources.has("/" + aSource)) {
              return this.sourcesContent[this._sources.indexOf("/" + aSource)];
            }
          }
    
          throw new Error('"' + aSource + '" is not in the SourceMap.');
        };
    
      /**
       * Returns the generated line and column information for the original source,
       * line, and column positions provided. The only argument is an object with
       * the following properties:
       *
       *   - source: The filename of the original source.
       *   - line: The line number in the original source.
       *   - column: The column number in the original source.
       *
       * and an object is returned with the following properties:
       *
       *   - line: The line number in the generated source, or null.
       *   - column: The column number in the generated source, or null.
       */
      SourceMapConsumer.prototype.generatedPositionFor =
        function SourceMapConsumer_generatedPositionFor(aArgs) {
          var needle = {
            source: util.getArg(aArgs, 'source'),
            originalLine: util.getArg(aArgs, 'line'),
            originalColumn: util.getArg(aArgs, 'column')
          };
    
          if (this.sourceRoot) {
            needle.source = util.relative(this.sourceRoot, needle.source);
          }
    
          var mapping = this._findMapping(needle,
                                          this._originalMappings,
                                          "originalLine",
                                          "originalColumn",
                                          util.compareByOriginalPositions);
    
          if (mapping) {
            return {
              line: util.getArg(mapping, 'generatedLine', null),
              column: util.getArg(mapping, 'generatedColumn', null)
            };
          }
    
          return {
            line: null,
            column: null
          };
        };
    
      SourceMapConsumer.GENERATED_ORDER = 1;
      SourceMapConsumer.ORIGINAL_ORDER = 2;
    
      /**
       * Iterate over each mapping between an original source/line/column and a
       * generated line/column in this source map.
       *
       * @param Function aCallback
       *        The function that is called with each mapping.
       * @param Object aContext
       *        Optional. If specified, this object will be the value of `this` every
       *        time that `aCallback` is called.
       * @param aOrder
       *        Either `SourceMapConsumer.GENERATED_ORDER` or
       *        `SourceMapConsumer.ORIGINAL_ORDER`. Specifies whether you want to
       *        iterate over the mappings sorted by the generated file's line/column
       *        order or the original's source/line/column order, respectively. Defaults to
       *        `SourceMapConsumer.GENERATED_ORDER`.
       */
      SourceMapConsumer.prototype.eachMapping =
        function SourceMapConsumer_eachMapping(aCallback, aContext, aOrder) {
          var context = aContext || null;
          var order = aOrder || SourceMapConsumer.GENERATED_ORDER;
    
          var mappings;
          switch (order) {
          case SourceMapConsumer.GENERATED_ORDER:
            mappings = this._generatedMappings;
            break;
          case SourceMapConsumer.ORIGINAL_ORDER:
            mappings = this._originalMappings;
            break;
          default:
            throw new Error("Unknown order of iteration.");
          }
    
          var sourceRoot = this.sourceRoot;
          mappings.map(function (mapping) {
            var source = mapping.source;
            if (source && sourceRoot) {
              source = util.join(sourceRoot, source);
            }
            return {
              source: source,
              generatedLine: mapping.generatedLine,
              generatedColumn: mapping.generatedColumn,
              originalLine: mapping.originalLine,
              originalColumn: mapping.originalColumn,
              name: mapping.name
            };
          }).forEach(aCallback, context);
        };
    
      exports.SourceMapConsumer = SourceMapConsumer;
    
    });
    
  provide("source-map/source-map/source-map-consumer", module.exports);
}(global));

// pakmanager:source-map/source-map/source-node
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /* -*- Mode: js; js-indent-level: 2; -*- */
    /*
     * Copyright 2011 Mozilla Foundation and contributors
     * Licensed under the New BSD license. See LICENSE or:
     * http://opensource.org/licenses/BSD-3-Clause
     */
    if (typeof define !== 'function') {
        var define = require('amdefine')(module, require);
    }
    define(function (require, exports, module) {
    
      var SourceMapGenerator =  require('source-map/source-map/source-map-generator').SourceMapGenerator;
      var util =  require('source-map/source-map/util');
    
      /**
       * SourceNodes provide a way to abstract over interpolating/concatenating
       * snippets of generated JavaScript source code while maintaining the line and
       * column information associated with the original source code.
       *
       * @param aLine The original line number.
       * @param aColumn The original column number.
       * @param aSource The original source's filename.
       * @param aChunks Optional. An array of strings which are snippets of
       *        generated JS, or other SourceNodes.
       * @param aName The original identifier.
       */
      function SourceNode(aLine, aColumn, aSource, aChunks, aName) {
        this.children = [];
        this.sourceContents = {};
        this.line = aLine === undefined ? null : aLine;
        this.column = aColumn === undefined ? null : aColumn;
        this.source = aSource === undefined ? null : aSource;
        this.name = aName === undefined ? null : aName;
        if (aChunks != null) this.add(aChunks);
      }
    
      /**
       * Creates a SourceNode from generated code and a SourceMapConsumer.
       *
       * @param aGeneratedCode The generated code
       * @param aSourceMapConsumer The SourceMap for the generated code
       */
      SourceNode.fromStringWithSourceMap =
        function SourceNode_fromStringWithSourceMap(aGeneratedCode, aSourceMapConsumer) {
          // The SourceNode we want to fill with the generated code
          // and the SourceMap
          var node = new SourceNode();
    
          // The generated code
          // Processed fragments are removed from this array.
          var remainingLines = aGeneratedCode.split('\n');
    
          // We need to remember the position of "remainingLines"
          var lastGeneratedLine = 1, lastGeneratedColumn = 0;
    
          // The generate SourceNodes we need a code range.
          // To extract it current and last mapping is used.
          // Here we store the last mapping.
          var lastMapping = null;
    
          aSourceMapConsumer.eachMapping(function (mapping) {
            if (lastMapping === null) {
              // We add the generated code until the first mapping
              // to the SourceNode without any mapping.
              // Each line is added as separate string.
              while (lastGeneratedLine < mapping.generatedLine) {
                node.add(remainingLines.shift() + "\n");
                lastGeneratedLine++;
              }
              if (lastGeneratedColumn < mapping.generatedColumn) {
                var nextLine = remainingLines[0];
                node.add(nextLine.substr(0, mapping.generatedColumn));
                remainingLines[0] = nextLine.substr(mapping.generatedColumn);
                lastGeneratedColumn = mapping.generatedColumn;
              }
            } else {
              // We add the code from "lastMapping" to "mapping":
              // First check if there is a new line in between.
              if (lastGeneratedLine < mapping.generatedLine) {
                var code = "";
                // Associate full lines with "lastMapping"
                do {
                  code += remainingLines.shift() + "\n";
                  lastGeneratedLine++;
                  lastGeneratedColumn = 0;
                } while (lastGeneratedLine < mapping.generatedLine);
                // When we reached the correct line, we add code until we
                // reach the correct column too.
                if (lastGeneratedColumn < mapping.generatedColumn) {
                  var nextLine = remainingLines[0];
                  code += nextLine.substr(0, mapping.generatedColumn);
                  remainingLines[0] = nextLine.substr(mapping.generatedColumn);
                  lastGeneratedColumn = mapping.generatedColumn;
                }
                // Create the SourceNode.
                addMappingWithCode(lastMapping, code);
              } else {
                // There is no new line in between.
                // Associate the code between "lastGeneratedColumn" and
                // "mapping.generatedColumn" with "lastMapping"
                var nextLine = remainingLines[0];
                var code = nextLine.substr(0, mapping.generatedColumn -
                                              lastGeneratedColumn);
                remainingLines[0] = nextLine.substr(mapping.generatedColumn -
                                                    lastGeneratedColumn);
                lastGeneratedColumn = mapping.generatedColumn;
                addMappingWithCode(lastMapping, code);
              }
            }
            lastMapping = mapping;
          }, this);
          // We have processed all mappings.
          // Associate the remaining code in the current line with "lastMapping"
          // and add the remaining lines without any mapping
          addMappingWithCode(lastMapping, remainingLines.join("\n"));
    
          // Copy sourcesContent into SourceNode
          aSourceMapConsumer.sources.forEach(function (sourceFile) {
            var content = aSourceMapConsumer.sourceContentFor(sourceFile);
            if (content) {
              node.setSourceContent(sourceFile, content);
            }
          });
    
          return node;
    
          function addMappingWithCode(mapping, code) {
            if (mapping === null || mapping.source === undefined) {
              node.add(code);
            } else {
              node.add(new SourceNode(mapping.originalLine,
                                      mapping.originalColumn,
                                      mapping.source,
                                      code,
                                      mapping.name));
            }
          }
        };
    
      /**
       * Add a chunk of generated JS to this source node.
       *
       * @param aChunk A string snippet of generated JS code, another instance of
       *        SourceNode, or an array where each member is one of those things.
       */
      SourceNode.prototype.add = function SourceNode_add(aChunk) {
        if (Array.isArray(aChunk)) {
          aChunk.forEach(function (chunk) {
            this.add(chunk);
          }, this);
        }
        else if (aChunk instanceof SourceNode || typeof aChunk === "string") {
          if (aChunk) {
            this.children.push(aChunk);
          }
        }
        else {
          throw new TypeError(
            "Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk
          );
        }
        return this;
      };
    
      /**
       * Add a chunk of generated JS to the beginning of this source node.
       *
       * @param aChunk A string snippet of generated JS code, another instance of
       *        SourceNode, or an array where each member is one of those things.
       */
      SourceNode.prototype.prepend = function SourceNode_prepend(aChunk) {
        if (Array.isArray(aChunk)) {
          for (var i = aChunk.length-1; i >= 0; i--) {
            this.prepend(aChunk[i]);
          }
        }
        else if (aChunk instanceof SourceNode || typeof aChunk === "string") {
          this.children.unshift(aChunk);
        }
        else {
          throw new TypeError(
            "Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk
          );
        }
        return this;
      };
    
      /**
       * Walk over the tree of JS snippets in this node and its children. The
       * walking function is called once for each snippet of JS and is passed that
       * snippet and the its original associated source's line/column location.
       *
       * @param aFn The traversal function.
       */
      SourceNode.prototype.walk = function SourceNode_walk(aFn) {
        var chunk;
        for (var i = 0, len = this.children.length; i < len; i++) {
          chunk = this.children[i];
          if (chunk instanceof SourceNode) {
            chunk.walk(aFn);
          }
          else {
            if (chunk !== '') {
              aFn(chunk, { source: this.source,
                           line: this.line,
                           column: this.column,
                           name: this.name });
            }
          }
        }
      };
    
      /**
       * Like `String.prototype.join` except for SourceNodes. Inserts `aStr` between
       * each of `this.children`.
       *
       * @param aSep The separator.
       */
      SourceNode.prototype.join = function SourceNode_join(aSep) {
        var newChildren;
        var i;
        var len = this.children.length;
        if (len > 0) {
          newChildren = [];
          for (i = 0; i < len-1; i++) {
            newChildren.push(this.children[i]);
            newChildren.push(aSep);
          }
          newChildren.push(this.children[i]);
          this.children = newChildren;
        }
        return this;
      };
    
      /**
       * Call String.prototype.replace on the very right-most source snippet. Useful
       * for trimming whitespace from the end of a source node, etc.
       *
       * @param aPattern The pattern to replace.
       * @param aReplacement The thing to replace the pattern with.
       */
      SourceNode.prototype.replaceRight = function SourceNode_replaceRight(aPattern, aReplacement) {
        var lastChild = this.children[this.children.length - 1];
        if (lastChild instanceof SourceNode) {
          lastChild.replaceRight(aPattern, aReplacement);
        }
        else if (typeof lastChild === 'string') {
          this.children[this.children.length - 1] = lastChild.replace(aPattern, aReplacement);
        }
        else {
          this.children.push(''.replace(aPattern, aReplacement));
        }
        return this;
      };
    
      /**
       * Set the source content for a source file. This will be added to the SourceMapGenerator
       * in the sourcesContent field.
       *
       * @param aSourceFile The filename of the source file
       * @param aSourceContent The content of the source file
       */
      SourceNode.prototype.setSourceContent =
        function SourceNode_setSourceContent(aSourceFile, aSourceContent) {
          this.sourceContents[util.toSetString(aSourceFile)] = aSourceContent;
        };
    
      /**
       * Walk over the tree of SourceNodes. The walking function is called for each
       * source file content and is passed the filename and source content.
       *
       * @param aFn The traversal function.
       */
      SourceNode.prototype.walkSourceContents =
        function SourceNode_walkSourceContents(aFn) {
          for (var i = 0, len = this.children.length; i < len; i++) {
            if (this.children[i] instanceof SourceNode) {
              this.children[i].walkSourceContents(aFn);
            }
          }
    
          var sources = Object.keys(this.sourceContents);
          for (var i = 0, len = sources.length; i < len; i++) {
            aFn(util.fromSetString(sources[i]), this.sourceContents[sources[i]]);
          }
        };
    
      /**
       * Return the string representation of this source node. Walks over the tree
       * and concatenates all the various snippets together to one string.
       */
      SourceNode.prototype.toString = function SourceNode_toString() {
        var str = "";
        this.walk(function (chunk) {
          str += chunk;
        });
        return str;
      };
    
      /**
       * Returns the string representation of this source node along with a source
       * map.
       */
      SourceNode.prototype.toStringWithSourceMap = function SourceNode_toStringWithSourceMap(aArgs) {
        var generated = {
          code: "",
          line: 1,
          column: 0
        };
        var map = new SourceMapGenerator(aArgs);
        var sourceMappingActive = false;
        var lastOriginalSource = null;
        var lastOriginalLine = null;
        var lastOriginalColumn = null;
        var lastOriginalName = null;
        this.walk(function (chunk, original) {
          generated.code += chunk;
          if (original.source !== null
              && original.line !== null
              && original.column !== null) {
            if(lastOriginalSource !== original.source
               || lastOriginalLine !== original.line
               || lastOriginalColumn !== original.column
               || lastOriginalName !== original.name) {
              map.addMapping({
                source: original.source,
                original: {
                  line: original.line,
                  column: original.column
                },
                generated: {
                  line: generated.line,
                  column: generated.column
                },
                name: original.name
              });
            }
            lastOriginalSource = original.source;
            lastOriginalLine = original.line;
            lastOriginalColumn = original.column;
            lastOriginalName = original.name;
            sourceMappingActive = true;
          } else if (sourceMappingActive) {
            map.addMapping({
              generated: {
                line: generated.line,
                column: generated.column
              }
            });
            lastOriginalSource = null;
            sourceMappingActive = false;
          }
          chunk.split('').forEach(function (ch) {
            if (ch === '\n') {
              generated.line++;
              generated.column = 0;
            } else {
              generated.column++;
            }
          });
        });
        this.walkSourceContents(function (sourceFile, sourceContent) {
          map.setSourceContent(sourceFile, sourceContent);
        });
    
        return { code: generated.code, map: map };
      };
    
      exports.SourceNode = SourceNode;
    
    });
    
  provide("source-map/source-map/source-node", module.exports);
}(global));

// pakmanager:source-map
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /*
     * Copyright 2009-2011 Mozilla Foundation and contributors
     * Licensed under the New BSD license. See LICENSE.txt or:
     * http://opensource.org/licenses/BSD-3-Clause
     */
    exports.SourceMapGenerator =  require('source-map/source-map/source-map-generator').SourceMapGenerator;
    exports.SourceMapConsumer =  require('source-map/source-map/source-map-consumer').SourceMapConsumer;
    exports.SourceNode =  require('source-map/source-map/source-node').SourceNode;
    
  provide("source-map", module.exports);
}(global));

// pakmanager:jstransform/src/docblock
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /**
     * Copyright 2013 Facebook, Inc.
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    
    var docblockRe = /^\s*(\/\*\*(.|\r?\n)*?\*\/)/;
    var ltrimRe = /^\s*/;
    /**
     * @param {String} contents
     * @return {String}
     */
    function extract(contents) {
      var match = contents.match(docblockRe);
      if (match) {
        return match[0].replace(ltrimRe, '') || '';
      }
      return '';
    }
    
    
    var commentStartRe = /^\/\*\*?/;
    var commentEndRe = /\*+\/$/;
    var wsRe = /[\t ]+/g;
    var stringStartRe = /(\r?\n|^) *\*/g;
    var multilineRe = /(?:^|\r?\n) *(@[^\r\n]*?) *\r?\n *([^@\r\n\s][^@\r\n]+?) *\r?\n/g;
    var propertyRe = /(?:^|\r?\n) *@(\S+) *([^\r\n]*)/g;
    
    /**
     * @param {String} contents
     * @return {Array}
     */
    function parse(docblock) {
      docblock = docblock
        .replace(commentStartRe, '')
        .replace(commentEndRe, '')
        .replace(wsRe, ' ')
        .replace(stringStartRe, '$1');
    
      // Normalize multi-line directives
      var prev = '';
      while (prev != docblock) {
        prev = docblock;
        docblock = docblock.replace(multilineRe, "\n$1 $2\n");
      }
      docblock = docblock.trim();
    
      var result = [];
      var match;
      while (match = propertyRe.exec(docblock)) {
        result.push([match[1], match[2]]);
      }
    
      return result;
    }
    
    /**
     * Same as parse but returns an object of prop: value instead of array of paris
     * If a property appers more than once the last one will be returned
     *
     * @param {String} contents
     * @return {Object}
     */
    function parseAsObject(docblock) {
      var pairs = parse(docblock);
      var result = {};
      for (var i = 0; i < pairs.length; i++) {
        result[pairs[i][0]] = pairs[i][1];
      }
      return result;
    }
    
    
    exports.extract = extract;
    exports.parse = parse;
    exports.parseAsObject = parseAsObject;
    
  provide("jstransform/src/docblock", module.exports);
}(global));

// pakmanager:jstransform/src/utils
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /**
     * Copyright 2013 Facebook, Inc.
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    
    
    /*jslint node: true*/
    var Syntax = require('esprima-fb').Syntax;
    var leadingIndentRegexp = /(^|\n)( {2}|\t)/g;
    var nonWhiteRegexp = /(\S)/g;
    
    /**
     * A `state` object represents the state of the parser. It has "local" and
     * "global" parts. Global contains parser position, source, etc. Local contains
     * scope based properties like current class name. State should contain all the
     * info required for transformation. It's the only mandatory object that is
     * being passed to every function in transform chain.
     *
     * @param  {string} source
     * @param  {object} transformOptions
     * @return {object}
     */
    function createState(source, rootNode, transformOptions) {
      return {
        /**
         * A tree representing the current local scope (and its lexical scope chain)
         * Useful for tracking identifiers from parent scopes, etc.
         * @type {Object}
         */
        localScope: {
          parentNode: rootNode,
          parentScope: null,
          identifiers: {},
          tempVarIndex: 0,
          tempVars: []
        },
        /**
         * The name (and, if applicable, expression) of the super class
         * @type {Object}
         */
        superClass: null,
        /**
         * The namespace to use when munging identifiers
         * @type {String}
         */
        mungeNamespace: '',
        /**
         * Ref to the node for the current MethodDefinition
         * @type {Object}
         */
        methodNode: null,
        /**
         * Ref to the node for the FunctionExpression of the enclosing
         * MethodDefinition
         * @type {Object}
         */
        methodFuncNode: null,
        /**
         * Name of the enclosing class
         * @type {String}
         */
        className: null,
        /**
         * Whether we're currently within a `strict` scope
         * @type {Bool}
         */
        scopeIsStrict: null,
        /**
         * Indentation offset
         * @type {Number}
         */
        indentBy: 0,
        /**
         * Global state (not affected by updateState)
         * @type {Object}
         */
        g: {
          /**
           * A set of general options that transformations can consider while doing
           * a transformation:
           *
           * - minify
           *   Specifies that transformation steps should do their best to minify
           *   the output source when possible. This is useful for places where
           *   minification optimizations are possible with higher-level context
           *   info than what jsxmin can provide.
           *
           *   For example, the ES6 class transform will minify munged private
           *   variables if this flag is set.
           */
          opts: transformOptions,
          /**
           * Current position in the source code
           * @type {Number}
           */
          position: 0,
          /**
           * Auxiliary data to be returned by transforms
           * @type {Object}
           */
          extra: {},
          /**
           * Buffer containing the result
           * @type {String}
           */
          buffer: '',
          /**
           * Source that is being transformed
           * @type {String}
           */
          source: source,
    
          /**
           * Cached parsed docblock (see getDocblock)
           * @type {object}
           */
          docblock: null,
    
          /**
           * Whether the thing was used
           * @type {Boolean}
           */
          tagNamespaceUsed: false,
    
          /**
           * If using bolt xjs transformation
           * @type {Boolean}
           */
          isBolt: undefined,
    
          /**
           * Whether to record source map (expensive) or not
           * @type {SourceMapGenerator|null}
           */
          sourceMap: null,
    
          /**
           * Filename of the file being processed. Will be returned as a source
           * attribute in the source map
           */
          sourceMapFilename: 'source.js',
    
          /**
           * Only when source map is used: last line in the source for which
           * source map was generated
           * @type {Number}
           */
          sourceLine: 1,
    
          /**
           * Only when source map is used: last line in the buffer for which
           * source map was generated
           * @type {Number}
           */
          bufferLine: 1,
    
          /**
           * The top-level Program AST for the original file.
           */
          originalProgramAST: null,
    
          sourceColumn: 0,
          bufferColumn: 0
        }
      };
    }
    
    /**
     * Updates a copy of a given state with "update" and returns an updated state.
     *
     * @param  {object} state
     * @param  {object} update
     * @return {object}
     */
    function updateState(state, update) {
      var ret = Object.create(state);
      Object.keys(update).forEach(function(updatedKey) {
        ret[updatedKey] = update[updatedKey];
      });
      return ret;
    }
    
    /**
     * Given a state fill the resulting buffer from the original source up to
     * the end
     *
     * @param {number} end
     * @param {object} state
     * @param {?function} contentTransformer Optional callback to transform newly
     *                                       added content.
     */
    function catchup(end, state, contentTransformer) {
      if (end < state.g.position) {
        // cannot move backwards
        return;
      }
      var source = state.g.source.substring(state.g.position, end);
      var transformed = updateIndent(source, state);
      if (state.g.sourceMap && transformed) {
        // record where we are
        state.g.sourceMap.addMapping({
          generated: { line: state.g.bufferLine, column: state.g.bufferColumn },
          original: { line: state.g.sourceLine, column: state.g.sourceColumn },
          source: state.g.sourceMapFilename
        });
    
        // record line breaks in transformed source
        var sourceLines = source.split('\n');
        var transformedLines = transformed.split('\n');
        // Add line break mappings between last known mapping and the end of the
        // added piece. So for the code piece
        //  (foo, bar);
        // > var x = 2;
        // > var b = 3;
        //   var c =
        // only add lines marked with ">": 2, 3.
        for (var i = 1; i < sourceLines.length - 1; i++) {
          state.g.sourceMap.addMapping({
            generated: { line: state.g.bufferLine, column: 0 },
            original: { line: state.g.sourceLine, column: 0 },
            source: state.g.sourceMapFilename
          });
          state.g.sourceLine++;
          state.g.bufferLine++;
        }
        // offset for the last piece
        if (sourceLines.length > 1) {
          state.g.sourceLine++;
          state.g.bufferLine++;
          state.g.sourceColumn = 0;
          state.g.bufferColumn = 0;
        }
        state.g.sourceColumn += sourceLines[sourceLines.length - 1].length;
        state.g.bufferColumn +=
          transformedLines[transformedLines.length - 1].length;
      }
      state.g.buffer +=
        contentTransformer ? contentTransformer(transformed) : transformed;
      state.g.position = end;
    }
    
    /**
     * Returns original source for an AST node.
     * @param {object} node
     * @param {object} state
     * @return {string}
     */
    function getNodeSourceText(node, state) {
      return state.g.source.substring(node.range[0], node.range[1]);
    }
    
    function _replaceNonWhite(value) {
      return value.replace(nonWhiteRegexp, ' ');
    }
    
    /**
     * Removes all non-whitespace characters
     */
    function _stripNonWhite(value) {
      return value.replace(nonWhiteRegexp, '');
    }
    
    /**
     * Finds the position of the next instance of the specified syntactic char in
     * the pending source.
     *
     * NOTE: This will skip instances of the specified char if they sit inside a
     *       comment body.
     *
     * NOTE: This function also assumes that the buffer's current position is not
     *       already within a comment or a string. This is rarely the case since all
     *       of the buffer-advancement utility methods tend to be used on syntactic
     *       nodes' range values -- but it's a small gotcha that's worth mentioning.
     */
    function getNextSyntacticCharOffset(char, state) {
      var pendingSource = state.g.source.substring(state.g.position);
      var pendingSourceLines = pendingSource.split('\n');
    
      var charOffset = 0;
      var line;
      var withinBlockComment = false;
      var withinString = false;
      lineLoop: while ((line = pendingSourceLines.shift()) !== undefined) {
        var lineEndPos = charOffset + line.length;
        charLoop: for (; charOffset < lineEndPos; charOffset++) {
          var currChar = pendingSource[charOffset];
          if (currChar === '"' || currChar === '\'') {
            withinString = !withinString;
            continue charLoop;
          } else if (withinString) {
            continue charLoop;
          } else if (charOffset + 1 < lineEndPos) {
            var nextTwoChars = currChar + line[charOffset + 1];
            if (nextTwoChars === '//') {
              charOffset = lineEndPos + 1;
              continue lineLoop;
            } else if (nextTwoChars === '/*') {
              withinBlockComment = true;
              charOffset += 1;
              continue charLoop;
            } else if (nextTwoChars === '*/') {
              withinBlockComment = false;
              charOffset += 1;
              continue charLoop;
            }
          }
    
          if (!withinBlockComment && currChar === char) {
            return charOffset + state.g.position;
          }
        }
    
        // Account for '\n'
        charOffset++;
        withinString = false;
      }
    
      throw new Error('`' + char + '` not found!');
    }
    
    /**
     * Catches up as `catchup` but replaces non-whitespace chars with spaces.
     */
    function catchupWhiteOut(end, state) {
      catchup(end, state, _replaceNonWhite);
    }
    
    /**
     * Catches up as `catchup` but removes all non-whitespace characters.
     */
    function catchupWhiteSpace(end, state) {
      catchup(end, state, _stripNonWhite);
    }
    
    /**
     * Removes all non-newline characters
     */
    var reNonNewline = /[^\n]/g;
    function stripNonNewline(value) {
      return value.replace(reNonNewline, function() {
        return '';
      });
    }
    
    /**
     * Catches up as `catchup` but removes all non-newline characters.
     *
     * Equivalent to appending as many newlines as there are in the original source
     * between the current position and `end`.
     */
    function catchupNewlines(end, state) {
      catchup(end, state, stripNonNewline);
    }
    
    
    /**
     * Same as catchup but does not touch the buffer
     *
     * @param  {number} end
     * @param  {object} state
     */
    function move(end, state) {
      // move the internal cursors
      if (state.g.sourceMap) {
        if (end < state.g.position) {
          state.g.position = 0;
          state.g.sourceLine = 1;
          state.g.sourceColumn = 0;
        }
    
        var source = state.g.source.substring(state.g.position, end);
        var sourceLines = source.split('\n');
        if (sourceLines.length > 1) {
          state.g.sourceLine += sourceLines.length - 1;
          state.g.sourceColumn = 0;
        }
        state.g.sourceColumn += sourceLines[sourceLines.length - 1].length;
      }
      state.g.position = end;
    }
    
    /**
     * Appends a string of text to the buffer
     *
     * @param {string} str
     * @param {object} state
     */
    function append(str, state) {
      if (state.g.sourceMap && str) {
        state.g.sourceMap.addMapping({
          generated: { line: state.g.bufferLine, column: state.g.bufferColumn },
          original: { line: state.g.sourceLine, column: state.g.sourceColumn },
          source: state.g.sourceMapFilename
        });
        var transformedLines = str.split('\n');
        if (transformedLines.length > 1) {
          state.g.bufferLine += transformedLines.length - 1;
          state.g.bufferColumn = 0;
        }
        state.g.bufferColumn +=
          transformedLines[transformedLines.length - 1].length;
      }
      state.g.buffer += str;
    }
    
    /**
     * Update indent using state.indentBy property. Indent is measured in
     * double spaces. Updates a single line only.
     *
     * @param {string} str
     * @param {object} state
     * @return {string}
     */
    function updateIndent(str, state) {
      /*jshint -W004*/
      var indentBy = state.indentBy;
      if (indentBy < 0) {
        for (var i = 0; i < -indentBy; i++) {
          str = str.replace(leadingIndentRegexp, '$1');
        }
      } else {
        for (var i = 0; i < indentBy; i++) {
          str = str.replace(leadingIndentRegexp, '$1$2$2');
        }
      }
      return str;
    }
    
    /**
     * Calculates indent from the beginning of the line until "start" or the first
     * character before start.
     * @example
     *   "  foo.bar()"
     *         ^
     *       start
     *   indent will be "  "
     *
     * @param  {number} start
     * @param  {object} state
     * @return {string}
     */
    function indentBefore(start, state) {
      var end = start;
      start = start - 1;
    
      while (start > 0 && state.g.source[start] != '\n') {
        if (!state.g.source[start].match(/[ \t]/)) {
          end = start;
        }
        start--;
      }
      return state.g.source.substring(start + 1, end);
    }
    
    function getDocblock(state) {
      if (!state.g.docblock) {
        var docblock =  require('jstransform/src/docblock');
        state.g.docblock =
          docblock.parseAsObject(docblock.extract(state.g.source));
      }
      return state.g.docblock;
    }
    
    function identWithinLexicalScope(identName, state, stopBeforeNode) {
      var currScope = state.localScope;
      while (currScope) {
        if (currScope.identifiers[identName] !== undefined) {
          return true;
        }
    
        if (stopBeforeNode && currScope.parentNode === stopBeforeNode) {
          break;
        }
    
        currScope = currScope.parentScope;
      }
      return false;
    }
    
    function identInLocalScope(identName, state) {
      return state.localScope.identifiers[identName] !== undefined;
    }
    
    /**
     * @param {object} boundaryNode
     * @param {?array} path
     * @return {?object} node
     */
    function initScopeMetadata(boundaryNode, path, node) {
      return {
        boundaryNode: boundaryNode,
        bindingPath: path,
        bindingNode: node
      };
    }
    
    function declareIdentInLocalScope(identName, metaData, state) {
      state.localScope.identifiers[identName] = {
        boundaryNode: metaData.boundaryNode,
        path: metaData.bindingPath,
        node: metaData.bindingNode,
        state: Object.create(state)
      };
    }
    
    function getLexicalBindingMetadata(identName, state) {
      var currScope = state.localScope;
      while (currScope) {
        if (currScope.identifiers[identName] !== undefined) {
          return currScope.identifiers[identName];
        }
    
        currScope = currScope.parentScope;
      }
    }
    
    function getLocalBindingMetadata(identName, state) {
      return state.localScope.identifiers[identName];
    }
    
    /**
     * Apply the given analyzer function to the current node. If the analyzer
     * doesn't return false, traverse each child of the current node using the given
     * traverser function.
     *
     * @param {function} analyzer
     * @param {function} traverser
     * @param {object} node
     * @param {array} path
     * @param {object} state
     */
    function analyzeAndTraverse(analyzer, traverser, node, path, state) {
      if (node.type) {
        if (analyzer(node, path, state) === false) {
          return;
        }
        path.unshift(node);
      }
    
      getOrderedChildren(node).forEach(function(child) {
        traverser(child, path, state);
      });
    
      node.type && path.shift();
    }
    
    /**
     * It is crucial that we traverse in order, or else catchup() on a later
     * node that is processed out of order can move the buffer past a node
     * that we haven't handled yet, preventing us from modifying that node.
     *
     * This can happen when a node has multiple properties containing children.
     * For example, XJSElement nodes have `openingElement`, `closingElement` and
     * `children`. If we traverse `openingElement`, then `closingElement`, then
     * when we get to `children`, the buffer has already caught up to the end of
     * the closing element, after the children.
     *
     * This is basically a Schwartzian transform. Collects an array of children,
     * each one represented as [child, startIndex]; sorts the array by start
     * index; then traverses the children in that order.
     */
    function getOrderedChildren(node) {
      var queue = [];
      for (var key in node) {
        if (node.hasOwnProperty(key)) {
          enqueueNodeWithStartIndex(queue, node[key]);
        }
      }
      queue.sort(function(a, b) { return a[1] - b[1]; });
      return queue.map(function(pair) { return pair[0]; });
    }
    
    /**
     * Helper function for analyzeAndTraverse which queues up all of the children
     * of the given node.
     *
     * Children can also be found in arrays, so we basically want to merge all of
     * those arrays together so we can sort them and then traverse the children
     * in order.
     *
     * One example is the Program node. It contains `body` and `comments`, both
     * arrays. Lexographically, comments are interspersed throughout the body
     * nodes, but esprima's AST groups them together.
     */
    function enqueueNodeWithStartIndex(queue, node) {
      if (typeof node !== 'object' || node === null) {
        return;
      }
      if (node.range) {
        queue.push([node, node.range[0]]);
      } else if (Array.isArray(node)) {
        for (var ii = 0; ii < node.length; ii++) {
          enqueueNodeWithStartIndex(queue, node[ii]);
        }
      }
    }
    
    /**
     * Checks whether a node or any of its sub-nodes contains
     * a syntactic construct of the passed type.
     * @param {object} node - AST node to test.
     * @param {string} type - node type to lookup.
     */
    function containsChildOfType(node, type) {
      return containsChildMatching(node, function(node) {
        return node.type === type;
      });
    }
    
    function containsChildMatching(node, matcher) {
      var foundMatchingChild = false;
      function nodeTypeAnalyzer(node) {
        if (matcher(node) === true) {
          foundMatchingChild = true;
          return false;
        }
      }
      function nodeTypeTraverser(child, path, state) {
        if (!foundMatchingChild) {
          foundMatchingChild = containsChildMatching(child, matcher);
        }
      }
      analyzeAndTraverse(
        nodeTypeAnalyzer,
        nodeTypeTraverser,
        node,
        []
      );
      return foundMatchingChild;
    }
    
    var scopeTypes = {};
    scopeTypes[Syntax.ArrowFunctionExpression] = true;
    scopeTypes[Syntax.FunctionExpression] = true;
    scopeTypes[Syntax.FunctionDeclaration] = true;
    scopeTypes[Syntax.Program] = true;
    
    function getBoundaryNode(path) {
      for (var ii = 0; ii < path.length; ++ii) {
        if (scopeTypes[path[ii].type]) {
          return path[ii];
        }
      }
      throw new Error(
        'Expected to find a node with one of the following types in path:\n' +
        JSON.stringify(Object.keys(scopeTypes))
      );
    }
    
    function getTempVar(tempVarIndex) {
      return '$__' + tempVarIndex;
    }
    
    function injectTempVar(state) {
      var tempVar = '$__' + (state.localScope.tempVarIndex++);
      state.localScope.tempVars.push(tempVar);
      return tempVar;
    }
    
    function injectTempVarDeclarations(state, index) {
      if (state.localScope.tempVars.length) {
        state.g.buffer =
          state.g.buffer.slice(0, index) +
          'var ' + state.localScope.tempVars.join(', ') + ';' +
          state.g.buffer.slice(index);
        state.localScope.tempVars = [];
      }
    }
    
    exports.analyzeAndTraverse = analyzeAndTraverse;
    exports.append = append;
    exports.catchup = catchup;
    exports.catchupNewlines = catchupNewlines;
    exports.catchupWhiteOut = catchupWhiteOut;
    exports.catchupWhiteSpace = catchupWhiteSpace;
    exports.containsChildMatching = containsChildMatching;
    exports.containsChildOfType = containsChildOfType;
    exports.createState = createState;
    exports.declareIdentInLocalScope = declareIdentInLocalScope;
    exports.getBoundaryNode = getBoundaryNode;
    exports.getDocblock = getDocblock;
    exports.getLexicalBindingMetadata = getLexicalBindingMetadata;
    exports.getLocalBindingMetadata = getLocalBindingMetadata;
    exports.getNextSyntacticCharOffset = getNextSyntacticCharOffset;
    exports.getNodeSourceText = getNodeSourceText;
    exports.getOrderedChildren = getOrderedChildren;
    exports.getTempVar = getTempVar;
    exports.identInLocalScope = identInLocalScope;
    exports.identWithinLexicalScope = identWithinLexicalScope;
    exports.indentBefore = indentBefore;
    exports.initScopeMetadata = initScopeMetadata;
    exports.injectTempVar = injectTempVar;
    exports.injectTempVarDeclarations = injectTempVarDeclarations;
    exports.move = move;
    exports.scopeTypes = scopeTypes;
    exports.updateIndent = updateIndent;
    exports.updateState = updateState;
    
  provide("jstransform/src/utils", module.exports);
}(global));

// pakmanager:jstransform
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /**
     * Copyright 2013 Facebook, Inc.
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    
    
    /*jslint node: true*/
    "use strict";
    
    var esprima = require('esprima-fb');
    var utils =  require('jstransform/src/utils');
    
    var getBoundaryNode = utils.getBoundaryNode;
    var declareIdentInScope = utils.declareIdentInLocalScope;
    var initScopeMetadata = utils.initScopeMetadata;
    var Syntax = esprima.Syntax;
    
    /**
     * @param {object} node
     * @param {object} parentNode
     * @return {boolean}
     */
    function _nodeIsClosureScopeBoundary(node, parentNode) {
      if (node.type === Syntax.Program) {
        return true;
      }
    
      var parentIsFunction =
        parentNode.type === Syntax.FunctionDeclaration
        || parentNode.type === Syntax.FunctionExpression
        || parentNode.type === Syntax.ArrowFunctionExpression;
    
      var parentIsCurlylessArrowFunc =
        parentNode.type === Syntax.ArrowFunctionExpression
        && node === parentNode.body;
    
      return parentIsFunction
             && (node.type === Syntax.BlockStatement || parentIsCurlylessArrowFunc);
    }
    
    function _nodeIsBlockScopeBoundary(node, parentNode) {
      if (node.type === Syntax.Program) {
        return false;
      }
    
      return node.type === Syntax.BlockStatement
             && parentNode.type === Syntax.CatchClause;
    }
    
    /**
     * @param {object} node
     * @param {array} path
     * @param {object} state
     */
    function traverse(node, path, state) {
      /*jshint -W004*/
      // Create a scope stack entry if this is the first node we've encountered in
      // its local scope
      var startIndex = null;
      var parentNode = path[0];
      if (!Array.isArray(node) && state.localScope.parentNode !== parentNode) {
        if (_nodeIsClosureScopeBoundary(node, parentNode)) {
          var scopeIsStrict = state.scopeIsStrict;
          if (!scopeIsStrict
              && (node.type === Syntax.BlockStatement
                  || node.type === Syntax.Program)) {
              scopeIsStrict =
                node.body.length > 0
                && node.body[0].type === Syntax.ExpressionStatement
                && node.body[0].expression.type === Syntax.Literal
                && node.body[0].expression.value === 'use strict';
          }
    
          if (node.type === Syntax.Program) {
            startIndex = state.g.buffer.length;
            state = utils.updateState(state, {
              scopeIsStrict: scopeIsStrict
            });
          } else {
            startIndex = state.g.buffer.length + 1;
            state = utils.updateState(state, {
              localScope: {
                parentNode: parentNode,
                parentScope: state.localScope,
                identifiers: {},
                tempVarIndex: 0,
                tempVars: []
              },
              scopeIsStrict: scopeIsStrict
            });
    
            // All functions have an implicit 'arguments' object in scope
            declareIdentInScope('arguments', initScopeMetadata(node), state);
    
            // Include function arg identifiers in the scope boundaries of the
            // function
            if (parentNode.params.length > 0) {
              var param;
              var metadata = initScopeMetadata(parentNode, path.slice(1), path[0]);
              for (var i = 0; i < parentNode.params.length; i++) {
                param = parentNode.params[i];
                if (param.type === Syntax.Identifier) {
                  declareIdentInScope(param.name, metadata, state);
                }
              }
            }
    
            // Include rest arg identifiers in the scope boundaries of their
            // functions
            if (parentNode.rest) {
              var metadata = initScopeMetadata(
                parentNode,
                path.slice(1),
                path[0]
              );
              declareIdentInScope(parentNode.rest.name, metadata, state);
            }
    
            // Named FunctionExpressions scope their name within the body block of
            // themselves only
            if (parentNode.type === Syntax.FunctionExpression && parentNode.id) {
              var metaData =
                initScopeMetadata(parentNode, path.parentNodeslice, parentNode);
              declareIdentInScope(parentNode.id.name, metaData, state);
            }
          }
    
          // Traverse and find all local identifiers in this closure first to
          // account for function/variable declaration hoisting
          collectClosureIdentsAndTraverse(node, path, state);
        }
    
        if (_nodeIsBlockScopeBoundary(node, parentNode)) {
          startIndex = state.g.buffer.length;
          state = utils.updateState(state, {
            localScope: {
              parentNode: parentNode,
              parentScope: state.localScope,
              identifiers: {},
              tempVarIndex: 0,
              tempVars: []
            }
          });
    
          if (parentNode.type === Syntax.CatchClause) {
            var metadata = initScopeMetadata(
              parentNode,
              path.slice(1),
              parentNode
            );
            declareIdentInScope(parentNode.param.name, metadata, state);
          }
          collectBlockIdentsAndTraverse(node, path, state);
        }
      }
    
      // Only catchup() before and after traversing a child node
      function traverser(node, path, state) {
        node.range && utils.catchup(node.range[0], state);
        traverse(node, path, state);
        node.range && utils.catchup(node.range[1], state);
      }
    
      utils.analyzeAndTraverse(walker, traverser, node, path, state);
    
      // Inject temp variables into the scope.
      if (startIndex !== null) {
        utils.injectTempVarDeclarations(state, startIndex);
      }
    }
    
    function collectClosureIdentsAndTraverse(node, path, state) {
      utils.analyzeAndTraverse(
        visitLocalClosureIdentifiers,
        collectClosureIdentsAndTraverse,
        node,
        path,
        state
      );
    }
    
    function collectBlockIdentsAndTraverse(node, path, state) {
      utils.analyzeAndTraverse(
        visitLocalBlockIdentifiers,
        collectBlockIdentsAndTraverse,
        node,
        path,
        state
      );
    }
    
    function visitLocalClosureIdentifiers(node, path, state) {
      var metaData;
      switch (node.type) {
        case Syntax.ArrowFunctionExpression:
        case Syntax.FunctionExpression:
          // Function expressions don't get their names (if there is one) added to
          // the closure scope they're defined in
          return false;
        case Syntax.ClassDeclaration:
        case Syntax.ClassExpression:
        case Syntax.FunctionDeclaration:
          if (node.id) {
            metaData = initScopeMetadata(getBoundaryNode(path), path.slice(), node);
            declareIdentInScope(node.id.name, metaData, state);
          }
          return false;
        case Syntax.VariableDeclarator:
          // Variables have function-local scope
          if (path[0].kind === 'var') {
            metaData = initScopeMetadata(getBoundaryNode(path), path.slice(), node);
            declareIdentInScope(node.id.name, metaData, state);
          }
          break;
      }
    }
    
    function visitLocalBlockIdentifiers(node, path, state) {
      // TODO: Support 'let' here...maybe...one day...or something...
      if (node.type === Syntax.CatchClause) {
        return false;
      }
    }
    
    function walker(node, path, state) {
      var visitors = state.g.visitors;
      for (var i = 0; i < visitors.length; i++) {
        if (visitors[i].test(node, path, state)) {
          return visitors[i](traverse, node, path, state);
        }
      }
    }
    
    var _astCache = {};
    
    function getAstForSource(source, options) {
      if (_astCache[source] && !options.disableAstCache) {
        return _astCache[source];
      }
      var ast = esprima.parse(source, {
        comment: true,
        loc: true,
        range: true,
        sourceType: options.sourceType
      });
      if (!options.disableAstCache) {
        _astCache[source] = ast;
      }
      return ast;
    }
    
    /**
     * Applies all available transformations to the source
     * @param {array} visitors
     * @param {string} source
     * @param {?object} options
     * @return {object}
     */
    function transform(visitors, source, options) {
      options = options || {};
      var ast;
      try {
        ast = getAstForSource(source, options);
        } catch (e) {
        e.message = 'Parse Error: ' + e.message;
        throw e;
      }
      var state = utils.createState(source, ast, options);
      state.g.visitors = visitors;
    
      if (options.sourceMap) {
        var SourceMapGenerator = require('source-map').SourceMapGenerator;
        state.g.sourceMap = new SourceMapGenerator({file: options.filename || 'transformed.js'});
      }
    
      traverse(ast, [], state);
      utils.catchup(source.length, state);
    
      var ret = {code: state.g.buffer, extra: state.g.extra};
      if (options.sourceMap) {
        ret.sourceMap = state.g.sourceMap;
        ret.sourceMapFilename =  options.filename || 'source.js';
      }
      return ret;
    }
    
    exports.transform = transform;
    exports.Syntax = Syntax;
    
  provide("jstransform", module.exports);
}(global));

// pakmanager:through
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  var Stream = require('stream')
    
    // through
    //
    // a stream that does nothing but re-emit the input.
    // useful for aggregating a series of changing but not ending streams into one stream)
    
    exports = module.exports = through
    through.through = through
    
    //create a readable writable stream.
    
    function through (write, end, opts) {
      write = write || function (data) { this.queue(data) }
      end = end || function () { this.queue(null) }
    
      var ended = false, destroyed = false, buffer = [], _ended = false
      var stream = new Stream()
      stream.readable = stream.writable = true
      stream.paused = false
    
    //  stream.autoPause   = !(opts && opts.autoPause   === false)
      stream.autoDestroy = !(opts && opts.autoDestroy === false)
    
      stream.write = function (data) {
        write.call(this, data)
        return !stream.paused
      }
    
      function drain() {
        while(buffer.length && !stream.paused) {
          var data = buffer.shift()
          if(null === data)
            return stream.emit('end')
          else
            stream.emit('data', data)
        }
      }
    
      stream.queue = stream.push = function (data) {
    //    console.error(ended)
        if(_ended) return stream
        if(data === null) _ended = true
        buffer.push(data)
        drain()
        return stream
      }
    
      //this will be registered as the first 'end' listener
      //must call destroy next tick, to make sure we're after any
      //stream piped from here.
      //this is only a problem if end is not emitted synchronously.
      //a nicer way to do this is to make sure this is the last listener for 'end'
    
      stream.on('end', function () {
        stream.readable = false
        if(!stream.writable && stream.autoDestroy)
          process.nextTick(function () {
            stream.destroy()
          })
      })
    
      function _end () {
        stream.writable = false
        end.call(stream)
        if(!stream.readable && stream.autoDestroy)
          stream.destroy()
      }
    
      stream.end = function (data) {
        if(ended) return
        ended = true
        if(arguments.length) stream.write(data)
        _end() // will emit or queue
        return stream
      }
    
      stream.destroy = function () {
        if(destroyed) return
        destroyed = true
        ended = true
        buffer.length = 0
        stream.writable = stream.readable = false
        stream.emit('close')
        return stream
      }
    
      stream.pause = function () {
        if(stream.paused) return
        stream.paused = true
        return stream
      }
    
      stream.resume = function () {
        if(stream.paused) {
          stream.paused = false
          stream.emit('resume')
        }
        drain()
        //may have become paused again,
        //as drain emits 'data'.
        if(!stream.paused)
          stream.emit('drain')
        return stream
      }
      return stream
    }
    
    
  provide("through", module.exports);
}(global));

// pakmanager:envify/visitors
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  var Syntax = require('jstransform').Syntax
    var utils = require('jstransform/src/utils')
    
    function create(envs) {
      var args  = [].concat(envs[0]._ || []).concat(envs[1]._ || [])
      var purge = args.indexOf('purge') !== -1
    
      function visitProcessEnv(traverse, node, path, state) {
        var key = node.property.name || node.property.value
    
        for (var i = 0; i < envs.length; i++) {
          var value = envs[i][key]
          if (value !== undefined) {
            replaceEnv(node, state, value)
            return false
          }
        }
    
        if (purge) {
          replaceEnv(node, state, undefined)
        }
    
        return false
      }
    
      function replaceEnv(node, state, value) {
        utils.catchup(node.range[0], state)
        utils.append(JSON.stringify(value), state)
        utils.move(node.range[1], state)
      }
    
      visitProcessEnv.test = function(node, path, state) {
        return (
          node.type === Syntax.MemberExpression
          && !(path[0].type === Syntax.AssignmentExpression && path[0].left === node)
          && node.property.type === (node.computed ? Syntax.Literal : Syntax.Identifier)
          && node.object.computed === false
          && node.object.type === Syntax.MemberExpression
          && node.object.object.type === Syntax.Identifier
          && node.object.object.name === 'process'
          && node.object.property.type === Syntax.Identifier
          && node.object.property.name === 'env'
        )
      }
    
      return [visitProcessEnv]
    }
    
    module.exports = create
    
  provide("envify/visitors", module.exports);
}(global));

// pakmanager:envify/custom
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  var through = require('through')
      , jstransform = require('jstransform')
      , createVisitors =  require('envify/visitors')
    
    var processEnvPattern = /\bprocess\.env\b/
    
    module.exports = function(rootEnv) {
      rootEnv = rootEnv || process.env || {}
    
      return function envify(file, argv) {
        if (/\.json$/.test(file)) return through()
    
        var buffer = []
        argv = argv || {}
    
        return through(write, flush)
    
        function write(data) {
          buffer.push(data)
        }
    
        function flush() {
          var source = buffer.join('')
    
          if (processEnvPattern.test(source)) {
            try {
              var visitors = createVisitors([argv, rootEnv])
              source = jstransform.transform(visitors, source).code
            } catch(err) {
              return this.emit('error', err)
            }
          }
    
          this.queue(source)
          this.queue(null)
        }
      }
    }
    
  provide("envify/custom", module.exports);
}(global));

// pakmanager:envify
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  module.exports =  require('envify/custom')(process.env)
    
  provide("envify", module.exports);
}(global));

// pakmanager:jquery
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /*!
     * jQuery JavaScript Library v2.2.1
     * http://jquery.com/
     *
     * Includes Sizzle.js
     * http://sizzlejs.com/
     *
     * Copyright jQuery Foundation and other contributors
     * Released under the MIT license
     * http://jquery.org/license
     *
     * Date: 2016-02-22T19:11Z
     */
    
    (function( global, factory ) {
    
    	if ( typeof module === "object" && typeof module.exports === "object" ) {
    		// For CommonJS and CommonJS-like environments where a proper `window`
    		// is present, execute the factory and get jQuery.
    		// For environments that do not have a `window` with a `document`
    		// (such as Node.js), expose a factory as module.exports.
    		// This accentuates the need for the creation of a real `window`.
    		// e.g. var jQuery =  require('jquery')(window);
    		// See ticket #14549 for more info.
    		module.exports = global.document ?
    			factory( global, true ) :
    			function( w ) {
    				if ( !w.document ) {
    					throw new Error( "jQuery requires a window with a document" );
    				}
    				return factory( w );
    			};
    	} else {
    		factory( global );
    	}
    
    // Pass this if window is not defined yet
    }(typeof window !== "undefined" ? window : this, function( window, noGlobal ) {
    
    // Support: Firefox 18+
    // Can't be in strict mode, several libs including ASP.NET trace
    // the stack via arguments.caller.callee and Firefox dies if
    // you try to trace through "use strict" call chains. (#13335)
    //"use strict";
    var arr = [];
    
    var document = window.document;
    
    var slice = arr.slice;
    
    var concat = arr.concat;
    
    var push = arr.push;
    
    var indexOf = arr.indexOf;
    
    var class2type = {};
    
    var toString = class2type.toString;
    
    var hasOwn = class2type.hasOwnProperty;
    
    var support = {};
    
    
    
    var
    	version = "2.2.1",
    
    	// Define a local copy of jQuery
    	jQuery = function( selector, context ) {
    
    		// The jQuery object is actually just the init constructor 'enhanced'
    		// Need init if jQuery is called (just allow error to be thrown if not included)
    		return new jQuery.fn.init( selector, context );
    	},
    
    	// Support: Android<4.1
    	// Make sure we trim BOM and NBSP
    	rtrim = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g,
    
    	// Matches dashed string for camelizing
    	rmsPrefix = /^-ms-/,
    	rdashAlpha = /-([\da-z])/gi,
    
    	// Used by jQuery.camelCase as callback to replace()
    	fcamelCase = function( all, letter ) {
    		return letter.toUpperCase();
    	};
    
    jQuery.fn = jQuery.prototype = {
    
    	// The current version of jQuery being used
    	jquery: version,
    
    	constructor: jQuery,
    
    	// Start with an empty selector
    	selector: "",
    
    	// The default length of a jQuery object is 0
    	length: 0,
    
    	toArray: function() {
    		return slice.call( this );
    	},
    
    	// Get the Nth element in the matched element set OR
    	// Get the whole matched element set as a clean array
    	get: function( num ) {
    		return num != null ?
    
    			// Return just the one element from the set
    			( num < 0 ? this[ num + this.length ] : this[ num ] ) :
    
    			// Return all the elements in a clean array
    			slice.call( this );
    	},
    
    	// Take an array of elements and push it onto the stack
    	// (returning the new matched element set)
    	pushStack: function( elems ) {
    
    		// Build a new jQuery matched element set
    		var ret = jQuery.merge( this.constructor(), elems );
    
    		// Add the old object onto the stack (as a reference)
    		ret.prevObject = this;
    		ret.context = this.context;
    
    		// Return the newly-formed element set
    		return ret;
    	},
    
    	// Execute a callback for every element in the matched set.
    	each: function( callback ) {
    		return jQuery.each( this, callback );
    	},
    
    	map: function( callback ) {
    		return this.pushStack( jQuery.map( this, function( elem, i ) {
    			return callback.call( elem, i, elem );
    		} ) );
    	},
    
    	slice: function() {
    		return this.pushStack( slice.apply( this, arguments ) );
    	},
    
    	first: function() {
    		return this.eq( 0 );
    	},
    
    	last: function() {
    		return this.eq( -1 );
    	},
    
    	eq: function( i ) {
    		var len = this.length,
    			j = +i + ( i < 0 ? len : 0 );
    		return this.pushStack( j >= 0 && j < len ? [ this[ j ] ] : [] );
    	},
    
    	end: function() {
    		return this.prevObject || this.constructor();
    	},
    
    	// For internal use only.
    	// Behaves like an Array's method, not like a jQuery method.
    	push: push,
    	sort: arr.sort,
    	splice: arr.splice
    };
    
    jQuery.extend = jQuery.fn.extend = function() {
    	var options, name, src, copy, copyIsArray, clone,
    		target = arguments[ 0 ] || {},
    		i = 1,
    		length = arguments.length,
    		deep = false;
    
    	// Handle a deep copy situation
    	if ( typeof target === "boolean" ) {
    		deep = target;
    
    		// Skip the boolean and the target
    		target = arguments[ i ] || {};
    		i++;
    	}
    
    	// Handle case when target is a string or something (possible in deep copy)
    	if ( typeof target !== "object" && !jQuery.isFunction( target ) ) {
    		target = {};
    	}
    
    	// Extend jQuery itself if only one argument is passed
    	if ( i === length ) {
    		target = this;
    		i--;
    	}
    
    	for ( ; i < length; i++ ) {
    
    		// Only deal with non-null/undefined values
    		if ( ( options = arguments[ i ] ) != null ) {
    
    			// Extend the base object
    			for ( name in options ) {
    				src = target[ name ];
    				copy = options[ name ];
    
    				// Prevent never-ending loop
    				if ( target === copy ) {
    					continue;
    				}
    
    				// Recurse if we're merging plain objects or arrays
    				if ( deep && copy && ( jQuery.isPlainObject( copy ) ||
    					( copyIsArray = jQuery.isArray( copy ) ) ) ) {
    
    					if ( copyIsArray ) {
    						copyIsArray = false;
    						clone = src && jQuery.isArray( src ) ? src : [];
    
    					} else {
    						clone = src && jQuery.isPlainObject( src ) ? src : {};
    					}
    
    					// Never move original objects, clone them
    					target[ name ] = jQuery.extend( deep, clone, copy );
    
    				// Don't bring in undefined values
    				} else if ( copy !== undefined ) {
    					target[ name ] = copy;
    				}
    			}
    		}
    	}
    
    	// Return the modified object
    	return target;
    };
    
    jQuery.extend( {
    
    	// Unique for each copy of jQuery on the page
    	expando: "jQuery" + ( version + Math.random() ).replace( /\D/g, "" ),
    
    	// Assume jQuery is ready without the ready module
    	isReady: true,
    
    	error: function( msg ) {
    		throw new Error( msg );
    	},
    
    	noop: function() {},
    
    	isFunction: function( obj ) {
    		return jQuery.type( obj ) === "function";
    	},
    
    	isArray: Array.isArray,
    
    	isWindow: function( obj ) {
    		return obj != null && obj === obj.window;
    	},
    
    	isNumeric: function( obj ) {
    
    		// parseFloat NaNs numeric-cast false positives (null|true|false|"")
    		// ...but misinterprets leading-number strings, particularly hex literals ("0x...")
    		// subtraction forces infinities to NaN
    		// adding 1 corrects loss of precision from parseFloat (#15100)
    		var realStringObj = obj && obj.toString();
    		return !jQuery.isArray( obj ) && ( realStringObj - parseFloat( realStringObj ) + 1 ) >= 0;
    	},
    
    	isPlainObject: function( obj ) {
    
    		// Not plain objects:
    		// - Any object or value whose internal [[Class]] property is not "[object Object]"
    		// - DOM nodes
    		// - window
    		if ( jQuery.type( obj ) !== "object" || obj.nodeType || jQuery.isWindow( obj ) ) {
    			return false;
    		}
    
    		if ( obj.constructor &&
    				!hasOwn.call( obj.constructor.prototype, "isPrototypeOf" ) ) {
    			return false;
    		}
    
    		// If the function hasn't returned already, we're confident that
    		// |obj| is a plain object, created by {} or constructed with new Object
    		return true;
    	},
    
    	isEmptyObject: function( obj ) {
    		var name;
    		for ( name in obj ) {
    			return false;
    		}
    		return true;
    	},
    
    	type: function( obj ) {
    		if ( obj == null ) {
    			return obj + "";
    		}
    
    		// Support: Android<4.0, iOS<6 (functionish RegExp)
    		return typeof obj === "object" || typeof obj === "function" ?
    			class2type[ toString.call( obj ) ] || "object" :
    			typeof obj;
    	},
    
    	// Evaluates a script in a global context
    	globalEval: function( code ) {
    		var script,
    			indirect = eval;
    
    		code = jQuery.trim( code );
    
    		if ( code ) {
    
    			// If the code includes a valid, prologue position
    			// strict mode pragma, execute code by injecting a
    			// script tag into the document.
    			if ( code.indexOf( "use strict" ) === 1 ) {
    				script = document.createElement( "script" );
    				script.text = code;
    				document.head.appendChild( script ).parentNode.removeChild( script );
    			} else {
    
    				// Otherwise, avoid the DOM node creation, insertion
    				// and removal by using an indirect global eval
    
    				indirect( code );
    			}
    		}
    	},
    
    	// Convert dashed to camelCase; used by the css and data modules
    	// Support: IE9-11+
    	// Microsoft forgot to hump their vendor prefix (#9572)
    	camelCase: function( string ) {
    		return string.replace( rmsPrefix, "ms-" ).replace( rdashAlpha, fcamelCase );
    	},
    
    	nodeName: function( elem, name ) {
    		return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();
    	},
    
    	each: function( obj, callback ) {
    		var length, i = 0;
    
    		if ( isArrayLike( obj ) ) {
    			length = obj.length;
    			for ( ; i < length; i++ ) {
    				if ( callback.call( obj[ i ], i, obj[ i ] ) === false ) {
    					break;
    				}
    			}
    		} else {
    			for ( i in obj ) {
    				if ( callback.call( obj[ i ], i, obj[ i ] ) === false ) {
    					break;
    				}
    			}
    		}
    
    		return obj;
    	},
    
    	// Support: Android<4.1
    	trim: function( text ) {
    		return text == null ?
    			"" :
    			( text + "" ).replace( rtrim, "" );
    	},
    
    	// results is for internal usage only
    	makeArray: function( arr, results ) {
    		var ret = results || [];
    
    		if ( arr != null ) {
    			if ( isArrayLike( Object( arr ) ) ) {
    				jQuery.merge( ret,
    					typeof arr === "string" ?
    					[ arr ] : arr
    				);
    			} else {
    				push.call( ret, arr );
    			}
    		}
    
    		return ret;
    	},
    
    	inArray: function( elem, arr, i ) {
    		return arr == null ? -1 : indexOf.call( arr, elem, i );
    	},
    
    	merge: function( first, second ) {
    		var len = +second.length,
    			j = 0,
    			i = first.length;
    
    		for ( ; j < len; j++ ) {
    			first[ i++ ] = second[ j ];
    		}
    
    		first.length = i;
    
    		return first;
    	},
    
    	grep: function( elems, callback, invert ) {
    		var callbackInverse,
    			matches = [],
    			i = 0,
    			length = elems.length,
    			callbackExpect = !invert;
    
    		// Go through the array, only saving the items
    		// that pass the validator function
    		for ( ; i < length; i++ ) {
    			callbackInverse = !callback( elems[ i ], i );
    			if ( callbackInverse !== callbackExpect ) {
    				matches.push( elems[ i ] );
    			}
    		}
    
    		return matches;
    	},
    
    	// arg is for internal usage only
    	map: function( elems, callback, arg ) {
    		var length, value,
    			i = 0,
    			ret = [];
    
    		// Go through the array, translating each of the items to their new values
    		if ( isArrayLike( elems ) ) {
    			length = elems.length;
    			for ( ; i < length; i++ ) {
    				value = callback( elems[ i ], i, arg );
    
    				if ( value != null ) {
    					ret.push( value );
    				}
    			}
    
    		// Go through every key on the object,
    		} else {
    			for ( i in elems ) {
    				value = callback( elems[ i ], i, arg );
    
    				if ( value != null ) {
    					ret.push( value );
    				}
    			}
    		}
    
    		// Flatten any nested arrays
    		return concat.apply( [], ret );
    	},
    
    	// A global GUID counter for objects
    	guid: 1,
    
    	// Bind a function to a context, optionally partially applying any
    	// arguments.
    	proxy: function( fn, context ) {
    		var tmp, args, proxy;
    
    		if ( typeof context === "string" ) {
    			tmp = fn[ context ];
    			context = fn;
    			fn = tmp;
    		}
    
    		// Quick check to determine if target is callable, in the spec
    		// this throws a TypeError, but we will just return undefined.
    		if ( !jQuery.isFunction( fn ) ) {
    			return undefined;
    		}
    
    		// Simulated bind
    		args = slice.call( arguments, 2 );
    		proxy = function() {
    			return fn.apply( context || this, args.concat( slice.call( arguments ) ) );
    		};
    
    		// Set the guid of unique handler to the same of original handler, so it can be removed
    		proxy.guid = fn.guid = fn.guid || jQuery.guid++;
    
    		return proxy;
    	},
    
    	now: Date.now,
    
    	// jQuery.support is not used in Core but other projects attach their
    	// properties to it so it needs to exist.
    	support: support
    } );
    
    // JSHint would error on this code due to the Symbol not being defined in ES5.
    // Defining this global in .jshintrc would create a danger of using the global
    // unguarded in another place, it seems safer to just disable JSHint for these
    // three lines.
    /* jshint ignore: start */
    if ( typeof Symbol === "function" ) {
    	jQuery.fn[ Symbol.iterator ] = arr[ Symbol.iterator ];
    }
    /* jshint ignore: end */
    
    // Populate the class2type map
    jQuery.each( "Boolean Number String Function Array Date RegExp Object Error Symbol".split( " " ),
    function( i, name ) {
    	class2type[ "[object " + name + "]" ] = name.toLowerCase();
    } );
    
    function isArrayLike( obj ) {
    
    	// Support: iOS 8.2 (not reproducible in simulator)
    	// `in` check used to prevent JIT error (gh-2145)
    	// hasOwn isn't used here due to false negatives
    	// regarding Nodelist length in IE
    	var length = !!obj && "length" in obj && obj.length,
    		type = jQuery.type( obj );
    
    	if ( type === "function" || jQuery.isWindow( obj ) ) {
    		return false;
    	}
    
    	return type === "array" || length === 0 ||
    		typeof length === "number" && length > 0 && ( length - 1 ) in obj;
    }
    var Sizzle =
    /*!
     * Sizzle CSS Selector Engine v2.2.1
     * http://sizzlejs.com/
     *
     * Copyright jQuery Foundation and other contributors
     * Released under the MIT license
     * http://jquery.org/license
     *
     * Date: 2015-10-17
     */
    (function( window ) {
    
    var i,
    	support,
    	Expr,
    	getText,
    	isXML,
    	tokenize,
    	compile,
    	select,
    	outermostContext,
    	sortInput,
    	hasDuplicate,
    
    	// Local document vars
    	setDocument,
    	document,
    	docElem,
    	documentIsHTML,
    	rbuggyQSA,
    	rbuggyMatches,
    	matches,
    	contains,
    
    	// Instance-specific data
    	expando = "sizzle" + 1 * new Date(),
    	preferredDoc = window.document,
    	dirruns = 0,
    	done = 0,
    	classCache = createCache(),
    	tokenCache = createCache(),
    	compilerCache = createCache(),
    	sortOrder = function( a, b ) {
    		if ( a === b ) {
    			hasDuplicate = true;
    		}
    		return 0;
    	},
    
    	// General-purpose constants
    	MAX_NEGATIVE = 1 << 31,
    
    	// Instance methods
    	hasOwn = ({}).hasOwnProperty,
    	arr = [],
    	pop = arr.pop,
    	push_native = arr.push,
    	push = arr.push,
    	slice = arr.slice,
    	// Use a stripped-down indexOf as it's faster than native
    	// http://jsperf.com/thor-indexof-vs-for/5
    	indexOf = function( list, elem ) {
    		var i = 0,
    			len = list.length;
    		for ( ; i < len; i++ ) {
    			if ( list[i] === elem ) {
    				return i;
    			}
    		}
    		return -1;
    	},
    
    	booleans = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped",
    
    	// Regular expressions
    
    	// http://www.w3.org/TR/css3-selectors/#whitespace
    	whitespace = "[\\x20\\t\\r\\n\\f]",
    
    	// http://www.w3.org/TR/CSS21/syndata.html#value-def-identifier
    	identifier = "(?:\\\\.|[\\w-]|[^\\x00-\\xa0])+",
    
    	// Attribute selectors: http://www.w3.org/TR/selectors/#attribute-selectors
    	attributes = "\\[" + whitespace + "*(" + identifier + ")(?:" + whitespace +
    		// Operator (capture 2)
    		"*([*^$|!~]?=)" + whitespace +
    		// "Attribute values must be CSS identifiers [capture 5] or strings [capture 3 or capture 4]"
    		"*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|(" + identifier + "))|)" + whitespace +
    		"*\\]",
    
    	pseudos = ":(" + identifier + ")(?:\\((" +
    		// To reduce the number of selectors needing tokenize in the preFilter, prefer arguments:
    		// 1. quoted (capture 3; capture 4 or capture 5)
    		"('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|" +
    		// 2. simple (capture 6)
    		"((?:\\\\.|[^\\\\()[\\]]|" + attributes + ")*)|" +
    		// 3. anything else (capture 2)
    		".*" +
    		")\\)|)",
    
    	// Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter
    	rwhitespace = new RegExp( whitespace + "+", "g" ),
    	rtrim = new RegExp( "^" + whitespace + "+|((?:^|[^\\\\])(?:\\\\.)*)" + whitespace + "+$", "g" ),
    
    	rcomma = new RegExp( "^" + whitespace + "*," + whitespace + "*" ),
    	rcombinators = new RegExp( "^" + whitespace + "*([>+~]|" + whitespace + ")" + whitespace + "*" ),
    
    	rattributeQuotes = new RegExp( "=" + whitespace + "*([^\\]'\"]*?)" + whitespace + "*\\]", "g" ),
    
    	rpseudo = new RegExp( pseudos ),
    	ridentifier = new RegExp( "^" + identifier + "$" ),
    
    	matchExpr = {
    		"ID": new RegExp( "^#(" + identifier + ")" ),
    		"CLASS": new RegExp( "^\\.(" + identifier + ")" ),
    		"TAG": new RegExp( "^(" + identifier + "|[*])" ),
    		"ATTR": new RegExp( "^" + attributes ),
    		"PSEUDO": new RegExp( "^" + pseudos ),
    		"CHILD": new RegExp( "^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" + whitespace +
    			"*(even|odd|(([+-]|)(\\d*)n|)" + whitespace + "*(?:([+-]|)" + whitespace +
    			"*(\\d+)|))" + whitespace + "*\\)|)", "i" ),
    		"bool": new RegExp( "^(?:" + booleans + ")$", "i" ),
    		// For use in libraries implementing .is()
    		// We use this for POS matching in `select`
    		"needsContext": new RegExp( "^" + whitespace + "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" +
    			whitespace + "*((?:-\\d)?\\d*)" + whitespace + "*\\)|)(?=[^-]|$)", "i" )
    	},
    
    	rinputs = /^(?:input|select|textarea|button)$/i,
    	rheader = /^h\d$/i,
    
    	rnative = /^[^{]+\{\s*\[native \w/,
    
    	// Easily-parseable/retrievable ID or TAG or CLASS selectors
    	rquickExpr = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,
    
    	rsibling = /[+~]/,
    	rescape = /'|\\/g,
    
    	// CSS escapes http://www.w3.org/TR/CSS21/syndata.html#escaped-characters
    	runescape = new RegExp( "\\\\([\\da-f]{1,6}" + whitespace + "?|(" + whitespace + ")|.)", "ig" ),
    	funescape = function( _, escaped, escapedWhitespace ) {
    		var high = "0x" + escaped - 0x10000;
    		// NaN means non-codepoint
    		// Support: Firefox<24
    		// Workaround erroneous numeric interpretation of +"0x"
    		return high !== high || escapedWhitespace ?
    			escaped :
    			high < 0 ?
    				// BMP codepoint
    				String.fromCharCode( high + 0x10000 ) :
    				// Supplemental Plane codepoint (surrogate pair)
    				String.fromCharCode( high >> 10 | 0xD800, high & 0x3FF | 0xDC00 );
    	},
    
    	// Used for iframes
    	// See setDocument()
    	// Removing the function wrapper causes a "Permission Denied"
    	// error in IE
    	unloadHandler = function() {
    		setDocument();
    	};
    
    // Optimize for push.apply( _, NodeList )
    try {
    	push.apply(
    		(arr = slice.call( preferredDoc.childNodes )),
    		preferredDoc.childNodes
    	);
    	// Support: Android<4.0
    	// Detect silently failing push.apply
    	arr[ preferredDoc.childNodes.length ].nodeType;
    } catch ( e ) {
    	push = { apply: arr.length ?
    
    		// Leverage slice if possible
    		function( target, els ) {
    			push_native.apply( target, slice.call(els) );
    		} :
    
    		// Support: IE<9
    		// Otherwise append directly
    		function( target, els ) {
    			var j = target.length,
    				i = 0;
    			// Can't trust NodeList.length
    			while ( (target[j++] = els[i++]) ) {}
    			target.length = j - 1;
    		}
    	};
    }
    
    function Sizzle( selector, context, results, seed ) {
    	var m, i, elem, nid, nidselect, match, groups, newSelector,
    		newContext = context && context.ownerDocument,
    
    		// nodeType defaults to 9, since context defaults to document
    		nodeType = context ? context.nodeType : 9;
    
    	results = results || [];
    
    	// Return early from calls with invalid selector or context
    	if ( typeof selector !== "string" || !selector ||
    		nodeType !== 1 && nodeType !== 9 && nodeType !== 11 ) {
    
    		return results;
    	}
    
    	// Try to shortcut find operations (as opposed to filters) in HTML documents
    	if ( !seed ) {
    
    		if ( ( context ? context.ownerDocument || context : preferredDoc ) !== document ) {
    			setDocument( context );
    		}
    		context = context || document;
    
    		if ( documentIsHTML ) {
    
    			// If the selector is sufficiently simple, try using a "get*By*" DOM method
    			// (excepting DocumentFragment context, where the methods don't exist)
    			if ( nodeType !== 11 && (match = rquickExpr.exec( selector )) ) {
    
    				// ID selector
    				if ( (m = match[1]) ) {
    
    					// Document context
    					if ( nodeType === 9 ) {
    						if ( (elem = context.getElementById( m )) ) {
    
    							// Support: IE, Opera, Webkit
    							// TODO: identify versions
    							// getElementById can match elements by name instead of ID
    							if ( elem.id === m ) {
    								results.push( elem );
    								return results;
    							}
    						} else {
    							return results;
    						}
    
    					// Element context
    					} else {
    
    						// Support: IE, Opera, Webkit
    						// TODO: identify versions
    						// getElementById can match elements by name instead of ID
    						if ( newContext && (elem = newContext.getElementById( m )) &&
    							contains( context, elem ) &&
    							elem.id === m ) {
    
    							results.push( elem );
    							return results;
    						}
    					}
    
    				// Type selector
    				} else if ( match[2] ) {
    					push.apply( results, context.getElementsByTagName( selector ) );
    					return results;
    
    				// Class selector
    				} else if ( (m = match[3]) && support.getElementsByClassName &&
    					context.getElementsByClassName ) {
    
    					push.apply( results, context.getElementsByClassName( m ) );
    					return results;
    				}
    			}
    
    			// Take advantage of querySelectorAll
    			if ( support.qsa &&
    				!compilerCache[ selector + " " ] &&
    				(!rbuggyQSA || !rbuggyQSA.test( selector )) ) {
    
    				if ( nodeType !== 1 ) {
    					newContext = context;
    					newSelector = selector;
    
    				// qSA looks outside Element context, which is not what we want
    				// Thanks to Andrew Dupont for this workaround technique
    				// Support: IE <=8
    				// Exclude object elements
    				} else if ( context.nodeName.toLowerCase() !== "object" ) {
    
    					// Capture the context ID, setting it first if necessary
    					if ( (nid = context.getAttribute( "id" )) ) {
    						nid = nid.replace( rescape, "\\$&" );
    					} else {
    						context.setAttribute( "id", (nid = expando) );
    					}
    
    					// Prefix every selector in the list
    					groups = tokenize( selector );
    					i = groups.length;
    					nidselect = ridentifier.test( nid ) ? "#" + nid : "[id='" + nid + "']";
    					while ( i-- ) {
    						groups[i] = nidselect + " " + toSelector( groups[i] );
    					}
    					newSelector = groups.join( "," );
    
    					// Expand context for sibling selectors
    					newContext = rsibling.test( selector ) && testContext( context.parentNode ) ||
    						context;
    				}
    
    				if ( newSelector ) {
    					try {
    						push.apply( results,
    							newContext.querySelectorAll( newSelector )
    						);
    						return results;
    					} catch ( qsaError ) {
    					} finally {
    						if ( nid === expando ) {
    							context.removeAttribute( "id" );
    						}
    					}
    				}
    			}
    		}
    	}
    
    	// All others
    	return select( selector.replace( rtrim, "$1" ), context, results, seed );
    }
    
    /**
     * Create key-value caches of limited size
     * @returns {function(string, object)} Returns the Object data after storing it on itself with
     *	property name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength)
     *	deleting the oldest entry
     */
    function createCache() {
    	var keys = [];
    
    	function cache( key, value ) {
    		// Use (key + " ") to avoid collision with native prototype properties (see Issue #157)
    		if ( keys.push( key + " " ) > Expr.cacheLength ) {
    			// Only keep the most recent entries
    			delete cache[ keys.shift() ];
    		}
    		return (cache[ key + " " ] = value);
    	}
    	return cache;
    }
    
    /**
     * Mark a function for special use by Sizzle
     * @param {Function} fn The function to mark
     */
    function markFunction( fn ) {
    	fn[ expando ] = true;
    	return fn;
    }
    
    /**
     * Support testing using an element
     * @param {Function} fn Passed the created div and expects a boolean result
     */
    function assert( fn ) {
    	var div = document.createElement("div");
    
    	try {
    		return !!fn( div );
    	} catch (e) {
    		return false;
    	} finally {
    		// Remove from its parent by default
    		if ( div.parentNode ) {
    			div.parentNode.removeChild( div );
    		}
    		// release memory in IE
    		div = null;
    	}
    }
    
    /**
     * Adds the same handler for all of the specified attrs
     * @param {String} attrs Pipe-separated list of attributes
     * @param {Function} handler The method that will be applied
     */
    function addHandle( attrs, handler ) {
    	var arr = attrs.split("|"),
    		i = arr.length;
    
    	while ( i-- ) {
    		Expr.attrHandle[ arr[i] ] = handler;
    	}
    }
    
    /**
     * Checks document order of two siblings
     * @param {Element} a
     * @param {Element} b
     * @returns {Number} Returns less than 0 if a precedes b, greater than 0 if a follows b
     */
    function siblingCheck( a, b ) {
    	var cur = b && a,
    		diff = cur && a.nodeType === 1 && b.nodeType === 1 &&
    			( ~b.sourceIndex || MAX_NEGATIVE ) -
    			( ~a.sourceIndex || MAX_NEGATIVE );
    
    	// Use IE sourceIndex if available on both nodes
    	if ( diff ) {
    		return diff;
    	}
    
    	// Check if b follows a
    	if ( cur ) {
    		while ( (cur = cur.nextSibling) ) {
    			if ( cur === b ) {
    				return -1;
    			}
    		}
    	}
    
    	return a ? 1 : -1;
    }
    
    /**
     * Returns a function to use in pseudos for input types
     * @param {String} type
     */
    function createInputPseudo( type ) {
    	return function( elem ) {
    		var name = elem.nodeName.toLowerCase();
    		return name === "input" && elem.type === type;
    	};
    }
    
    /**
     * Returns a function to use in pseudos for buttons
     * @param {String} type
     */
    function createButtonPseudo( type ) {
    	return function( elem ) {
    		var name = elem.nodeName.toLowerCase();
    		return (name === "input" || name === "button") && elem.type === type;
    	};
    }
    
    /**
     * Returns a function to use in pseudos for positionals
     * @param {Function} fn
     */
    function createPositionalPseudo( fn ) {
    	return markFunction(function( argument ) {
    		argument = +argument;
    		return markFunction(function( seed, matches ) {
    			var j,
    				matchIndexes = fn( [], seed.length, argument ),
    				i = matchIndexes.length;
    
    			// Match elements found at the specified indexes
    			while ( i-- ) {
    				if ( seed[ (j = matchIndexes[i]) ] ) {
    					seed[j] = !(matches[j] = seed[j]);
    				}
    			}
    		});
    	});
    }
    
    /**
     * Checks a node for validity as a Sizzle context
     * @param {Element|Object=} context
     * @returns {Element|Object|Boolean} The input node if acceptable, otherwise a falsy value
     */
    function testContext( context ) {
    	return context && typeof context.getElementsByTagName !== "undefined" && context;
    }
    
    // Expose support vars for convenience
    support = Sizzle.support = {};
    
    /**
     * Detects XML nodes
     * @param {Element|Object} elem An element or a document
     * @returns {Boolean} True iff elem is a non-HTML XML node
     */
    isXML = Sizzle.isXML = function( elem ) {
    	// documentElement is verified for cases where it doesn't yet exist
    	// (such as loading iframes in IE - #4833)
    	var documentElement = elem && (elem.ownerDocument || elem).documentElement;
    	return documentElement ? documentElement.nodeName !== "HTML" : false;
    };
    
    /**
     * Sets document-related variables once based on the current document
     * @param {Element|Object} [doc] An element or document object to use to set the document
     * @returns {Object} Returns the current document
     */
    setDocument = Sizzle.setDocument = function( node ) {
    	var hasCompare, parent,
    		doc = node ? node.ownerDocument || node : preferredDoc;
    
    	// Return early if doc is invalid or already selected
    	if ( doc === document || doc.nodeType !== 9 || !doc.documentElement ) {
    		return document;
    	}
    
    	// Update global variables
    	document = doc;
    	docElem = document.documentElement;
    	documentIsHTML = !isXML( document );
    
    	// Support: IE 9-11, Edge
    	// Accessing iframe documents after unload throws "permission denied" errors (jQuery #13936)
    	if ( (parent = document.defaultView) && parent.top !== parent ) {
    		// Support: IE 11
    		if ( parent.addEventListener ) {
    			parent.addEventListener( "unload", unloadHandler, false );
    
    		// Support: IE 9 - 10 only
    		} else if ( parent.attachEvent ) {
    			parent.attachEvent( "onunload", unloadHandler );
    		}
    	}
    
    	/* Attributes
    	---------------------------------------------------------------------- */
    
    	// Support: IE<8
    	// Verify that getAttribute really returns attributes and not properties
    	// (excepting IE8 booleans)
    	support.attributes = assert(function( div ) {
    		div.className = "i";
    		return !div.getAttribute("className");
    	});
    
    	/* getElement(s)By*
    	---------------------------------------------------------------------- */
    
    	// Check if getElementsByTagName("*") returns only elements
    	support.getElementsByTagName = assert(function( div ) {
    		div.appendChild( document.createComment("") );
    		return !div.getElementsByTagName("*").length;
    	});
    
    	// Support: IE<9
    	support.getElementsByClassName = rnative.test( document.getElementsByClassName );
    
    	// Support: IE<10
    	// Check if getElementById returns elements by name
    	// The broken getElementById methods don't pick up programatically-set names,
    	// so use a roundabout getElementsByName test
    	support.getById = assert(function( div ) {
    		docElem.appendChild( div ).id = expando;
    		return !document.getElementsByName || !document.getElementsByName( expando ).length;
    	});
    
    	// ID find and filter
    	if ( support.getById ) {
    		Expr.find["ID"] = function( id, context ) {
    			if ( typeof context.getElementById !== "undefined" && documentIsHTML ) {
    				var m = context.getElementById( id );
    				return m ? [ m ] : [];
    			}
    		};
    		Expr.filter["ID"] = function( id ) {
    			var attrId = id.replace( runescape, funescape );
    			return function( elem ) {
    				return elem.getAttribute("id") === attrId;
    			};
    		};
    	} else {
    		// Support: IE6/7
    		// getElementById is not reliable as a find shortcut
    		delete Expr.find["ID"];
    
    		Expr.filter["ID"] =  function( id ) {
    			var attrId = id.replace( runescape, funescape );
    			return function( elem ) {
    				var node = typeof elem.getAttributeNode !== "undefined" &&
    					elem.getAttributeNode("id");
    				return node && node.value === attrId;
    			};
    		};
    	}
    
    	// Tag
    	Expr.find["TAG"] = support.getElementsByTagName ?
    		function( tag, context ) {
    			if ( typeof context.getElementsByTagName !== "undefined" ) {
    				return context.getElementsByTagName( tag );
    
    			// DocumentFragment nodes don't have gEBTN
    			} else if ( support.qsa ) {
    				return context.querySelectorAll( tag );
    			}
    		} :
    
    		function( tag, context ) {
    			var elem,
    				tmp = [],
    				i = 0,
    				// By happy coincidence, a (broken) gEBTN appears on DocumentFragment nodes too
    				results = context.getElementsByTagName( tag );
    
    			// Filter out possible comments
    			if ( tag === "*" ) {
    				while ( (elem = results[i++]) ) {
    					if ( elem.nodeType === 1 ) {
    						tmp.push( elem );
    					}
    				}
    
    				return tmp;
    			}
    			return results;
    		};
    
    	// Class
    	Expr.find["CLASS"] = support.getElementsByClassName && function( className, context ) {
    		if ( typeof context.getElementsByClassName !== "undefined" && documentIsHTML ) {
    			return context.getElementsByClassName( className );
    		}
    	};
    
    	/* QSA/matchesSelector
    	---------------------------------------------------------------------- */
    
    	// QSA and matchesSelector support
    
    	// matchesSelector(:active) reports false when true (IE9/Opera 11.5)
    	rbuggyMatches = [];
    
    	// qSa(:focus) reports false when true (Chrome 21)
    	// We allow this because of a bug in IE8/9 that throws an error
    	// whenever `document.activeElement` is accessed on an iframe
    	// So, we allow :focus to pass through QSA all the time to avoid the IE error
    	// See http://bugs.jquery.com/ticket/13378
    	rbuggyQSA = [];
    
    	if ( (support.qsa = rnative.test( document.querySelectorAll )) ) {
    		// Build QSA regex
    		// Regex strategy adopted from Diego Perini
    		assert(function( div ) {
    			// Select is set to empty string on purpose
    			// This is to test IE's treatment of not explicitly
    			// setting a boolean content attribute,
    			// since its presence should be enough
    			// http://bugs.jquery.com/ticket/12359
    			docElem.appendChild( div ).innerHTML = "<a id='" + expando + "'></a>" +
    				"<select id='" + expando + "-\r\\' msallowcapture=''>" +
    				"<option selected=''></option></select>";
    
    			// Support: IE8, Opera 11-12.16
    			// Nothing should be selected when empty strings follow ^= or $= or *=
    			// The test attribute must be unknown in Opera but "safe" for WinRT
    			// http://msdn.microsoft.com/en-us/library/ie/hh465388.aspx#attribute_section
    			if ( div.querySelectorAll("[msallowcapture^='']").length ) {
    				rbuggyQSA.push( "[*^$]=" + whitespace + "*(?:''|\"\")" );
    			}
    
    			// Support: IE8
    			// Boolean attributes and "value" are not treated correctly
    			if ( !div.querySelectorAll("[selected]").length ) {
    				rbuggyQSA.push( "\\[" + whitespace + "*(?:value|" + booleans + ")" );
    			}
    
    			// Support: Chrome<29, Android<4.4, Safari<7.0+, iOS<7.0+, PhantomJS<1.9.8+
    			if ( !div.querySelectorAll( "[id~=" + expando + "-]" ).length ) {
    				rbuggyQSA.push("~=");
    			}
    
    			// Webkit/Opera - :checked should return selected option elements
    			// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
    			// IE8 throws error here and will not see later tests
    			if ( !div.querySelectorAll(":checked").length ) {
    				rbuggyQSA.push(":checked");
    			}
    
    			// Support: Safari 8+, iOS 8+
    			// https://bugs.webkit.org/show_bug.cgi?id=136851
    			// In-page `selector#id sibing-combinator selector` fails
    			if ( !div.querySelectorAll( "a#" + expando + "+*" ).length ) {
    				rbuggyQSA.push(".#.+[+~]");
    			}
    		});
    
    		assert(function( div ) {
    			// Support: Windows 8 Native Apps
    			// The type and name attributes are restricted during .innerHTML assignment
    			var input = document.createElement("input");
    			input.setAttribute( "type", "hidden" );
    			div.appendChild( input ).setAttribute( "name", "D" );
    
    			// Support: IE8
    			// Enforce case-sensitivity of name attribute
    			if ( div.querySelectorAll("[name=d]").length ) {
    				rbuggyQSA.push( "name" + whitespace + "*[*^$|!~]?=" );
    			}
    
    			// FF 3.5 - :enabled/:disabled and hidden elements (hidden elements are still enabled)
    			// IE8 throws error here and will not see later tests
    			if ( !div.querySelectorAll(":enabled").length ) {
    				rbuggyQSA.push( ":enabled", ":disabled" );
    			}
    
    			// Opera 10-11 does not throw on post-comma invalid pseudos
    			div.querySelectorAll("*,:x");
    			rbuggyQSA.push(",.*:");
    		});
    	}
    
    	if ( (support.matchesSelector = rnative.test( (matches = docElem.matches ||
    		docElem.webkitMatchesSelector ||
    		docElem.mozMatchesSelector ||
    		docElem.oMatchesSelector ||
    		docElem.msMatchesSelector) )) ) {
    
    		assert(function( div ) {
    			// Check to see if it's possible to do matchesSelector
    			// on a disconnected node (IE 9)
    			support.disconnectedMatch = matches.call( div, "div" );
    
    			// This should fail with an exception
    			// Gecko does not error, returns false instead
    			matches.call( div, "[s!='']:x" );
    			rbuggyMatches.push( "!=", pseudos );
    		});
    	}
    
    	rbuggyQSA = rbuggyQSA.length && new RegExp( rbuggyQSA.join("|") );
    	rbuggyMatches = rbuggyMatches.length && new RegExp( rbuggyMatches.join("|") );
    
    	/* Contains
    	---------------------------------------------------------------------- */
    	hasCompare = rnative.test( docElem.compareDocumentPosition );
    
    	// Element contains another
    	// Purposefully self-exclusive
    	// As in, an element does not contain itself
    	contains = hasCompare || rnative.test( docElem.contains ) ?
    		function( a, b ) {
    			var adown = a.nodeType === 9 ? a.documentElement : a,
    				bup = b && b.parentNode;
    			return a === bup || !!( bup && bup.nodeType === 1 && (
    				adown.contains ?
    					adown.contains( bup ) :
    					a.compareDocumentPosition && a.compareDocumentPosition( bup ) & 16
    			));
    		} :
    		function( a, b ) {
    			if ( b ) {
    				while ( (b = b.parentNode) ) {
    					if ( b === a ) {
    						return true;
    					}
    				}
    			}
    			return false;
    		};
    
    	/* Sorting
    	---------------------------------------------------------------------- */
    
    	// Document order sorting
    	sortOrder = hasCompare ?
    	function( a, b ) {
    
    		// Flag for duplicate removal
    		if ( a === b ) {
    			hasDuplicate = true;
    			return 0;
    		}
    
    		// Sort on method existence if only one input has compareDocumentPosition
    		var compare = !a.compareDocumentPosition - !b.compareDocumentPosition;
    		if ( compare ) {
    			return compare;
    		}
    
    		// Calculate position if both inputs belong to the same document
    		compare = ( a.ownerDocument || a ) === ( b.ownerDocument || b ) ?
    			a.compareDocumentPosition( b ) :
    
    			// Otherwise we know they are disconnected
    			1;
    
    		// Disconnected nodes
    		if ( compare & 1 ||
    			(!support.sortDetached && b.compareDocumentPosition( a ) === compare) ) {
    
    			// Choose the first element that is related to our preferred document
    			if ( a === document || a.ownerDocument === preferredDoc && contains(preferredDoc, a) ) {
    				return -1;
    			}
    			if ( b === document || b.ownerDocument === preferredDoc && contains(preferredDoc, b) ) {
    				return 1;
    			}
    
    			// Maintain original order
    			return sortInput ?
    				( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :
    				0;
    		}
    
    		return compare & 4 ? -1 : 1;
    	} :
    	function( a, b ) {
    		// Exit early if the nodes are identical
    		if ( a === b ) {
    			hasDuplicate = true;
    			return 0;
    		}
    
    		var cur,
    			i = 0,
    			aup = a.parentNode,
    			bup = b.parentNode,
    			ap = [ a ],
    			bp = [ b ];
    
    		// Parentless nodes are either documents or disconnected
    		if ( !aup || !bup ) {
    			return a === document ? -1 :
    				b === document ? 1 :
    				aup ? -1 :
    				bup ? 1 :
    				sortInput ?
    				( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :
    				0;
    
    		// If the nodes are siblings, we can do a quick check
    		} else if ( aup === bup ) {
    			return siblingCheck( a, b );
    		}
    
    		// Otherwise we need full lists of their ancestors for comparison
    		cur = a;
    		while ( (cur = cur.parentNode) ) {
    			ap.unshift( cur );
    		}
    		cur = b;
    		while ( (cur = cur.parentNode) ) {
    			bp.unshift( cur );
    		}
    
    		// Walk down the tree looking for a discrepancy
    		while ( ap[i] === bp[i] ) {
    			i++;
    		}
    
    		return i ?
    			// Do a sibling check if the nodes have a common ancestor
    			siblingCheck( ap[i], bp[i] ) :
    
    			// Otherwise nodes in our document sort first
    			ap[i] === preferredDoc ? -1 :
    			bp[i] === preferredDoc ? 1 :
    			0;
    	};
    
    	return document;
    };
    
    Sizzle.matches = function( expr, elements ) {
    	return Sizzle( expr, null, null, elements );
    };
    
    Sizzle.matchesSelector = function( elem, expr ) {
    	// Set document vars if needed
    	if ( ( elem.ownerDocument || elem ) !== document ) {
    		setDocument( elem );
    	}
    
    	// Make sure that attribute selectors are quoted
    	expr = expr.replace( rattributeQuotes, "='$1']" );
    
    	if ( support.matchesSelector && documentIsHTML &&
    		!compilerCache[ expr + " " ] &&
    		( !rbuggyMatches || !rbuggyMatches.test( expr ) ) &&
    		( !rbuggyQSA     || !rbuggyQSA.test( expr ) ) ) {
    
    		try {
    			var ret = matches.call( elem, expr );
    
    			// IE 9's matchesSelector returns false on disconnected nodes
    			if ( ret || support.disconnectedMatch ||
    					// As well, disconnected nodes are said to be in a document
    					// fragment in IE 9
    					elem.document && elem.document.nodeType !== 11 ) {
    				return ret;
    			}
    		} catch (e) {}
    	}
    
    	return Sizzle( expr, document, null, [ elem ] ).length > 0;
    };
    
    Sizzle.contains = function( context, elem ) {
    	// Set document vars if needed
    	if ( ( context.ownerDocument || context ) !== document ) {
    		setDocument( context );
    	}
    	return contains( context, elem );
    };
    
    Sizzle.attr = function( elem, name ) {
    	// Set document vars if needed
    	if ( ( elem.ownerDocument || elem ) !== document ) {
    		setDocument( elem );
    	}
    
    	var fn = Expr.attrHandle[ name.toLowerCase() ],
    		// Don't get fooled by Object.prototype properties (jQuery #13807)
    		val = fn && hasOwn.call( Expr.attrHandle, name.toLowerCase() ) ?
    			fn( elem, name, !documentIsHTML ) :
    			undefined;
    
    	return val !== undefined ?
    		val :
    		support.attributes || !documentIsHTML ?
    			elem.getAttribute( name ) :
    			(val = elem.getAttributeNode(name)) && val.specified ?
    				val.value :
    				null;
    };
    
    Sizzle.error = function( msg ) {
    	throw new Error( "Syntax error, unrecognized expression: " + msg );
    };
    
    /**
     * Document sorting and removing duplicates
     * @param {ArrayLike} results
     */
    Sizzle.uniqueSort = function( results ) {
    	var elem,
    		duplicates = [],
    		j = 0,
    		i = 0;
    
    	// Unless we *know* we can detect duplicates, assume their presence
    	hasDuplicate = !support.detectDuplicates;
    	sortInput = !support.sortStable && results.slice( 0 );
    	results.sort( sortOrder );
    
    	if ( hasDuplicate ) {
    		while ( (elem = results[i++]) ) {
    			if ( elem === results[ i ] ) {
    				j = duplicates.push( i );
    			}
    		}
    		while ( j-- ) {
    			results.splice( duplicates[ j ], 1 );
    		}
    	}
    
    	// Clear input after sorting to release objects
    	// See https://github.com/jquery/sizzle/pull/225
    	sortInput = null;
    
    	return results;
    };
    
    /**
     * Utility function for retrieving the text value of an array of DOM nodes
     * @param {Array|Element} elem
     */
    getText = Sizzle.getText = function( elem ) {
    	var node,
    		ret = "",
    		i = 0,
    		nodeType = elem.nodeType;
    
    	if ( !nodeType ) {
    		// If no nodeType, this is expected to be an array
    		while ( (node = elem[i++]) ) {
    			// Do not traverse comment nodes
    			ret += getText( node );
    		}
    	} else if ( nodeType === 1 || nodeType === 9 || nodeType === 11 ) {
    		// Use textContent for elements
    		// innerText usage removed for consistency of new lines (jQuery #11153)
    		if ( typeof elem.textContent === "string" ) {
    			return elem.textContent;
    		} else {
    			// Traverse its children
    			for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
    				ret += getText( elem );
    			}
    		}
    	} else if ( nodeType === 3 || nodeType === 4 ) {
    		return elem.nodeValue;
    	}
    	// Do not include comment or processing instruction nodes
    
    	return ret;
    };
    
    Expr = Sizzle.selectors = {
    
    	// Can be adjusted by the user
    	cacheLength: 50,
    
    	createPseudo: markFunction,
    
    	match: matchExpr,
    
    	attrHandle: {},
    
    	find: {},
    
    	relative: {
    		">": { dir: "parentNode", first: true },
    		" ": { dir: "parentNode" },
    		"+": { dir: "previousSibling", first: true },
    		"~": { dir: "previousSibling" }
    	},
    
    	preFilter: {
    		"ATTR": function( match ) {
    			match[1] = match[1].replace( runescape, funescape );
    
    			// Move the given value to match[3] whether quoted or unquoted
    			match[3] = ( match[3] || match[4] || match[5] || "" ).replace( runescape, funescape );
    
    			if ( match[2] === "~=" ) {
    				match[3] = " " + match[3] + " ";
    			}
    
    			return match.slice( 0, 4 );
    		},
    
    		"CHILD": function( match ) {
    			/* matches from matchExpr["CHILD"]
    				1 type (only|nth|...)
    				2 what (child|of-type)
    				3 argument (even|odd|\d*|\d*n([+-]\d+)?|...)
    				4 xn-component of xn+y argument ([+-]?\d*n|)
    				5 sign of xn-component
    				6 x of xn-component
    				7 sign of y-component
    				8 y of y-component
    			*/
    			match[1] = match[1].toLowerCase();
    
    			if ( match[1].slice( 0, 3 ) === "nth" ) {
    				// nth-* requires argument
    				if ( !match[3] ) {
    					Sizzle.error( match[0] );
    				}
    
    				// numeric x and y parameters for Expr.filter.CHILD
    				// remember that false/true cast respectively to 0/1
    				match[4] = +( match[4] ? match[5] + (match[6] || 1) : 2 * ( match[3] === "even" || match[3] === "odd" ) );
    				match[5] = +( ( match[7] + match[8] ) || match[3] === "odd" );
    
    			// other types prohibit arguments
    			} else if ( match[3] ) {
    				Sizzle.error( match[0] );
    			}
    
    			return match;
    		},
    
    		"PSEUDO": function( match ) {
    			var excess,
    				unquoted = !match[6] && match[2];
    
    			if ( matchExpr["CHILD"].test( match[0] ) ) {
    				return null;
    			}
    
    			// Accept quoted arguments as-is
    			if ( match[3] ) {
    				match[2] = match[4] || match[5] || "";
    
    			// Strip excess characters from unquoted arguments
    			} else if ( unquoted && rpseudo.test( unquoted ) &&
    				// Get excess from tokenize (recursively)
    				(excess = tokenize( unquoted, true )) &&
    				// advance to the next closing parenthesis
    				(excess = unquoted.indexOf( ")", unquoted.length - excess ) - unquoted.length) ) {
    
    				// excess is a negative index
    				match[0] = match[0].slice( 0, excess );
    				match[2] = unquoted.slice( 0, excess );
    			}
    
    			// Return only captures needed by the pseudo filter method (type and argument)
    			return match.slice( 0, 3 );
    		}
    	},
    
    	filter: {
    
    		"TAG": function( nodeNameSelector ) {
    			var nodeName = nodeNameSelector.replace( runescape, funescape ).toLowerCase();
    			return nodeNameSelector === "*" ?
    				function() { return true; } :
    				function( elem ) {
    					return elem.nodeName && elem.nodeName.toLowerCase() === nodeName;
    				};
    		},
    
    		"CLASS": function( className ) {
    			var pattern = classCache[ className + " " ];
    
    			return pattern ||
    				(pattern = new RegExp( "(^|" + whitespace + ")" + className + "(" + whitespace + "|$)" )) &&
    				classCache( className, function( elem ) {
    					return pattern.test( typeof elem.className === "string" && elem.className || typeof elem.getAttribute !== "undefined" && elem.getAttribute("class") || "" );
    				});
    		},
    
    		"ATTR": function( name, operator, check ) {
    			return function( elem ) {
    				var result = Sizzle.attr( elem, name );
    
    				if ( result == null ) {
    					return operator === "!=";
    				}
    				if ( !operator ) {
    					return true;
    				}
    
    				result += "";
    
    				return operator === "=" ? result === check :
    					operator === "!=" ? result !== check :
    					operator === "^=" ? check && result.indexOf( check ) === 0 :
    					operator === "*=" ? check && result.indexOf( check ) > -1 :
    					operator === "$=" ? check && result.slice( -check.length ) === check :
    					operator === "~=" ? ( " " + result.replace( rwhitespace, " " ) + " " ).indexOf( check ) > -1 :
    					operator === "|=" ? result === check || result.slice( 0, check.length + 1 ) === check + "-" :
    					false;
    			};
    		},
    
    		"CHILD": function( type, what, argument, first, last ) {
    			var simple = type.slice( 0, 3 ) !== "nth",
    				forward = type.slice( -4 ) !== "last",
    				ofType = what === "of-type";
    
    			return first === 1 && last === 0 ?
    
    				// Shortcut for :nth-*(n)
    				function( elem ) {
    					return !!elem.parentNode;
    				} :
    
    				function( elem, context, xml ) {
    					var cache, uniqueCache, outerCache, node, nodeIndex, start,
    						dir = simple !== forward ? "nextSibling" : "previousSibling",
    						parent = elem.parentNode,
    						name = ofType && elem.nodeName.toLowerCase(),
    						useCache = !xml && !ofType,
    						diff = false;
    
    					if ( parent ) {
    
    						// :(first|last|only)-(child|of-type)
    						if ( simple ) {
    							while ( dir ) {
    								node = elem;
    								while ( (node = node[ dir ]) ) {
    									if ( ofType ?
    										node.nodeName.toLowerCase() === name :
    										node.nodeType === 1 ) {
    
    										return false;
    									}
    								}
    								// Reverse direction for :only-* (if we haven't yet done so)
    								start = dir = type === "only" && !start && "nextSibling";
    							}
    							return true;
    						}
    
    						start = [ forward ? parent.firstChild : parent.lastChild ];
    
    						// non-xml :nth-child(...) stores cache data on `parent`
    						if ( forward && useCache ) {
    
    							// Seek `elem` from a previously-cached index
    
    							// ...in a gzip-friendly way
    							node = parent;
    							outerCache = node[ expando ] || (node[ expando ] = {});
    
    							// Support: IE <9 only
    							// Defend against cloned attroperties (jQuery gh-1709)
    							uniqueCache = outerCache[ node.uniqueID ] ||
    								(outerCache[ node.uniqueID ] = {});
    
    							cache = uniqueCache[ type ] || [];
    							nodeIndex = cache[ 0 ] === dirruns && cache[ 1 ];
    							diff = nodeIndex && cache[ 2 ];
    							node = nodeIndex && parent.childNodes[ nodeIndex ];
    
    							while ( (node = ++nodeIndex && node && node[ dir ] ||
    
    								// Fallback to seeking `elem` from the start
    								(diff = nodeIndex = 0) || start.pop()) ) {
    
    								// When found, cache indexes on `parent` and break
    								if ( node.nodeType === 1 && ++diff && node === elem ) {
    									uniqueCache[ type ] = [ dirruns, nodeIndex, diff ];
    									break;
    								}
    							}
    
    						} else {
    							// Use previously-cached element index if available
    							if ( useCache ) {
    								// ...in a gzip-friendly way
    								node = elem;
    								outerCache = node[ expando ] || (node[ expando ] = {});
    
    								// Support: IE <9 only
    								// Defend against cloned attroperties (jQuery gh-1709)
    								uniqueCache = outerCache[ node.uniqueID ] ||
    									(outerCache[ node.uniqueID ] = {});
    
    								cache = uniqueCache[ type ] || [];
    								nodeIndex = cache[ 0 ] === dirruns && cache[ 1 ];
    								diff = nodeIndex;
    							}
    
    							// xml :nth-child(...)
    							// or :nth-last-child(...) or :nth(-last)?-of-type(...)
    							if ( diff === false ) {
    								// Use the same loop as above to seek `elem` from the start
    								while ( (node = ++nodeIndex && node && node[ dir ] ||
    									(diff = nodeIndex = 0) || start.pop()) ) {
    
    									if ( ( ofType ?
    										node.nodeName.toLowerCase() === name :
    										node.nodeType === 1 ) &&
    										++diff ) {
    
    										// Cache the index of each encountered element
    										if ( useCache ) {
    											outerCache = node[ expando ] || (node[ expando ] = {});
    
    											// Support: IE <9 only
    											// Defend against cloned attroperties (jQuery gh-1709)
    											uniqueCache = outerCache[ node.uniqueID ] ||
    												(outerCache[ node.uniqueID ] = {});
    
    											uniqueCache[ type ] = [ dirruns, diff ];
    										}
    
    										if ( node === elem ) {
    											break;
    										}
    									}
    								}
    							}
    						}
    
    						// Incorporate the offset, then check against cycle size
    						diff -= last;
    						return diff === first || ( diff % first === 0 && diff / first >= 0 );
    					}
    				};
    		},
    
    		"PSEUDO": function( pseudo, argument ) {
    			// pseudo-class names are case-insensitive
    			// http://www.w3.org/TR/selectors/#pseudo-classes
    			// Prioritize by case sensitivity in case custom pseudos are added with uppercase letters
    			// Remember that setFilters inherits from pseudos
    			var args,
    				fn = Expr.pseudos[ pseudo ] || Expr.setFilters[ pseudo.toLowerCase() ] ||
    					Sizzle.error( "unsupported pseudo: " + pseudo );
    
    			// The user may use createPseudo to indicate that
    			// arguments are needed to create the filter function
    			// just as Sizzle does
    			if ( fn[ expando ] ) {
    				return fn( argument );
    			}
    
    			// But maintain support for old signatures
    			if ( fn.length > 1 ) {
    				args = [ pseudo, pseudo, "", argument ];
    				return Expr.setFilters.hasOwnProperty( pseudo.toLowerCase() ) ?
    					markFunction(function( seed, matches ) {
    						var idx,
    							matched = fn( seed, argument ),
    							i = matched.length;
    						while ( i-- ) {
    							idx = indexOf( seed, matched[i] );
    							seed[ idx ] = !( matches[ idx ] = matched[i] );
    						}
    					}) :
    					function( elem ) {
    						return fn( elem, 0, args );
    					};
    			}
    
    			return fn;
    		}
    	},
    
    	pseudos: {
    		// Potentially complex pseudos
    		"not": markFunction(function( selector ) {
    			// Trim the selector passed to compile
    			// to avoid treating leading and trailing
    			// spaces as combinators
    			var input = [],
    				results = [],
    				matcher = compile( selector.replace( rtrim, "$1" ) );
    
    			return matcher[ expando ] ?
    				markFunction(function( seed, matches, context, xml ) {
    					var elem,
    						unmatched = matcher( seed, null, xml, [] ),
    						i = seed.length;
    
    					// Match elements unmatched by `matcher`
    					while ( i-- ) {
    						if ( (elem = unmatched[i]) ) {
    							seed[i] = !(matches[i] = elem);
    						}
    					}
    				}) :
    				function( elem, context, xml ) {
    					input[0] = elem;
    					matcher( input, null, xml, results );
    					// Don't keep the element (issue #299)
    					input[0] = null;
    					return !results.pop();
    				};
    		}),
    
    		"has": markFunction(function( selector ) {
    			return function( elem ) {
    				return Sizzle( selector, elem ).length > 0;
    			};
    		}),
    
    		"contains": markFunction(function( text ) {
    			text = text.replace( runescape, funescape );
    			return function( elem ) {
    				return ( elem.textContent || elem.innerText || getText( elem ) ).indexOf( text ) > -1;
    			};
    		}),
    
    		// "Whether an element is represented by a :lang() selector
    		// is based solely on the element's language value
    		// being equal to the identifier C,
    		// or beginning with the identifier C immediately followed by "-".
    		// The matching of C against the element's language value is performed case-insensitively.
    		// The identifier C does not have to be a valid language name."
    		// http://www.w3.org/TR/selectors/#lang-pseudo
    		"lang": markFunction( function( lang ) {
    			// lang value must be a valid identifier
    			if ( !ridentifier.test(lang || "") ) {
    				Sizzle.error( "unsupported lang: " + lang );
    			}
    			lang = lang.replace( runescape, funescape ).toLowerCase();
    			return function( elem ) {
    				var elemLang;
    				do {
    					if ( (elemLang = documentIsHTML ?
    						elem.lang :
    						elem.getAttribute("xml:lang") || elem.getAttribute("lang")) ) {
    
    						elemLang = elemLang.toLowerCase();
    						return elemLang === lang || elemLang.indexOf( lang + "-" ) === 0;
    					}
    				} while ( (elem = elem.parentNode) && elem.nodeType === 1 );
    				return false;
    			};
    		}),
    
    		// Miscellaneous
    		"target": function( elem ) {
    			var hash = window.location && window.location.hash;
    			return hash && hash.slice( 1 ) === elem.id;
    		},
    
    		"root": function( elem ) {
    			return elem === docElem;
    		},
    
    		"focus": function( elem ) {
    			return elem === document.activeElement && (!document.hasFocus || document.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex);
    		},
    
    		// Boolean properties
    		"enabled": function( elem ) {
    			return elem.disabled === false;
    		},
    
    		"disabled": function( elem ) {
    			return elem.disabled === true;
    		},
    
    		"checked": function( elem ) {
    			// In CSS3, :checked should return both checked and selected elements
    			// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
    			var nodeName = elem.nodeName.toLowerCase();
    			return (nodeName === "input" && !!elem.checked) || (nodeName === "option" && !!elem.selected);
    		},
    
    		"selected": function( elem ) {
    			// Accessing this property makes selected-by-default
    			// options in Safari work properly
    			if ( elem.parentNode ) {
    				elem.parentNode.selectedIndex;
    			}
    
    			return elem.selected === true;
    		},
    
    		// Contents
    		"empty": function( elem ) {
    			// http://www.w3.org/TR/selectors/#empty-pseudo
    			// :empty is negated by element (1) or content nodes (text: 3; cdata: 4; entity ref: 5),
    			//   but not by others (comment: 8; processing instruction: 7; etc.)
    			// nodeType < 6 works because attributes (2) do not appear as children
    			for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
    				if ( elem.nodeType < 6 ) {
    					return false;
    				}
    			}
    			return true;
    		},
    
    		"parent": function( elem ) {
    			return !Expr.pseudos["empty"]( elem );
    		},
    
    		// Element/input types
    		"header": function( elem ) {
    			return rheader.test( elem.nodeName );
    		},
    
    		"input": function( elem ) {
    			return rinputs.test( elem.nodeName );
    		},
    
    		"button": function( elem ) {
    			var name = elem.nodeName.toLowerCase();
    			return name === "input" && elem.type === "button" || name === "button";
    		},
    
    		"text": function( elem ) {
    			var attr;
    			return elem.nodeName.toLowerCase() === "input" &&
    				elem.type === "text" &&
    
    				// Support: IE<8
    				// New HTML5 attribute values (e.g., "search") appear with elem.type === "text"
    				( (attr = elem.getAttribute("type")) == null || attr.toLowerCase() === "text" );
    		},
    
    		// Position-in-collection
    		"first": createPositionalPseudo(function() {
    			return [ 0 ];
    		}),
    
    		"last": createPositionalPseudo(function( matchIndexes, length ) {
    			return [ length - 1 ];
    		}),
    
    		"eq": createPositionalPseudo(function( matchIndexes, length, argument ) {
    			return [ argument < 0 ? argument + length : argument ];
    		}),
    
    		"even": createPositionalPseudo(function( matchIndexes, length ) {
    			var i = 0;
    			for ( ; i < length; i += 2 ) {
    				matchIndexes.push( i );
    			}
    			return matchIndexes;
    		}),
    
    		"odd": createPositionalPseudo(function( matchIndexes, length ) {
    			var i = 1;
    			for ( ; i < length; i += 2 ) {
    				matchIndexes.push( i );
    			}
    			return matchIndexes;
    		}),
    
    		"lt": createPositionalPseudo(function( matchIndexes, length, argument ) {
    			var i = argument < 0 ? argument + length : argument;
    			for ( ; --i >= 0; ) {
    				matchIndexes.push( i );
    			}
    			return matchIndexes;
    		}),
    
    		"gt": createPositionalPseudo(function( matchIndexes, length, argument ) {
    			var i = argument < 0 ? argument + length : argument;
    			for ( ; ++i < length; ) {
    				matchIndexes.push( i );
    			}
    			return matchIndexes;
    		})
    	}
    };
    
    Expr.pseudos["nth"] = Expr.pseudos["eq"];
    
    // Add button/input type pseudos
    for ( i in { radio: true, checkbox: true, file: true, password: true, image: true } ) {
    	Expr.pseudos[ i ] = createInputPseudo( i );
    }
    for ( i in { submit: true, reset: true } ) {
    	Expr.pseudos[ i ] = createButtonPseudo( i );
    }
    
    // Easy API for creating new setFilters
    function setFilters() {}
    setFilters.prototype = Expr.filters = Expr.pseudos;
    Expr.setFilters = new setFilters();
    
    tokenize = Sizzle.tokenize = function( selector, parseOnly ) {
    	var matched, match, tokens, type,
    		soFar, groups, preFilters,
    		cached = tokenCache[ selector + " " ];
    
    	if ( cached ) {
    		return parseOnly ? 0 : cached.slice( 0 );
    	}
    
    	soFar = selector;
    	groups = [];
    	preFilters = Expr.preFilter;
    
    	while ( soFar ) {
    
    		// Comma and first run
    		if ( !matched || (match = rcomma.exec( soFar )) ) {
    			if ( match ) {
    				// Don't consume trailing commas as valid
    				soFar = soFar.slice( match[0].length ) || soFar;
    			}
    			groups.push( (tokens = []) );
    		}
    
    		matched = false;
    
    		// Combinators
    		if ( (match = rcombinators.exec( soFar )) ) {
    			matched = match.shift();
    			tokens.push({
    				value: matched,
    				// Cast descendant combinators to space
    				type: match[0].replace( rtrim, " " )
    			});
    			soFar = soFar.slice( matched.length );
    		}
    
    		// Filters
    		for ( type in Expr.filter ) {
    			if ( (match = matchExpr[ type ].exec( soFar )) && (!preFilters[ type ] ||
    				(match = preFilters[ type ]( match ))) ) {
    				matched = match.shift();
    				tokens.push({
    					value: matched,
    					type: type,
    					matches: match
    				});
    				soFar = soFar.slice( matched.length );
    			}
    		}
    
    		if ( !matched ) {
    			break;
    		}
    	}
    
    	// Return the length of the invalid excess
    	// if we're just parsing
    	// Otherwise, throw an error or return tokens
    	return parseOnly ?
    		soFar.length :
    		soFar ?
    			Sizzle.error( selector ) :
    			// Cache the tokens
    			tokenCache( selector, groups ).slice( 0 );
    };
    
    function toSelector( tokens ) {
    	var i = 0,
    		len = tokens.length,
    		selector = "";
    	for ( ; i < len; i++ ) {
    		selector += tokens[i].value;
    	}
    	return selector;
    }
    
    function addCombinator( matcher, combinator, base ) {
    	var dir = combinator.dir,
    		checkNonElements = base && dir === "parentNode",
    		doneName = done++;
    
    	return combinator.first ?
    		// Check against closest ancestor/preceding element
    		function( elem, context, xml ) {
    			while ( (elem = elem[ dir ]) ) {
    				if ( elem.nodeType === 1 || checkNonElements ) {
    					return matcher( elem, context, xml );
    				}
    			}
    		} :
    
    		// Check against all ancestor/preceding elements
    		function( elem, context, xml ) {
    			var oldCache, uniqueCache, outerCache,
    				newCache = [ dirruns, doneName ];
    
    			// We can't set arbitrary data on XML nodes, so they don't benefit from combinator caching
    			if ( xml ) {
    				while ( (elem = elem[ dir ]) ) {
    					if ( elem.nodeType === 1 || checkNonElements ) {
    						if ( matcher( elem, context, xml ) ) {
    							return true;
    						}
    					}
    				}
    			} else {
    				while ( (elem = elem[ dir ]) ) {
    					if ( elem.nodeType === 1 || checkNonElements ) {
    						outerCache = elem[ expando ] || (elem[ expando ] = {});
    
    						// Support: IE <9 only
    						// Defend against cloned attroperties (jQuery gh-1709)
    						uniqueCache = outerCache[ elem.uniqueID ] || (outerCache[ elem.uniqueID ] = {});
    
    						if ( (oldCache = uniqueCache[ dir ]) &&
    							oldCache[ 0 ] === dirruns && oldCache[ 1 ] === doneName ) {
    
    							// Assign to newCache so results back-propagate to previous elements
    							return (newCache[ 2 ] = oldCache[ 2 ]);
    						} else {
    							// Reuse newcache so results back-propagate to previous elements
    							uniqueCache[ dir ] = newCache;
    
    							// A match means we're done; a fail means we have to keep checking
    							if ( (newCache[ 2 ] = matcher( elem, context, xml )) ) {
    								return true;
    							}
    						}
    					}
    				}
    			}
    		};
    }
    
    function elementMatcher( matchers ) {
    	return matchers.length > 1 ?
    		function( elem, context, xml ) {
    			var i = matchers.length;
    			while ( i-- ) {
    				if ( !matchers[i]( elem, context, xml ) ) {
    					return false;
    				}
    			}
    			return true;
    		} :
    		matchers[0];
    }
    
    function multipleContexts( selector, contexts, results ) {
    	var i = 0,
    		len = contexts.length;
    	for ( ; i < len; i++ ) {
    		Sizzle( selector, contexts[i], results );
    	}
    	return results;
    }
    
    function condense( unmatched, map, filter, context, xml ) {
    	var elem,
    		newUnmatched = [],
    		i = 0,
    		len = unmatched.length,
    		mapped = map != null;
    
    	for ( ; i < len; i++ ) {
    		if ( (elem = unmatched[i]) ) {
    			if ( !filter || filter( elem, context, xml ) ) {
    				newUnmatched.push( elem );
    				if ( mapped ) {
    					map.push( i );
    				}
    			}
    		}
    	}
    
    	return newUnmatched;
    }
    
    function setMatcher( preFilter, selector, matcher, postFilter, postFinder, postSelector ) {
    	if ( postFilter && !postFilter[ expando ] ) {
    		postFilter = setMatcher( postFilter );
    	}
    	if ( postFinder && !postFinder[ expando ] ) {
    		postFinder = setMatcher( postFinder, postSelector );
    	}
    	return markFunction(function( seed, results, context, xml ) {
    		var temp, i, elem,
    			preMap = [],
    			postMap = [],
    			preexisting = results.length,
    
    			// Get initial elements from seed or context
    			elems = seed || multipleContexts( selector || "*", context.nodeType ? [ context ] : context, [] ),
    
    			// Prefilter to get matcher input, preserving a map for seed-results synchronization
    			matcherIn = preFilter && ( seed || !selector ) ?
    				condense( elems, preMap, preFilter, context, xml ) :
    				elems,
    
    			matcherOut = matcher ?
    				// If we have a postFinder, or filtered seed, or non-seed postFilter or preexisting results,
    				postFinder || ( seed ? preFilter : preexisting || postFilter ) ?
    
    					// ...intermediate processing is necessary
    					[] :
    
    					// ...otherwise use results directly
    					results :
    				matcherIn;
    
    		// Find primary matches
    		if ( matcher ) {
    			matcher( matcherIn, matcherOut, context, xml );
    		}
    
    		// Apply postFilter
    		if ( postFilter ) {
    			temp = condense( matcherOut, postMap );
    			postFilter( temp, [], context, xml );
    
    			// Un-match failing elements by moving them back to matcherIn
    			i = temp.length;
    			while ( i-- ) {
    				if ( (elem = temp[i]) ) {
    					matcherOut[ postMap[i] ] = !(matcherIn[ postMap[i] ] = elem);
    				}
    			}
    		}
    
    		if ( seed ) {
    			if ( postFinder || preFilter ) {
    				if ( postFinder ) {
    					// Get the final matcherOut by condensing this intermediate into postFinder contexts
    					temp = [];
    					i = matcherOut.length;
    					while ( i-- ) {
    						if ( (elem = matcherOut[i]) ) {
    							// Restore matcherIn since elem is not yet a final match
    							temp.push( (matcherIn[i] = elem) );
    						}
    					}
    					postFinder( null, (matcherOut = []), temp, xml );
    				}
    
    				// Move matched elements from seed to results to keep them synchronized
    				i = matcherOut.length;
    				while ( i-- ) {
    					if ( (elem = matcherOut[i]) &&
    						(temp = postFinder ? indexOf( seed, elem ) : preMap[i]) > -1 ) {
    
    						seed[temp] = !(results[temp] = elem);
    					}
    				}
    			}
    
    		// Add elements to results, through postFinder if defined
    		} else {
    			matcherOut = condense(
    				matcherOut === results ?
    					matcherOut.splice( preexisting, matcherOut.length ) :
    					matcherOut
    			);
    			if ( postFinder ) {
    				postFinder( null, results, matcherOut, xml );
    			} else {
    				push.apply( results, matcherOut );
    			}
    		}
    	});
    }
    
    function matcherFromTokens( tokens ) {
    	var checkContext, matcher, j,
    		len = tokens.length,
    		leadingRelative = Expr.relative[ tokens[0].type ],
    		implicitRelative = leadingRelative || Expr.relative[" "],
    		i = leadingRelative ? 1 : 0,
    
    		// The foundational matcher ensures that elements are reachable from top-level context(s)
    		matchContext = addCombinator( function( elem ) {
    			return elem === checkContext;
    		}, implicitRelative, true ),
    		matchAnyContext = addCombinator( function( elem ) {
    			return indexOf( checkContext, elem ) > -1;
    		}, implicitRelative, true ),
    		matchers = [ function( elem, context, xml ) {
    			var ret = ( !leadingRelative && ( xml || context !== outermostContext ) ) || (
    				(checkContext = context).nodeType ?
    					matchContext( elem, context, xml ) :
    					matchAnyContext( elem, context, xml ) );
    			// Avoid hanging onto element (issue #299)
    			checkContext = null;
    			return ret;
    		} ];
    
    	for ( ; i < len; i++ ) {
    		if ( (matcher = Expr.relative[ tokens[i].type ]) ) {
    			matchers = [ addCombinator(elementMatcher( matchers ), matcher) ];
    		} else {
    			matcher = Expr.filter[ tokens[i].type ].apply( null, tokens[i].matches );
    
    			// Return special upon seeing a positional matcher
    			if ( matcher[ expando ] ) {
    				// Find the next relative operator (if any) for proper handling
    				j = ++i;
    				for ( ; j < len; j++ ) {
    					if ( Expr.relative[ tokens[j].type ] ) {
    						break;
    					}
    				}
    				return setMatcher(
    					i > 1 && elementMatcher( matchers ),
    					i > 1 && toSelector(
    						// If the preceding token was a descendant combinator, insert an implicit any-element `*`
    						tokens.slice( 0, i - 1 ).concat({ value: tokens[ i - 2 ].type === " " ? "*" : "" })
    					).replace( rtrim, "$1" ),
    					matcher,
    					i < j && matcherFromTokens( tokens.slice( i, j ) ),
    					j < len && matcherFromTokens( (tokens = tokens.slice( j )) ),
    					j < len && toSelector( tokens )
    				);
    			}
    			matchers.push( matcher );
    		}
    	}
    
    	return elementMatcher( matchers );
    }
    
    function matcherFromGroupMatchers( elementMatchers, setMatchers ) {
    	var bySet = setMatchers.length > 0,
    		byElement = elementMatchers.length > 0,
    		superMatcher = function( seed, context, xml, results, outermost ) {
    			var elem, j, matcher,
    				matchedCount = 0,
    				i = "0",
    				unmatched = seed && [],
    				setMatched = [],
    				contextBackup = outermostContext,
    				// We must always have either seed elements or outermost context
    				elems = seed || byElement && Expr.find["TAG"]( "*", outermost ),
    				// Use integer dirruns iff this is the outermost matcher
    				dirrunsUnique = (dirruns += contextBackup == null ? 1 : Math.random() || 0.1),
    				len = elems.length;
    
    			if ( outermost ) {
    				outermostContext = context === document || context || outermost;
    			}
    
    			// Add elements passing elementMatchers directly to results
    			// Support: IE<9, Safari
    			// Tolerate NodeList properties (IE: "length"; Safari: <number>) matching elements by id
    			for ( ; i !== len && (elem = elems[i]) != null; i++ ) {
    				if ( byElement && elem ) {
    					j = 0;
    					if ( !context && elem.ownerDocument !== document ) {
    						setDocument( elem );
    						xml = !documentIsHTML;
    					}
    					while ( (matcher = elementMatchers[j++]) ) {
    						if ( matcher( elem, context || document, xml) ) {
    							results.push( elem );
    							break;
    						}
    					}
    					if ( outermost ) {
    						dirruns = dirrunsUnique;
    					}
    				}
    
    				// Track unmatched elements for set filters
    				if ( bySet ) {
    					// They will have gone through all possible matchers
    					if ( (elem = !matcher && elem) ) {
    						matchedCount--;
    					}
    
    					// Lengthen the array for every element, matched or not
    					if ( seed ) {
    						unmatched.push( elem );
    					}
    				}
    			}
    
    			// `i` is now the count of elements visited above, and adding it to `matchedCount`
    			// makes the latter nonnegative.
    			matchedCount += i;
    
    			// Apply set filters to unmatched elements
    			// NOTE: This can be skipped if there are no unmatched elements (i.e., `matchedCount`
    			// equals `i`), unless we didn't visit _any_ elements in the above loop because we have
    			// no element matchers and no seed.
    			// Incrementing an initially-string "0" `i` allows `i` to remain a string only in that
    			// case, which will result in a "00" `matchedCount` that differs from `i` but is also
    			// numerically zero.
    			if ( bySet && i !== matchedCount ) {
    				j = 0;
    				while ( (matcher = setMatchers[j++]) ) {
    					matcher( unmatched, setMatched, context, xml );
    				}
    
    				if ( seed ) {
    					// Reintegrate element matches to eliminate the need for sorting
    					if ( matchedCount > 0 ) {
    						while ( i-- ) {
    							if ( !(unmatched[i] || setMatched[i]) ) {
    								setMatched[i] = pop.call( results );
    							}
    						}
    					}
    
    					// Discard index placeholder values to get only actual matches
    					setMatched = condense( setMatched );
    				}
    
    				// Add matches to results
    				push.apply( results, setMatched );
    
    				// Seedless set matches succeeding multiple successful matchers stipulate sorting
    				if ( outermost && !seed && setMatched.length > 0 &&
    					( matchedCount + setMatchers.length ) > 1 ) {
    
    					Sizzle.uniqueSort( results );
    				}
    			}
    
    			// Override manipulation of globals by nested matchers
    			if ( outermost ) {
    				dirruns = dirrunsUnique;
    				outermostContext = contextBackup;
    			}
    
    			return unmatched;
    		};
    
    	return bySet ?
    		markFunction( superMatcher ) :
    		superMatcher;
    }
    
    compile = Sizzle.compile = function( selector, match /* Internal Use Only */ ) {
    	var i,
    		setMatchers = [],
    		elementMatchers = [],
    		cached = compilerCache[ selector + " " ];
    
    	if ( !cached ) {
    		// Generate a function of recursive functions that can be used to check each element
    		if ( !match ) {
    			match = tokenize( selector );
    		}
    		i = match.length;
    		while ( i-- ) {
    			cached = matcherFromTokens( match[i] );
    			if ( cached[ expando ] ) {
    				setMatchers.push( cached );
    			} else {
    				elementMatchers.push( cached );
    			}
    		}
    
    		// Cache the compiled function
    		cached = compilerCache( selector, matcherFromGroupMatchers( elementMatchers, setMatchers ) );
    
    		// Save selector and tokenization
    		cached.selector = selector;
    	}
    	return cached;
    };
    
    /**
     * A low-level selection function that works with Sizzle's compiled
     *  selector functions
     * @param {String|Function} selector A selector or a pre-compiled
     *  selector function built with Sizzle.compile
     * @param {Element} context
     * @param {Array} [results]
     * @param {Array} [seed] A set of elements to match against
     */
    select = Sizzle.select = function( selector, context, results, seed ) {
    	var i, tokens, token, type, find,
    		compiled = typeof selector === "function" && selector,
    		match = !seed && tokenize( (selector = compiled.selector || selector) );
    
    	results = results || [];
    
    	// Try to minimize operations if there is only one selector in the list and no seed
    	// (the latter of which guarantees us context)
    	if ( match.length === 1 ) {
    
    		// Reduce context if the leading compound selector is an ID
    		tokens = match[0] = match[0].slice( 0 );
    		if ( tokens.length > 2 && (token = tokens[0]).type === "ID" &&
    				support.getById && context.nodeType === 9 && documentIsHTML &&
    				Expr.relative[ tokens[1].type ] ) {
    
    			context = ( Expr.find["ID"]( token.matches[0].replace(runescape, funescape), context ) || [] )[0];
    			if ( !context ) {
    				return results;
    
    			// Precompiled matchers will still verify ancestry, so step up a level
    			} else if ( compiled ) {
    				context = context.parentNode;
    			}
    
    			selector = selector.slice( tokens.shift().value.length );
    		}
    
    		// Fetch a seed set for right-to-left matching
    		i = matchExpr["needsContext"].test( selector ) ? 0 : tokens.length;
    		while ( i-- ) {
    			token = tokens[i];
    
    			// Abort if we hit a combinator
    			if ( Expr.relative[ (type = token.type) ] ) {
    				break;
    			}
    			if ( (find = Expr.find[ type ]) ) {
    				// Search, expanding context for leading sibling combinators
    				if ( (seed = find(
    					token.matches[0].replace( runescape, funescape ),
    					rsibling.test( tokens[0].type ) && testContext( context.parentNode ) || context
    				)) ) {
    
    					// If seed is empty or no tokens remain, we can return early
    					tokens.splice( i, 1 );
    					selector = seed.length && toSelector( tokens );
    					if ( !selector ) {
    						push.apply( results, seed );
    						return results;
    					}
    
    					break;
    				}
    			}
    		}
    	}
    
    	// Compile and execute a filtering function if one is not provided
    	// Provide `match` to avoid retokenization if we modified the selector above
    	( compiled || compile( selector, match ) )(
    		seed,
    		context,
    		!documentIsHTML,
    		results,
    		!context || rsibling.test( selector ) && testContext( context.parentNode ) || context
    	);
    	return results;
    };
    
    // One-time assignments
    
    // Sort stability
    support.sortStable = expando.split("").sort( sortOrder ).join("") === expando;
    
    // Support: Chrome 14-35+
    // Always assume duplicates if they aren't passed to the comparison function
    support.detectDuplicates = !!hasDuplicate;
    
    // Initialize against the default document
    setDocument();
    
    // Support: Webkit<537.32 - Safari 6.0.3/Chrome 25 (fixed in Chrome 27)
    // Detached nodes confoundingly follow *each other*
    support.sortDetached = assert(function( div1 ) {
    	// Should return 1, but returns 4 (following)
    	return div1.compareDocumentPosition( document.createElement("div") ) & 1;
    });
    
    // Support: IE<8
    // Prevent attribute/property "interpolation"
    // http://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx
    if ( !assert(function( div ) {
    	div.innerHTML = "<a href='#'></a>";
    	return div.firstChild.getAttribute("href") === "#" ;
    }) ) {
    	addHandle( "type|href|height|width", function( elem, name, isXML ) {
    		if ( !isXML ) {
    			return elem.getAttribute( name, name.toLowerCase() === "type" ? 1 : 2 );
    		}
    	});
    }
    
    // Support: IE<9
    // Use defaultValue in place of getAttribute("value")
    if ( !support.attributes || !assert(function( div ) {
    	div.innerHTML = "<input/>";
    	div.firstChild.setAttribute( "value", "" );
    	return div.firstChild.getAttribute( "value" ) === "";
    }) ) {
    	addHandle( "value", function( elem, name, isXML ) {
    		if ( !isXML && elem.nodeName.toLowerCase() === "input" ) {
    			return elem.defaultValue;
    		}
    	});
    }
    
    // Support: IE<9
    // Use getAttributeNode to fetch booleans when getAttribute lies
    if ( !assert(function( div ) {
    	return div.getAttribute("disabled") == null;
    }) ) {
    	addHandle( booleans, function( elem, name, isXML ) {
    		var val;
    		if ( !isXML ) {
    			return elem[ name ] === true ? name.toLowerCase() :
    					(val = elem.getAttributeNode( name )) && val.specified ?
    					val.value :
    				null;
    		}
    	});
    }
    
    return Sizzle;
    
    })( window );
    
    
    
    jQuery.find = Sizzle;
    jQuery.expr = Sizzle.selectors;
    jQuery.expr[ ":" ] = jQuery.expr.pseudos;
    jQuery.uniqueSort = jQuery.unique = Sizzle.uniqueSort;
    jQuery.text = Sizzle.getText;
    jQuery.isXMLDoc = Sizzle.isXML;
    jQuery.contains = Sizzle.contains;
    
    
    
    var dir = function( elem, dir, until ) {
    	var matched = [],
    		truncate = until !== undefined;
    
    	while ( ( elem = elem[ dir ] ) && elem.nodeType !== 9 ) {
    		if ( elem.nodeType === 1 ) {
    			if ( truncate && jQuery( elem ).is( until ) ) {
    				break;
    			}
    			matched.push( elem );
    		}
    	}
    	return matched;
    };
    
    
    var siblings = function( n, elem ) {
    	var matched = [];
    
    	for ( ; n; n = n.nextSibling ) {
    		if ( n.nodeType === 1 && n !== elem ) {
    			matched.push( n );
    		}
    	}
    
    	return matched;
    };
    
    
    var rneedsContext = jQuery.expr.match.needsContext;
    
    var rsingleTag = ( /^<([\w-]+)\s*\/?>(?:<\/\1>|)$/ );
    
    
    
    var risSimple = /^.[^:#\[\.,]*$/;
    
    // Implement the identical functionality for filter and not
    function winnow( elements, qualifier, not ) {
    	if ( jQuery.isFunction( qualifier ) ) {
    		return jQuery.grep( elements, function( elem, i ) {
    			/* jshint -W018 */
    			return !!qualifier.call( elem, i, elem ) !== not;
    		} );
    
    	}
    
    	if ( qualifier.nodeType ) {
    		return jQuery.grep( elements, function( elem ) {
    			return ( elem === qualifier ) !== not;
    		} );
    
    	}
    
    	if ( typeof qualifier === "string" ) {
    		if ( risSimple.test( qualifier ) ) {
    			return jQuery.filter( qualifier, elements, not );
    		}
    
    		qualifier = jQuery.filter( qualifier, elements );
    	}
    
    	return jQuery.grep( elements, function( elem ) {
    		return ( indexOf.call( qualifier, elem ) > -1 ) !== not;
    	} );
    }
    
    jQuery.filter = function( expr, elems, not ) {
    	var elem = elems[ 0 ];
    
    	if ( not ) {
    		expr = ":not(" + expr + ")";
    	}
    
    	return elems.length === 1 && elem.nodeType === 1 ?
    		jQuery.find.matchesSelector( elem, expr ) ? [ elem ] : [] :
    		jQuery.find.matches( expr, jQuery.grep( elems, function( elem ) {
    			return elem.nodeType === 1;
    		} ) );
    };
    
    jQuery.fn.extend( {
    	find: function( selector ) {
    		var i,
    			len = this.length,
    			ret = [],
    			self = this;
    
    		if ( typeof selector !== "string" ) {
    			return this.pushStack( jQuery( selector ).filter( function() {
    				for ( i = 0; i < len; i++ ) {
    					if ( jQuery.contains( self[ i ], this ) ) {
    						return true;
    					}
    				}
    			} ) );
    		}
    
    		for ( i = 0; i < len; i++ ) {
    			jQuery.find( selector, self[ i ], ret );
    		}
    
    		// Needed because $( selector, context ) becomes $( context ).find( selector )
    		ret = this.pushStack( len > 1 ? jQuery.unique( ret ) : ret );
    		ret.selector = this.selector ? this.selector + " " + selector : selector;
    		return ret;
    	},
    	filter: function( selector ) {
    		return this.pushStack( winnow( this, selector || [], false ) );
    	},
    	not: function( selector ) {
    		return this.pushStack( winnow( this, selector || [], true ) );
    	},
    	is: function( selector ) {
    		return !!winnow(
    			this,
    
    			// If this is a positional/relative selector, check membership in the returned set
    			// so $("p:first").is("p:last") won't return true for a doc with two "p".
    			typeof selector === "string" && rneedsContext.test( selector ) ?
    				jQuery( selector ) :
    				selector || [],
    			false
    		).length;
    	}
    } );
    
    
    // Initialize a jQuery object
    
    
    // A central reference to the root jQuery(document)
    var rootjQuery,
    
    	// A simple way to check for HTML strings
    	// Prioritize #id over <tag> to avoid XSS via location.hash (#9521)
    	// Strict HTML recognition (#11290: must start with <)
    	rquickExpr = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]*))$/,
    
    	init = jQuery.fn.init = function( selector, context, root ) {
    		var match, elem;
    
    		// HANDLE: $(""), $(null), $(undefined), $(false)
    		if ( !selector ) {
    			return this;
    		}
    
    		// Method init() accepts an alternate rootjQuery
    		// so migrate can support jQuery.sub (gh-2101)
    		root = root || rootjQuery;
    
    		// Handle HTML strings
    		if ( typeof selector === "string" ) {
    			if ( selector[ 0 ] === "<" &&
    				selector[ selector.length - 1 ] === ">" &&
    				selector.length >= 3 ) {
    
    				// Assume that strings that start and end with <> are HTML and skip the regex check
    				match = [ null, selector, null ];
    
    			} else {
    				match = rquickExpr.exec( selector );
    			}
    
    			// Match html or make sure no context is specified for #id
    			if ( match && ( match[ 1 ] || !context ) ) {
    
    				// HANDLE: $(html) -> $(array)
    				if ( match[ 1 ] ) {
    					context = context instanceof jQuery ? context[ 0 ] : context;
    
    					// Option to run scripts is true for back-compat
    					// Intentionally let the error be thrown if parseHTML is not present
    					jQuery.merge( this, jQuery.parseHTML(
    						match[ 1 ],
    						context && context.nodeType ? context.ownerDocument || context : document,
    						true
    					) );
    
    					// HANDLE: $(html, props)
    					if ( rsingleTag.test( match[ 1 ] ) && jQuery.isPlainObject( context ) ) {
    						for ( match in context ) {
    
    							// Properties of context are called as methods if possible
    							if ( jQuery.isFunction( this[ match ] ) ) {
    								this[ match ]( context[ match ] );
    
    							// ...and otherwise set as attributes
    							} else {
    								this.attr( match, context[ match ] );
    							}
    						}
    					}
    
    					return this;
    
    				// HANDLE: $(#id)
    				} else {
    					elem = document.getElementById( match[ 2 ] );
    
    					// Support: Blackberry 4.6
    					// gEBID returns nodes no longer in the document (#6963)
    					if ( elem && elem.parentNode ) {
    
    						// Inject the element directly into the jQuery object
    						this.length = 1;
    						this[ 0 ] = elem;
    					}
    
    					this.context = document;
    					this.selector = selector;
    					return this;
    				}
    
    			// HANDLE: $(expr, $(...))
    			} else if ( !context || context.jquery ) {
    				return ( context || root ).find( selector );
    
    			// HANDLE: $(expr, context)
    			// (which is just equivalent to: $(context).find(expr)
    			} else {
    				return this.constructor( context ).find( selector );
    			}
    
    		// HANDLE: $(DOMElement)
    		} else if ( selector.nodeType ) {
    			this.context = this[ 0 ] = selector;
    			this.length = 1;
    			return this;
    
    		// HANDLE: $(function)
    		// Shortcut for document ready
    		} else if ( jQuery.isFunction( selector ) ) {
    			return root.ready !== undefined ?
    				root.ready( selector ) :
    
    				// Execute immediately if ready is not present
    				selector( jQuery );
    		}
    
    		if ( selector.selector !== undefined ) {
    			this.selector = selector.selector;
    			this.context = selector.context;
    		}
    
    		return jQuery.makeArray( selector, this );
    	};
    
    // Give the init function the jQuery prototype for later instantiation
    init.prototype = jQuery.fn;
    
    // Initialize central reference
    rootjQuery = jQuery( document );
    
    
    var rparentsprev = /^(?:parents|prev(?:Until|All))/,
    
    	// Methods guaranteed to produce a unique set when starting from a unique set
    	guaranteedUnique = {
    		children: true,
    		contents: true,
    		next: true,
    		prev: true
    	};
    
    jQuery.fn.extend( {
    	has: function( target ) {
    		var targets = jQuery( target, this ),
    			l = targets.length;
    
    		return this.filter( function() {
    			var i = 0;
    			for ( ; i < l; i++ ) {
    				if ( jQuery.contains( this, targets[ i ] ) ) {
    					return true;
    				}
    			}
    		} );
    	},
    
    	closest: function( selectors, context ) {
    		var cur,
    			i = 0,
    			l = this.length,
    			matched = [],
    			pos = rneedsContext.test( selectors ) || typeof selectors !== "string" ?
    				jQuery( selectors, context || this.context ) :
    				0;
    
    		for ( ; i < l; i++ ) {
    			for ( cur = this[ i ]; cur && cur !== context; cur = cur.parentNode ) {
    
    				// Always skip document fragments
    				if ( cur.nodeType < 11 && ( pos ?
    					pos.index( cur ) > -1 :
    
    					// Don't pass non-elements to Sizzle
    					cur.nodeType === 1 &&
    						jQuery.find.matchesSelector( cur, selectors ) ) ) {
    
    					matched.push( cur );
    					break;
    				}
    			}
    		}
    
    		return this.pushStack( matched.length > 1 ? jQuery.uniqueSort( matched ) : matched );
    	},
    
    	// Determine the position of an element within the set
    	index: function( elem ) {
    
    		// No argument, return index in parent
    		if ( !elem ) {
    			return ( this[ 0 ] && this[ 0 ].parentNode ) ? this.first().prevAll().length : -1;
    		}
    
    		// Index in selector
    		if ( typeof elem === "string" ) {
    			return indexOf.call( jQuery( elem ), this[ 0 ] );
    		}
    
    		// Locate the position of the desired element
    		return indexOf.call( this,
    
    			// If it receives a jQuery object, the first element is used
    			elem.jquery ? elem[ 0 ] : elem
    		);
    	},
    
    	add: function( selector, context ) {
    		return this.pushStack(
    			jQuery.uniqueSort(
    				jQuery.merge( this.get(), jQuery( selector, context ) )
    			)
    		);
    	},
    
    	addBack: function( selector ) {
    		return this.add( selector == null ?
    			this.prevObject : this.prevObject.filter( selector )
    		);
    	}
    } );
    
    function sibling( cur, dir ) {
    	while ( ( cur = cur[ dir ] ) && cur.nodeType !== 1 ) {}
    	return cur;
    }
    
    jQuery.each( {
    	parent: function( elem ) {
    		var parent = elem.parentNode;
    		return parent && parent.nodeType !== 11 ? parent : null;
    	},
    	parents: function( elem ) {
    		return dir( elem, "parentNode" );
    	},
    	parentsUntil: function( elem, i, until ) {
    		return dir( elem, "parentNode", until );
    	},
    	next: function( elem ) {
    		return sibling( elem, "nextSibling" );
    	},
    	prev: function( elem ) {
    		return sibling( elem, "previousSibling" );
    	},
    	nextAll: function( elem ) {
    		return dir( elem, "nextSibling" );
    	},
    	prevAll: function( elem ) {
    		return dir( elem, "previousSibling" );
    	},
    	nextUntil: function( elem, i, until ) {
    		return dir( elem, "nextSibling", until );
    	},
    	prevUntil: function( elem, i, until ) {
    		return dir( elem, "previousSibling", until );
    	},
    	siblings: function( elem ) {
    		return siblings( ( elem.parentNode || {} ).firstChild, elem );
    	},
    	children: function( elem ) {
    		return siblings( elem.firstChild );
    	},
    	contents: function( elem ) {
    		return elem.contentDocument || jQuery.merge( [], elem.childNodes );
    	}
    }, function( name, fn ) {
    	jQuery.fn[ name ] = function( until, selector ) {
    		var matched = jQuery.map( this, fn, until );
    
    		if ( name.slice( -5 ) !== "Until" ) {
    			selector = until;
    		}
    
    		if ( selector && typeof selector === "string" ) {
    			matched = jQuery.filter( selector, matched );
    		}
    
    		if ( this.length > 1 ) {
    
    			// Remove duplicates
    			if ( !guaranteedUnique[ name ] ) {
    				jQuery.uniqueSort( matched );
    			}
    
    			// Reverse order for parents* and prev-derivatives
    			if ( rparentsprev.test( name ) ) {
    				matched.reverse();
    			}
    		}
    
    		return this.pushStack( matched );
    	};
    } );
    var rnotwhite = ( /\S+/g );
    
    
    
    // Convert String-formatted options into Object-formatted ones
    function createOptions( options ) {
    	var object = {};
    	jQuery.each( options.match( rnotwhite ) || [], function( _, flag ) {
    		object[ flag ] = true;
    	} );
    	return object;
    }
    
    /*
     * Create a callback list using the following parameters:
     *
     *	options: an optional list of space-separated options that will change how
     *			the callback list behaves or a more traditional option object
     *
     * By default a callback list will act like an event callback list and can be
     * "fired" multiple times.
     *
     * Possible options:
     *
     *	once:			will ensure the callback list can only be fired once (like a Deferred)
     *
     *	memory:			will keep track of previous values and will call any callback added
     *					after the list has been fired right away with the latest "memorized"
     *					values (like a Deferred)
     *
     *	unique:			will ensure a callback can only be added once (no duplicate in the list)
     *
     *	stopOnFalse:	interrupt callings when a callback returns false
     *
     */
    jQuery.Callbacks = function( options ) {
    
    	// Convert options from String-formatted to Object-formatted if needed
    	// (we check in cache first)
    	options = typeof options === "string" ?
    		createOptions( options ) :
    		jQuery.extend( {}, options );
    
    	var // Flag to know if list is currently firing
    		firing,
    
    		// Last fire value for non-forgettable lists
    		memory,
    
    		// Flag to know if list was already fired
    		fired,
    
    		// Flag to prevent firing
    		locked,
    
    		// Actual callback list
    		list = [],
    
    		// Queue of execution data for repeatable lists
    		queue = [],
    
    		// Index of currently firing callback (modified by add/remove as needed)
    		firingIndex = -1,
    
    		// Fire callbacks
    		fire = function() {
    
    			// Enforce single-firing
    			locked = options.once;
    
    			// Execute callbacks for all pending executions,
    			// respecting firingIndex overrides and runtime changes
    			fired = firing = true;
    			for ( ; queue.length; firingIndex = -1 ) {
    				memory = queue.shift();
    				while ( ++firingIndex < list.length ) {
    
    					// Run callback and check for early termination
    					if ( list[ firingIndex ].apply( memory[ 0 ], memory[ 1 ] ) === false &&
    						options.stopOnFalse ) {
    
    						// Jump to end and forget the data so .add doesn't re-fire
    						firingIndex = list.length;
    						memory = false;
    					}
    				}
    			}
    
    			// Forget the data if we're done with it
    			if ( !options.memory ) {
    				memory = false;
    			}
    
    			firing = false;
    
    			// Clean up if we're done firing for good
    			if ( locked ) {
    
    				// Keep an empty list if we have data for future add calls
    				if ( memory ) {
    					list = [];
    
    				// Otherwise, this object is spent
    				} else {
    					list = "";
    				}
    			}
    		},
    
    		// Actual Callbacks object
    		self = {
    
    			// Add a callback or a collection of callbacks to the list
    			add: function() {
    				if ( list ) {
    
    					// If we have memory from a past run, we should fire after adding
    					if ( memory && !firing ) {
    						firingIndex = list.length - 1;
    						queue.push( memory );
    					}
    
    					( function add( args ) {
    						jQuery.each( args, function( _, arg ) {
    							if ( jQuery.isFunction( arg ) ) {
    								if ( !options.unique || !self.has( arg ) ) {
    									list.push( arg );
    								}
    							} else if ( arg && arg.length && jQuery.type( arg ) !== "string" ) {
    
    								// Inspect recursively
    								add( arg );
    							}
    						} );
    					} )( arguments );
    
    					if ( memory && !firing ) {
    						fire();
    					}
    				}
    				return this;
    			},
    
    			// Remove a callback from the list
    			remove: function() {
    				jQuery.each( arguments, function( _, arg ) {
    					var index;
    					while ( ( index = jQuery.inArray( arg, list, index ) ) > -1 ) {
    						list.splice( index, 1 );
    
    						// Handle firing indexes
    						if ( index <= firingIndex ) {
    							firingIndex--;
    						}
    					}
    				} );
    				return this;
    			},
    
    			// Check if a given callback is in the list.
    			// If no argument is given, return whether or not list has callbacks attached.
    			has: function( fn ) {
    				return fn ?
    					jQuery.inArray( fn, list ) > -1 :
    					list.length > 0;
    			},
    
    			// Remove all callbacks from the list
    			empty: function() {
    				if ( list ) {
    					list = [];
    				}
    				return this;
    			},
    
    			// Disable .fire and .add
    			// Abort any current/pending executions
    			// Clear all callbacks and values
    			disable: function() {
    				locked = queue = [];
    				list = memory = "";
    				return this;
    			},
    			disabled: function() {
    				return !list;
    			},
    
    			// Disable .fire
    			// Also disable .add unless we have memory (since it would have no effect)
    			// Abort any pending executions
    			lock: function() {
    				locked = queue = [];
    				if ( !memory ) {
    					list = memory = "";
    				}
    				return this;
    			},
    			locked: function() {
    				return !!locked;
    			},
    
    			// Call all callbacks with the given context and arguments
    			fireWith: function( context, args ) {
    				if ( !locked ) {
    					args = args || [];
    					args = [ context, args.slice ? args.slice() : args ];
    					queue.push( args );
    					if ( !firing ) {
    						fire();
    					}
    				}
    				return this;
    			},
    
    			// Call all the callbacks with the given arguments
    			fire: function() {
    				self.fireWith( this, arguments );
    				return this;
    			},
    
    			// To know if the callbacks have already been called at least once
    			fired: function() {
    				return !!fired;
    			}
    		};
    
    	return self;
    };
    
    
    jQuery.extend( {
    
    	Deferred: function( func ) {
    		var tuples = [
    
    				// action, add listener, listener list, final state
    				[ "resolve", "done", jQuery.Callbacks( "once memory" ), "resolved" ],
    				[ "reject", "fail", jQuery.Callbacks( "once memory" ), "rejected" ],
    				[ "notify", "progress", jQuery.Callbacks( "memory" ) ]
    			],
    			state = "pending",
    			promise = {
    				state: function() {
    					return state;
    				},
    				always: function() {
    					deferred.done( arguments ).fail( arguments );
    					return this;
    				},
    				then: function( /* fnDone, fnFail, fnProgress */ ) {
    					var fns = arguments;
    					return jQuery.Deferred( function( newDefer ) {
    						jQuery.each( tuples, function( i, tuple ) {
    							var fn = jQuery.isFunction( fns[ i ] ) && fns[ i ];
    
    							// deferred[ done | fail | progress ] for forwarding actions to newDefer
    							deferred[ tuple[ 1 ] ]( function() {
    								var returned = fn && fn.apply( this, arguments );
    								if ( returned && jQuery.isFunction( returned.promise ) ) {
    									returned.promise()
    										.progress( newDefer.notify )
    										.done( newDefer.resolve )
    										.fail( newDefer.reject );
    								} else {
    									newDefer[ tuple[ 0 ] + "With" ](
    										this === promise ? newDefer.promise() : this,
    										fn ? [ returned ] : arguments
    									);
    								}
    							} );
    						} );
    						fns = null;
    					} ).promise();
    				},
    
    				// Get a promise for this deferred
    				// If obj is provided, the promise aspect is added to the object
    				promise: function( obj ) {
    					return obj != null ? jQuery.extend( obj, promise ) : promise;
    				}
    			},
    			deferred = {};
    
    		// Keep pipe for back-compat
    		promise.pipe = promise.then;
    
    		// Add list-specific methods
    		jQuery.each( tuples, function( i, tuple ) {
    			var list = tuple[ 2 ],
    				stateString = tuple[ 3 ];
    
    			// promise[ done | fail | progress ] = list.add
    			promise[ tuple[ 1 ] ] = list.add;
    
    			// Handle state
    			if ( stateString ) {
    				list.add( function() {
    
    					// state = [ resolved | rejected ]
    					state = stateString;
    
    				// [ reject_list | resolve_list ].disable; progress_list.lock
    				}, tuples[ i ^ 1 ][ 2 ].disable, tuples[ 2 ][ 2 ].lock );
    			}
    
    			// deferred[ resolve | reject | notify ]
    			deferred[ tuple[ 0 ] ] = function() {
    				deferred[ tuple[ 0 ] + "With" ]( this === deferred ? promise : this, arguments );
    				return this;
    			};
    			deferred[ tuple[ 0 ] + "With" ] = list.fireWith;
    		} );
    
    		// Make the deferred a promise
    		promise.promise( deferred );
    
    		// Call given func if any
    		if ( func ) {
    			func.call( deferred, deferred );
    		}
    
    		// All done!
    		return deferred;
    	},
    
    	// Deferred helper
    	when: function( subordinate /* , ..., subordinateN */ ) {
    		var i = 0,
    			resolveValues = slice.call( arguments ),
    			length = resolveValues.length,
    
    			// the count of uncompleted subordinates
    			remaining = length !== 1 ||
    				( subordinate && jQuery.isFunction( subordinate.promise ) ) ? length : 0,
    
    			// the master Deferred.
    			// If resolveValues consist of only a single Deferred, just use that.
    			deferred = remaining === 1 ? subordinate : jQuery.Deferred(),
    
    			// Update function for both resolve and progress values
    			updateFunc = function( i, contexts, values ) {
    				return function( value ) {
    					contexts[ i ] = this;
    					values[ i ] = arguments.length > 1 ? slice.call( arguments ) : value;
    					if ( values === progressValues ) {
    						deferred.notifyWith( contexts, values );
    					} else if ( !( --remaining ) ) {
    						deferred.resolveWith( contexts, values );
    					}
    				};
    			},
    
    			progressValues, progressContexts, resolveContexts;
    
    		// Add listeners to Deferred subordinates; treat others as resolved
    		if ( length > 1 ) {
    			progressValues = new Array( length );
    			progressContexts = new Array( length );
    			resolveContexts = new Array( length );
    			for ( ; i < length; i++ ) {
    				if ( resolveValues[ i ] && jQuery.isFunction( resolveValues[ i ].promise ) ) {
    					resolveValues[ i ].promise()
    						.progress( updateFunc( i, progressContexts, progressValues ) )
    						.done( updateFunc( i, resolveContexts, resolveValues ) )
    						.fail( deferred.reject );
    				} else {
    					--remaining;
    				}
    			}
    		}
    
    		// If we're not waiting on anything, resolve the master
    		if ( !remaining ) {
    			deferred.resolveWith( resolveContexts, resolveValues );
    		}
    
    		return deferred.promise();
    	}
    } );
    
    
    // The deferred used on DOM ready
    var readyList;
    
    jQuery.fn.ready = function( fn ) {
    
    	// Add the callback
    	jQuery.ready.promise().done( fn );
    
    	return this;
    };
    
    jQuery.extend( {
    
    	// Is the DOM ready to be used? Set to true once it occurs.
    	isReady: false,
    
    	// A counter to track how many items to wait for before
    	// the ready event fires. See #6781
    	readyWait: 1,
    
    	// Hold (or release) the ready event
    	holdReady: function( hold ) {
    		if ( hold ) {
    			jQuery.readyWait++;
    		} else {
    			jQuery.ready( true );
    		}
    	},
    
    	// Handle when the DOM is ready
    	ready: function( wait ) {
    
    		// Abort if there are pending holds or we're already ready
    		if ( wait === true ? --jQuery.readyWait : jQuery.isReady ) {
    			return;
    		}
    
    		// Remember that the DOM is ready
    		jQuery.isReady = true;
    
    		// If a normal DOM Ready event fired, decrement, and wait if need be
    		if ( wait !== true && --jQuery.readyWait > 0 ) {
    			return;
    		}
    
    		// If there are functions bound, to execute
    		readyList.resolveWith( document, [ jQuery ] );
    
    		// Trigger any bound ready events
    		if ( jQuery.fn.triggerHandler ) {
    			jQuery( document ).triggerHandler( "ready" );
    			jQuery( document ).off( "ready" );
    		}
    	}
    } );
    
    /**
     * The ready event handler and self cleanup method
     */
    function completed() {
    	document.removeEventListener( "DOMContentLoaded", completed );
    	window.removeEventListener( "load", completed );
    	jQuery.ready();
    }
    
    jQuery.ready.promise = function( obj ) {
    	if ( !readyList ) {
    
    		readyList = jQuery.Deferred();
    
    		// Catch cases where $(document).ready() is called
    		// after the browser event has already occurred.
    		// Support: IE9-10 only
    		// Older IE sometimes signals "interactive" too soon
    		if ( document.readyState === "complete" ||
    			( document.readyState !== "loading" && !document.documentElement.doScroll ) ) {
    
    			// Handle it asynchronously to allow scripts the opportunity to delay ready
    			window.setTimeout( jQuery.ready );
    
    		} else {
    
    			// Use the handy event callback
    			document.addEventListener( "DOMContentLoaded", completed );
    
    			// A fallback to window.onload, that will always work
    			window.addEventListener( "load", completed );
    		}
    	}
    	return readyList.promise( obj );
    };
    
    // Kick off the DOM ready check even if the user does not
    jQuery.ready.promise();
    
    
    
    
    // Multifunctional method to get and set values of a collection
    // The value/s can optionally be executed if it's a function
    var access = function( elems, fn, key, value, chainable, emptyGet, raw ) {
    	var i = 0,
    		len = elems.length,
    		bulk = key == null;
    
    	// Sets many values
    	if ( jQuery.type( key ) === "object" ) {
    		chainable = true;
    		for ( i in key ) {
    			access( elems, fn, i, key[ i ], true, emptyGet, raw );
    		}
    
    	// Sets one value
    	} else if ( value !== undefined ) {
    		chainable = true;
    
    		if ( !jQuery.isFunction( value ) ) {
    			raw = true;
    		}
    
    		if ( bulk ) {
    
    			// Bulk operations run against the entire set
    			if ( raw ) {
    				fn.call( elems, value );
    				fn = null;
    
    			// ...except when executing function values
    			} else {
    				bulk = fn;
    				fn = function( elem, key, value ) {
    					return bulk.call( jQuery( elem ), value );
    				};
    			}
    		}
    
    		if ( fn ) {
    			for ( ; i < len; i++ ) {
    				fn(
    					elems[ i ], key, raw ?
    					value :
    					value.call( elems[ i ], i, fn( elems[ i ], key ) )
    				);
    			}
    		}
    	}
    
    	return chainable ?
    		elems :
    
    		// Gets
    		bulk ?
    			fn.call( elems ) :
    			len ? fn( elems[ 0 ], key ) : emptyGet;
    };
    var acceptData = function( owner ) {
    
    	// Accepts only:
    	//  - Node
    	//    - Node.ELEMENT_NODE
    	//    - Node.DOCUMENT_NODE
    	//  - Object
    	//    - Any
    	/* jshint -W018 */
    	return owner.nodeType === 1 || owner.nodeType === 9 || !( +owner.nodeType );
    };
    
    
    
    
    function Data() {
    	this.expando = jQuery.expando + Data.uid++;
    }
    
    Data.uid = 1;
    
    Data.prototype = {
    
    	register: function( owner, initial ) {
    		var value = initial || {};
    
    		// If it is a node unlikely to be stringify-ed or looped over
    		// use plain assignment
    		if ( owner.nodeType ) {
    			owner[ this.expando ] = value;
    
    		// Otherwise secure it in a non-enumerable, non-writable property
    		// configurability must be true to allow the property to be
    		// deleted with the delete operator
    		} else {
    			Object.defineProperty( owner, this.expando, {
    				value: value,
    				writable: true,
    				configurable: true
    			} );
    		}
    		return owner[ this.expando ];
    	},
    	cache: function( owner ) {
    
    		// We can accept data for non-element nodes in modern browsers,
    		// but we should not, see #8335.
    		// Always return an empty object.
    		if ( !acceptData( owner ) ) {
    			return {};
    		}
    
    		// Check if the owner object already has a cache
    		var value = owner[ this.expando ];
    
    		// If not, create one
    		if ( !value ) {
    			value = {};
    
    			// We can accept data for non-element nodes in modern browsers,
    			// but we should not, see #8335.
    			// Always return an empty object.
    			if ( acceptData( owner ) ) {
    
    				// If it is a node unlikely to be stringify-ed or looped over
    				// use plain assignment
    				if ( owner.nodeType ) {
    					owner[ this.expando ] = value;
    
    				// Otherwise secure it in a non-enumerable property
    				// configurable must be true to allow the property to be
    				// deleted when data is removed
    				} else {
    					Object.defineProperty( owner, this.expando, {
    						value: value,
    						configurable: true
    					} );
    				}
    			}
    		}
    
    		return value;
    	},
    	set: function( owner, data, value ) {
    		var prop,
    			cache = this.cache( owner );
    
    		// Handle: [ owner, key, value ] args
    		if ( typeof data === "string" ) {
    			cache[ data ] = value;
    
    		// Handle: [ owner, { properties } ] args
    		} else {
    
    			// Copy the properties one-by-one to the cache object
    			for ( prop in data ) {
    				cache[ prop ] = data[ prop ];
    			}
    		}
    		return cache;
    	},
    	get: function( owner, key ) {
    		return key === undefined ?
    			this.cache( owner ) :
    			owner[ this.expando ] && owner[ this.expando ][ key ];
    	},
    	access: function( owner, key, value ) {
    		var stored;
    
    		// In cases where either:
    		//
    		//   1. No key was specified
    		//   2. A string key was specified, but no value provided
    		//
    		// Take the "read" path and allow the get method to determine
    		// which value to return, respectively either:
    		//
    		//   1. The entire cache object
    		//   2. The data stored at the key
    		//
    		if ( key === undefined ||
    				( ( key && typeof key === "string" ) && value === undefined ) ) {
    
    			stored = this.get( owner, key );
    
    			return stored !== undefined ?
    				stored : this.get( owner, jQuery.camelCase( key ) );
    		}
    
    		// When the key is not a string, or both a key and value
    		// are specified, set or extend (existing objects) with either:
    		//
    		//   1. An object of properties
    		//   2. A key and value
    		//
    		this.set( owner, key, value );
    
    		// Since the "set" path can have two possible entry points
    		// return the expected data based on which path was taken[*]
    		return value !== undefined ? value : key;
    	},
    	remove: function( owner, key ) {
    		var i, name, camel,
    			cache = owner[ this.expando ];
    
    		if ( cache === undefined ) {
    			return;
    		}
    
    		if ( key === undefined ) {
    			this.register( owner );
    
    		} else {
    
    			// Support array or space separated string of keys
    			if ( jQuery.isArray( key ) ) {
    
    				// If "name" is an array of keys...
    				// When data is initially created, via ("key", "val") signature,
    				// keys will be converted to camelCase.
    				// Since there is no way to tell _how_ a key was added, remove
    				// both plain key and camelCase key. #12786
    				// This will only penalize the array argument path.
    				name = key.concat( key.map( jQuery.camelCase ) );
    			} else {
    				camel = jQuery.camelCase( key );
    
    				// Try the string as a key before any manipulation
    				if ( key in cache ) {
    					name = [ key, camel ];
    				} else {
    
    					// If a key with the spaces exists, use it.
    					// Otherwise, create an array by matching non-whitespace
    					name = camel;
    					name = name in cache ?
    						[ name ] : ( name.match( rnotwhite ) || [] );
    				}
    			}
    
    			i = name.length;
    
    			while ( i-- ) {
    				delete cache[ name[ i ] ];
    			}
    		}
    
    		// Remove the expando if there's no more data
    		if ( key === undefined || jQuery.isEmptyObject( cache ) ) {
    
    			// Support: Chrome <= 35-45+
    			// Webkit & Blink performance suffers when deleting properties
    			// from DOM nodes, so set to undefined instead
    			// https://code.google.com/p/chromium/issues/detail?id=378607
    			if ( owner.nodeType ) {
    				owner[ this.expando ] = undefined;
    			} else {
    				delete owner[ this.expando ];
    			}
    		}
    	},
    	hasData: function( owner ) {
    		var cache = owner[ this.expando ];
    		return cache !== undefined && !jQuery.isEmptyObject( cache );
    	}
    };
    var dataPriv = new Data();
    
    var dataUser = new Data();
    
    
    
    //	Implementation Summary
    //
    //	1. Enforce API surface and semantic compatibility with 1.9.x branch
    //	2. Improve the module's maintainability by reducing the storage
    //		paths to a single mechanism.
    //	3. Use the same single mechanism to support "private" and "user" data.
    //	4. _Never_ expose "private" data to user code (TODO: Drop _data, _removeData)
    //	5. Avoid exposing implementation details on user objects (eg. expando properties)
    //	6. Provide a clear path for implementation upgrade to WeakMap in 2014
    
    var rbrace = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,
    	rmultiDash = /[A-Z]/g;
    
    function dataAttr( elem, key, data ) {
    	var name;
    
    	// If nothing was found internally, try to fetch any
    	// data from the HTML5 data-* attribute
    	if ( data === undefined && elem.nodeType === 1 ) {
    		name = "data-" + key.replace( rmultiDash, "-$&" ).toLowerCase();
    		data = elem.getAttribute( name );
    
    		if ( typeof data === "string" ) {
    			try {
    				data = data === "true" ? true :
    					data === "false" ? false :
    					data === "null" ? null :
    
    					// Only convert to a number if it doesn't change the string
    					+data + "" === data ? +data :
    					rbrace.test( data ) ? jQuery.parseJSON( data ) :
    					data;
    			} catch ( e ) {}
    
    			// Make sure we set the data so it isn't changed later
    			dataUser.set( elem, key, data );
    		} else {
    			data = undefined;
    		}
    	}
    	return data;
    }
    
    jQuery.extend( {
    	hasData: function( elem ) {
    		return dataUser.hasData( elem ) || dataPriv.hasData( elem );
    	},
    
    	data: function( elem, name, data ) {
    		return dataUser.access( elem, name, data );
    	},
    
    	removeData: function( elem, name ) {
    		dataUser.remove( elem, name );
    	},
    
    	// TODO: Now that all calls to _data and _removeData have been replaced
    	// with direct calls to dataPriv methods, these can be deprecated.
    	_data: function( elem, name, data ) {
    		return dataPriv.access( elem, name, data );
    	},
    
    	_removeData: function( elem, name ) {
    		dataPriv.remove( elem, name );
    	}
    } );
    
    jQuery.fn.extend( {
    	data: function( key, value ) {
    		var i, name, data,
    			elem = this[ 0 ],
    			attrs = elem && elem.attributes;
    
    		// Gets all values
    		if ( key === undefined ) {
    			if ( this.length ) {
    				data = dataUser.get( elem );
    
    				if ( elem.nodeType === 1 && !dataPriv.get( elem, "hasDataAttrs" ) ) {
    					i = attrs.length;
    					while ( i-- ) {
    
    						// Support: IE11+
    						// The attrs elements can be null (#14894)
    						if ( attrs[ i ] ) {
    							name = attrs[ i ].name;
    							if ( name.indexOf( "data-" ) === 0 ) {
    								name = jQuery.camelCase( name.slice( 5 ) );
    								dataAttr( elem, name, data[ name ] );
    							}
    						}
    					}
    					dataPriv.set( elem, "hasDataAttrs", true );
    				}
    			}
    
    			return data;
    		}
    
    		// Sets multiple values
    		if ( typeof key === "object" ) {
    			return this.each( function() {
    				dataUser.set( this, key );
    			} );
    		}
    
    		return access( this, function( value ) {
    			var data, camelKey;
    
    			// The calling jQuery object (element matches) is not empty
    			// (and therefore has an element appears at this[ 0 ]) and the
    			// `value` parameter was not undefined. An empty jQuery object
    			// will result in `undefined` for elem = this[ 0 ] which will
    			// throw an exception if an attempt to read a data cache is made.
    			if ( elem && value === undefined ) {
    
    				// Attempt to get data from the cache
    				// with the key as-is
    				data = dataUser.get( elem, key ) ||
    
    					// Try to find dashed key if it exists (gh-2779)
    					// This is for 2.2.x only
    					dataUser.get( elem, key.replace( rmultiDash, "-$&" ).toLowerCase() );
    
    				if ( data !== undefined ) {
    					return data;
    				}
    
    				camelKey = jQuery.camelCase( key );
    
    				// Attempt to get data from the cache
    				// with the key camelized
    				data = dataUser.get( elem, camelKey );
    				if ( data !== undefined ) {
    					return data;
    				}
    
    				// Attempt to "discover" the data in
    				// HTML5 custom data-* attrs
    				data = dataAttr( elem, camelKey, undefined );
    				if ( data !== undefined ) {
    					return data;
    				}
    
    				// We tried really hard, but the data doesn't exist.
    				return;
    			}
    
    			// Set the data...
    			camelKey = jQuery.camelCase( key );
    			this.each( function() {
    
    				// First, attempt to store a copy or reference of any
    				// data that might've been store with a camelCased key.
    				var data = dataUser.get( this, camelKey );
    
    				// For HTML5 data-* attribute interop, we have to
    				// store property names with dashes in a camelCase form.
    				// This might not apply to all properties...*
    				dataUser.set( this, camelKey, value );
    
    				// *... In the case of properties that might _actually_
    				// have dashes, we need to also store a copy of that
    				// unchanged property.
    				if ( key.indexOf( "-" ) > -1 && data !== undefined ) {
    					dataUser.set( this, key, value );
    				}
    			} );
    		}, null, value, arguments.length > 1, null, true );
    	},
    
    	removeData: function( key ) {
    		return this.each( function() {
    			dataUser.remove( this, key );
    		} );
    	}
    } );
    
    
    jQuery.extend( {
    	queue: function( elem, type, data ) {
    		var queue;
    
    		if ( elem ) {
    			type = ( type || "fx" ) + "queue";
    			queue = dataPriv.get( elem, type );
    
    			// Speed up dequeue by getting out quickly if this is just a lookup
    			if ( data ) {
    				if ( !queue || jQuery.isArray( data ) ) {
    					queue = dataPriv.access( elem, type, jQuery.makeArray( data ) );
    				} else {
    					queue.push( data );
    				}
    			}
    			return queue || [];
    		}
    	},
    
    	dequeue: function( elem, type ) {
    		type = type || "fx";
    
    		var queue = jQuery.queue( elem, type ),
    			startLength = queue.length,
    			fn = queue.shift(),
    			hooks = jQuery._queueHooks( elem, type ),
    			next = function() {
    				jQuery.dequeue( elem, type );
    			};
    
    		// If the fx queue is dequeued, always remove the progress sentinel
    		if ( fn === "inprogress" ) {
    			fn = queue.shift();
    			startLength--;
    		}
    
    		if ( fn ) {
    
    			// Add a progress sentinel to prevent the fx queue from being
    			// automatically dequeued
    			if ( type === "fx" ) {
    				queue.unshift( "inprogress" );
    			}
    
    			// Clear up the last queue stop function
    			delete hooks.stop;
    			fn.call( elem, next, hooks );
    		}
    
    		if ( !startLength && hooks ) {
    			hooks.empty.fire();
    		}
    	},
    
    	// Not public - generate a queueHooks object, or return the current one
    	_queueHooks: function( elem, type ) {
    		var key = type + "queueHooks";
    		return dataPriv.get( elem, key ) || dataPriv.access( elem, key, {
    			empty: jQuery.Callbacks( "once memory" ).add( function() {
    				dataPriv.remove( elem, [ type + "queue", key ] );
    			} )
    		} );
    	}
    } );
    
    jQuery.fn.extend( {
    	queue: function( type, data ) {
    		var setter = 2;
    
    		if ( typeof type !== "string" ) {
    			data = type;
    			type = "fx";
    			setter--;
    		}
    
    		if ( arguments.length < setter ) {
    			return jQuery.queue( this[ 0 ], type );
    		}
    
    		return data === undefined ?
    			this :
    			this.each( function() {
    				var queue = jQuery.queue( this, type, data );
    
    				// Ensure a hooks for this queue
    				jQuery._queueHooks( this, type );
    
    				if ( type === "fx" && queue[ 0 ] !== "inprogress" ) {
    					jQuery.dequeue( this, type );
    				}
    			} );
    	},
    	dequeue: function( type ) {
    		return this.each( function() {
    			jQuery.dequeue( this, type );
    		} );
    	},
    	clearQueue: function( type ) {
    		return this.queue( type || "fx", [] );
    	},
    
    	// Get a promise resolved when queues of a certain type
    	// are emptied (fx is the type by default)
    	promise: function( type, obj ) {
    		var tmp,
    			count = 1,
    			defer = jQuery.Deferred(),
    			elements = this,
    			i = this.length,
    			resolve = function() {
    				if ( !( --count ) ) {
    					defer.resolveWith( elements, [ elements ] );
    				}
    			};
    
    		if ( typeof type !== "string" ) {
    			obj = type;
    			type = undefined;
    		}
    		type = type || "fx";
    
    		while ( i-- ) {
    			tmp = dataPriv.get( elements[ i ], type + "queueHooks" );
    			if ( tmp && tmp.empty ) {
    				count++;
    				tmp.empty.add( resolve );
    			}
    		}
    		resolve();
    		return defer.promise( obj );
    	}
    } );
    var pnum = ( /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/ ).source;
    
    var rcssNum = new RegExp( "^(?:([+-])=|)(" + pnum + ")([a-z%]*)$", "i" );
    
    
    var cssExpand = [ "Top", "Right", "Bottom", "Left" ];
    
    var isHidden = function( elem, el ) {
    
    		// isHidden might be called from jQuery#filter function;
    		// in that case, element will be second argument
    		elem = el || elem;
    		return jQuery.css( elem, "display" ) === "none" ||
    			!jQuery.contains( elem.ownerDocument, elem );
    	};
    
    
    
    function adjustCSS( elem, prop, valueParts, tween ) {
    	var adjusted,
    		scale = 1,
    		maxIterations = 20,
    		currentValue = tween ?
    			function() { return tween.cur(); } :
    			function() { return jQuery.css( elem, prop, "" ); },
    		initial = currentValue(),
    		unit = valueParts && valueParts[ 3 ] || ( jQuery.cssNumber[ prop ] ? "" : "px" ),
    
    		// Starting value computation is required for potential unit mismatches
    		initialInUnit = ( jQuery.cssNumber[ prop ] || unit !== "px" && +initial ) &&
    			rcssNum.exec( jQuery.css( elem, prop ) );
    
    	if ( initialInUnit && initialInUnit[ 3 ] !== unit ) {
    
    		// Trust units reported by jQuery.css
    		unit = unit || initialInUnit[ 3 ];
    
    		// Make sure we update the tween properties later on
    		valueParts = valueParts || [];
    
    		// Iteratively approximate from a nonzero starting point
    		initialInUnit = +initial || 1;
    
    		do {
    
    			// If previous iteration zeroed out, double until we get *something*.
    			// Use string for doubling so we don't accidentally see scale as unchanged below
    			scale = scale || ".5";
    
    			// Adjust and apply
    			initialInUnit = initialInUnit / scale;
    			jQuery.style( elem, prop, initialInUnit + unit );
    
    		// Update scale, tolerating zero or NaN from tween.cur()
    		// Break the loop if scale is unchanged or perfect, or if we've just had enough.
    		} while (
    			scale !== ( scale = currentValue() / initial ) && scale !== 1 && --maxIterations
    		);
    	}
    
    	if ( valueParts ) {
    		initialInUnit = +initialInUnit || +initial || 0;
    
    		// Apply relative offset (+=/-=) if specified
    		adjusted = valueParts[ 1 ] ?
    			initialInUnit + ( valueParts[ 1 ] + 1 ) * valueParts[ 2 ] :
    			+valueParts[ 2 ];
    		if ( tween ) {
    			tween.unit = unit;
    			tween.start = initialInUnit;
    			tween.end = adjusted;
    		}
    	}
    	return adjusted;
    }
    var rcheckableType = ( /^(?:checkbox|radio)$/i );
    
    var rtagName = ( /<([\w:-]+)/ );
    
    var rscriptType = ( /^$|\/(?:java|ecma)script/i );
    
    
    
    // We have to close these tags to support XHTML (#13200)
    var wrapMap = {
    
    	// Support: IE9
    	option: [ 1, "<select multiple='multiple'>", "</select>" ],
    
    	// XHTML parsers do not magically insert elements in the
    	// same way that tag soup parsers do. So we cannot shorten
    	// this by omitting <tbody> or other required elements.
    	thead: [ 1, "<table>", "</table>" ],
    	col: [ 2, "<table><colgroup>", "</colgroup></table>" ],
    	tr: [ 2, "<table><tbody>", "</tbody></table>" ],
    	td: [ 3, "<table><tbody><tr>", "</tr></tbody></table>" ],
    
    	_default: [ 0, "", "" ]
    };
    
    // Support: IE9
    wrapMap.optgroup = wrapMap.option;
    
    wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
    wrapMap.th = wrapMap.td;
    
    
    function getAll( context, tag ) {
    
    	// Support: IE9-11+
    	// Use typeof to avoid zero-argument method invocation on host objects (#15151)
    	var ret = typeof context.getElementsByTagName !== "undefined" ?
    			context.getElementsByTagName( tag || "*" ) :
    			typeof context.querySelectorAll !== "undefined" ?
    				context.querySelectorAll( tag || "*" ) :
    			[];
    
    	return tag === undefined || tag && jQuery.nodeName( context, tag ) ?
    		jQuery.merge( [ context ], ret ) :
    		ret;
    }
    
    
    // Mark scripts as having already been evaluated
    function setGlobalEval( elems, refElements ) {
    	var i = 0,
    		l = elems.length;
    
    	for ( ; i < l; i++ ) {
    		dataPriv.set(
    			elems[ i ],
    			"globalEval",
    			!refElements || dataPriv.get( refElements[ i ], "globalEval" )
    		);
    	}
    }
    
    
    var rhtml = /<|&#?\w+;/;
    
    function buildFragment( elems, context, scripts, selection, ignored ) {
    	var elem, tmp, tag, wrap, contains, j,
    		fragment = context.createDocumentFragment(),
    		nodes = [],
    		i = 0,
    		l = elems.length;
    
    	for ( ; i < l; i++ ) {
    		elem = elems[ i ];
    
    		if ( elem || elem === 0 ) {
    
    			// Add nodes directly
    			if ( jQuery.type( elem ) === "object" ) {
    
    				// Support: Android<4.1, PhantomJS<2
    				// push.apply(_, arraylike) throws on ancient WebKit
    				jQuery.merge( nodes, elem.nodeType ? [ elem ] : elem );
    
    			// Convert non-html into a text node
    			} else if ( !rhtml.test( elem ) ) {
    				nodes.push( context.createTextNode( elem ) );
    
    			// Convert html into DOM nodes
    			} else {
    				tmp = tmp || fragment.appendChild( context.createElement( "div" ) );
    
    				// Deserialize a standard representation
    				tag = ( rtagName.exec( elem ) || [ "", "" ] )[ 1 ].toLowerCase();
    				wrap = wrapMap[ tag ] || wrapMap._default;
    				tmp.innerHTML = wrap[ 1 ] + jQuery.htmlPrefilter( elem ) + wrap[ 2 ];
    
    				// Descend through wrappers to the right content
    				j = wrap[ 0 ];
    				while ( j-- ) {
    					tmp = tmp.lastChild;
    				}
    
    				// Support: Android<4.1, PhantomJS<2
    				// push.apply(_, arraylike) throws on ancient WebKit
    				jQuery.merge( nodes, tmp.childNodes );
    
    				// Remember the top-level container
    				tmp = fragment.firstChild;
    
    				// Ensure the created nodes are orphaned (#12392)
    				tmp.textContent = "";
    			}
    		}
    	}
    
    	// Remove wrapper from fragment
    	fragment.textContent = "";
    
    	i = 0;
    	while ( ( elem = nodes[ i++ ] ) ) {
    
    		// Skip elements already in the context collection (trac-4087)
    		if ( selection && jQuery.inArray( elem, selection ) > -1 ) {
    			if ( ignored ) {
    				ignored.push( elem );
    			}
    			continue;
    		}
    
    		contains = jQuery.contains( elem.ownerDocument, elem );
    
    		// Append to fragment
    		tmp = getAll( fragment.appendChild( elem ), "script" );
    
    		// Preserve script evaluation history
    		if ( contains ) {
    			setGlobalEval( tmp );
    		}
    
    		// Capture executables
    		if ( scripts ) {
    			j = 0;
    			while ( ( elem = tmp[ j++ ] ) ) {
    				if ( rscriptType.test( elem.type || "" ) ) {
    					scripts.push( elem );
    				}
    			}
    		}
    	}
    
    	return fragment;
    }
    
    
    ( function() {
    	var fragment = document.createDocumentFragment(),
    		div = fragment.appendChild( document.createElement( "div" ) ),
    		input = document.createElement( "input" );
    
    	// Support: Android 4.0-4.3, Safari<=5.1
    	// Check state lost if the name is set (#11217)
    	// Support: Windows Web Apps (WWA)
    	// `name` and `type` must use .setAttribute for WWA (#14901)
    	input.setAttribute( "type", "radio" );
    	input.setAttribute( "checked", "checked" );
    	input.setAttribute( "name", "t" );
    
    	div.appendChild( input );
    
    	// Support: Safari<=5.1, Android<4.2
    	// Older WebKit doesn't clone checked state correctly in fragments
    	support.checkClone = div.cloneNode( true ).cloneNode( true ).lastChild.checked;
    
    	// Support: IE<=11+
    	// Make sure textarea (and checkbox) defaultValue is properly cloned
    	div.innerHTML = "<textarea>x</textarea>";
    	support.noCloneChecked = !!div.cloneNode( true ).lastChild.defaultValue;
    } )();
    
    
    var
    	rkeyEvent = /^key/,
    	rmouseEvent = /^(?:mouse|pointer|contextmenu|drag|drop)|click/,
    	rtypenamespace = /^([^.]*)(?:\.(.+)|)/;
    
    function returnTrue() {
    	return true;
    }
    
    function returnFalse() {
    	return false;
    }
    
    // Support: IE9
    // See #13393 for more info
    function safeActiveElement() {
    	try {
    		return document.activeElement;
    	} catch ( err ) { }
    }
    
    function on( elem, types, selector, data, fn, one ) {
    	var origFn, type;
    
    	// Types can be a map of types/handlers
    	if ( typeof types === "object" ) {
    
    		// ( types-Object, selector, data )
    		if ( typeof selector !== "string" ) {
    
    			// ( types-Object, data )
    			data = data || selector;
    			selector = undefined;
    		}
    		for ( type in types ) {
    			on( elem, type, selector, data, types[ type ], one );
    		}
    		return elem;
    	}
    
    	if ( data == null && fn == null ) {
    
    		// ( types, fn )
    		fn = selector;
    		data = selector = undefined;
    	} else if ( fn == null ) {
    		if ( typeof selector === "string" ) {
    
    			// ( types, selector, fn )
    			fn = data;
    			data = undefined;
    		} else {
    
    			// ( types, data, fn )
    			fn = data;
    			data = selector;
    			selector = undefined;
    		}
    	}
    	if ( fn === false ) {
    		fn = returnFalse;
    	} else if ( !fn ) {
    		return elem;
    	}
    
    	if ( one === 1 ) {
    		origFn = fn;
    		fn = function( event ) {
    
    			// Can use an empty set, since event contains the info
    			jQuery().off( event );
    			return origFn.apply( this, arguments );
    		};
    
    		// Use same guid so caller can remove using origFn
    		fn.guid = origFn.guid || ( origFn.guid = jQuery.guid++ );
    	}
    	return elem.each( function() {
    		jQuery.event.add( this, types, fn, data, selector );
    	} );
    }
    
    /*
     * Helper functions for managing events -- not part of the public interface.
     * Props to Dean Edwards' addEvent library for many of the ideas.
     */
    jQuery.event = {
    
    	global: {},
    
    	add: function( elem, types, handler, data, selector ) {
    
    		var handleObjIn, eventHandle, tmp,
    			events, t, handleObj,
    			special, handlers, type, namespaces, origType,
    			elemData = dataPriv.get( elem );
    
    		// Don't attach events to noData or text/comment nodes (but allow plain objects)
    		if ( !elemData ) {
    			return;
    		}
    
    		// Caller can pass in an object of custom data in lieu of the handler
    		if ( handler.handler ) {
    			handleObjIn = handler;
    			handler = handleObjIn.handler;
    			selector = handleObjIn.selector;
    		}
    
    		// Make sure that the handler has a unique ID, used to find/remove it later
    		if ( !handler.guid ) {
    			handler.guid = jQuery.guid++;
    		}
    
    		// Init the element's event structure and main handler, if this is the first
    		if ( !( events = elemData.events ) ) {
    			events = elemData.events = {};
    		}
    		if ( !( eventHandle = elemData.handle ) ) {
    			eventHandle = elemData.handle = function( e ) {
    
    				// Discard the second event of a jQuery.event.trigger() and
    				// when an event is called after a page has unloaded
    				return typeof jQuery !== "undefined" && jQuery.event.triggered !== e.type ?
    					jQuery.event.dispatch.apply( elem, arguments ) : undefined;
    			};
    		}
    
    		// Handle multiple events separated by a space
    		types = ( types || "" ).match( rnotwhite ) || [ "" ];
    		t = types.length;
    		while ( t-- ) {
    			tmp = rtypenamespace.exec( types[ t ] ) || [];
    			type = origType = tmp[ 1 ];
    			namespaces = ( tmp[ 2 ] || "" ).split( "." ).sort();
    
    			// There *must* be a type, no attaching namespace-only handlers
    			if ( !type ) {
    				continue;
    			}
    
    			// If event changes its type, use the special event handlers for the changed type
    			special = jQuery.event.special[ type ] || {};
    
    			// If selector defined, determine special event api type, otherwise given type
    			type = ( selector ? special.delegateType : special.bindType ) || type;
    
    			// Update special based on newly reset type
    			special = jQuery.event.special[ type ] || {};
    
    			// handleObj is passed to all event handlers
    			handleObj = jQuery.extend( {
    				type: type,
    				origType: origType,
    				data: data,
    				handler: handler,
    				guid: handler.guid,
    				selector: selector,
    				needsContext: selector && jQuery.expr.match.needsContext.test( selector ),
    				namespace: namespaces.join( "." )
    			}, handleObjIn );
    
    			// Init the event handler queue if we're the first
    			if ( !( handlers = events[ type ] ) ) {
    				handlers = events[ type ] = [];
    				handlers.delegateCount = 0;
    
    				// Only use addEventListener if the special events handler returns false
    				if ( !special.setup ||
    					special.setup.call( elem, data, namespaces, eventHandle ) === false ) {
    
    					if ( elem.addEventListener ) {
    						elem.addEventListener( type, eventHandle );
    					}
    				}
    			}
    
    			if ( special.add ) {
    				special.add.call( elem, handleObj );
    
    				if ( !handleObj.handler.guid ) {
    					handleObj.handler.guid = handler.guid;
    				}
    			}
    
    			// Add to the element's handler list, delegates in front
    			if ( selector ) {
    				handlers.splice( handlers.delegateCount++, 0, handleObj );
    			} else {
    				handlers.push( handleObj );
    			}
    
    			// Keep track of which events have ever been used, for event optimization
    			jQuery.event.global[ type ] = true;
    		}
    
    	},
    
    	// Detach an event or set of events from an element
    	remove: function( elem, types, handler, selector, mappedTypes ) {
    
    		var j, origCount, tmp,
    			events, t, handleObj,
    			special, handlers, type, namespaces, origType,
    			elemData = dataPriv.hasData( elem ) && dataPriv.get( elem );
    
    		if ( !elemData || !( events = elemData.events ) ) {
    			return;
    		}
    
    		// Once for each type.namespace in types; type may be omitted
    		types = ( types || "" ).match( rnotwhite ) || [ "" ];
    		t = types.length;
    		while ( t-- ) {
    			tmp = rtypenamespace.exec( types[ t ] ) || [];
    			type = origType = tmp[ 1 ];
    			namespaces = ( tmp[ 2 ] || "" ).split( "." ).sort();
    
    			// Unbind all events (on this namespace, if provided) for the element
    			if ( !type ) {
    				for ( type in events ) {
    					jQuery.event.remove( elem, type + types[ t ], handler, selector, true );
    				}
    				continue;
    			}
    
    			special = jQuery.event.special[ type ] || {};
    			type = ( selector ? special.delegateType : special.bindType ) || type;
    			handlers = events[ type ] || [];
    			tmp = tmp[ 2 ] &&
    				new RegExp( "(^|\\.)" + namespaces.join( "\\.(?:.*\\.|)" ) + "(\\.|$)" );
    
    			// Remove matching events
    			origCount = j = handlers.length;
    			while ( j-- ) {
    				handleObj = handlers[ j ];
    
    				if ( ( mappedTypes || origType === handleObj.origType ) &&
    					( !handler || handler.guid === handleObj.guid ) &&
    					( !tmp || tmp.test( handleObj.namespace ) ) &&
    					( !selector || selector === handleObj.selector ||
    						selector === "**" && handleObj.selector ) ) {
    					handlers.splice( j, 1 );
    
    					if ( handleObj.selector ) {
    						handlers.delegateCount--;
    					}
    					if ( special.remove ) {
    						special.remove.call( elem, handleObj );
    					}
    				}
    			}
    
    			// Remove generic event handler if we removed something and no more handlers exist
    			// (avoids potential for endless recursion during removal of special event handlers)
    			if ( origCount && !handlers.length ) {
    				if ( !special.teardown ||
    					special.teardown.call( elem, namespaces, elemData.handle ) === false ) {
    
    					jQuery.removeEvent( elem, type, elemData.handle );
    				}
    
    				delete events[ type ];
    			}
    		}
    
    		// Remove data and the expando if it's no longer used
    		if ( jQuery.isEmptyObject( events ) ) {
    			dataPriv.remove( elem, "handle events" );
    		}
    	},
    
    	dispatch: function( event ) {
    
    		// Make a writable jQuery.Event from the native event object
    		event = jQuery.event.fix( event );
    
    		var i, j, ret, matched, handleObj,
    			handlerQueue = [],
    			args = slice.call( arguments ),
    			handlers = ( dataPriv.get( this, "events" ) || {} )[ event.type ] || [],
    			special = jQuery.event.special[ event.type ] || {};
    
    		// Use the fix-ed jQuery.Event rather than the (read-only) native event
    		args[ 0 ] = event;
    		event.delegateTarget = this;
    
    		// Call the preDispatch hook for the mapped type, and let it bail if desired
    		if ( special.preDispatch && special.preDispatch.call( this, event ) === false ) {
    			return;
    		}
    
    		// Determine handlers
    		handlerQueue = jQuery.event.handlers.call( this, event, handlers );
    
    		// Run delegates first; they may want to stop propagation beneath us
    		i = 0;
    		while ( ( matched = handlerQueue[ i++ ] ) && !event.isPropagationStopped() ) {
    			event.currentTarget = matched.elem;
    
    			j = 0;
    			while ( ( handleObj = matched.handlers[ j++ ] ) &&
    				!event.isImmediatePropagationStopped() ) {
    
    				// Triggered event must either 1) have no namespace, or 2) have namespace(s)
    				// a subset or equal to those in the bound event (both can have no namespace).
    				if ( !event.rnamespace || event.rnamespace.test( handleObj.namespace ) ) {
    
    					event.handleObj = handleObj;
    					event.data = handleObj.data;
    
    					ret = ( ( jQuery.event.special[ handleObj.origType ] || {} ).handle ||
    						handleObj.handler ).apply( matched.elem, args );
    
    					if ( ret !== undefined ) {
    						if ( ( event.result = ret ) === false ) {
    							event.preventDefault();
    							event.stopPropagation();
    						}
    					}
    				}
    			}
    		}
    
    		// Call the postDispatch hook for the mapped type
    		if ( special.postDispatch ) {
    			special.postDispatch.call( this, event );
    		}
    
    		return event.result;
    	},
    
    	handlers: function( event, handlers ) {
    		var i, matches, sel, handleObj,
    			handlerQueue = [],
    			delegateCount = handlers.delegateCount,
    			cur = event.target;
    
    		// Support (at least): Chrome, IE9
    		// Find delegate handlers
    		// Black-hole SVG <use> instance trees (#13180)
    		//
    		// Support: Firefox<=42+
    		// Avoid non-left-click in FF but don't block IE radio events (#3861, gh-2343)
    		if ( delegateCount && cur.nodeType &&
    			( event.type !== "click" || isNaN( event.button ) || event.button < 1 ) ) {
    
    			for ( ; cur !== this; cur = cur.parentNode || this ) {
    
    				// Don't check non-elements (#13208)
    				// Don't process clicks on disabled elements (#6911, #8165, #11382, #11764)
    				if ( cur.nodeType === 1 && ( cur.disabled !== true || event.type !== "click" ) ) {
    					matches = [];
    					for ( i = 0; i < delegateCount; i++ ) {
    						handleObj = handlers[ i ];
    
    						// Don't conflict with Object.prototype properties (#13203)
    						sel = handleObj.selector + " ";
    
    						if ( matches[ sel ] === undefined ) {
    							matches[ sel ] = handleObj.needsContext ?
    								jQuery( sel, this ).index( cur ) > -1 :
    								jQuery.find( sel, this, null, [ cur ] ).length;
    						}
    						if ( matches[ sel ] ) {
    							matches.push( handleObj );
    						}
    					}
    					if ( matches.length ) {
    						handlerQueue.push( { elem: cur, handlers: matches } );
    					}
    				}
    			}
    		}
    
    		// Add the remaining (directly-bound) handlers
    		if ( delegateCount < handlers.length ) {
    			handlerQueue.push( { elem: this, handlers: handlers.slice( delegateCount ) } );
    		}
    
    		return handlerQueue;
    	},
    
    	// Includes some event props shared by KeyEvent and MouseEvent
    	props: ( "altKey bubbles cancelable ctrlKey currentTarget detail eventPhase " +
    		"metaKey relatedTarget shiftKey target timeStamp view which" ).split( " " ),
    
    	fixHooks: {},
    
    	keyHooks: {
    		props: "char charCode key keyCode".split( " " ),
    		filter: function( event, original ) {
    
    			// Add which for key events
    			if ( event.which == null ) {
    				event.which = original.charCode != null ? original.charCode : original.keyCode;
    			}
    
    			return event;
    		}
    	},
    
    	mouseHooks: {
    		props: ( "button buttons clientX clientY offsetX offsetY pageX pageY " +
    			"screenX screenY toElement" ).split( " " ),
    		filter: function( event, original ) {
    			var eventDoc, doc, body,
    				button = original.button;
    
    			// Calculate pageX/Y if missing and clientX/Y available
    			if ( event.pageX == null && original.clientX != null ) {
    				eventDoc = event.target.ownerDocument || document;
    				doc = eventDoc.documentElement;
    				body = eventDoc.body;
    
    				event.pageX = original.clientX +
    					( doc && doc.scrollLeft || body && body.scrollLeft || 0 ) -
    					( doc && doc.clientLeft || body && body.clientLeft || 0 );
    				event.pageY = original.clientY +
    					( doc && doc.scrollTop  || body && body.scrollTop  || 0 ) -
    					( doc && doc.clientTop  || body && body.clientTop  || 0 );
    			}
    
    			// Add which for click: 1 === left; 2 === middle; 3 === right
    			// Note: button is not normalized, so don't use it
    			if ( !event.which && button !== undefined ) {
    				event.which = ( button & 1 ? 1 : ( button & 2 ? 3 : ( button & 4 ? 2 : 0 ) ) );
    			}
    
    			return event;
    		}
    	},
    
    	fix: function( event ) {
    		if ( event[ jQuery.expando ] ) {
    			return event;
    		}
    
    		// Create a writable copy of the event object and normalize some properties
    		var i, prop, copy,
    			type = event.type,
    			originalEvent = event,
    			fixHook = this.fixHooks[ type ];
    
    		if ( !fixHook ) {
    			this.fixHooks[ type ] = fixHook =
    				rmouseEvent.test( type ) ? this.mouseHooks :
    				rkeyEvent.test( type ) ? this.keyHooks :
    				{};
    		}
    		copy = fixHook.props ? this.props.concat( fixHook.props ) : this.props;
    
    		event = new jQuery.Event( originalEvent );
    
    		i = copy.length;
    		while ( i-- ) {
    			prop = copy[ i ];
    			event[ prop ] = originalEvent[ prop ];
    		}
    
    		// Support: Cordova 2.5 (WebKit) (#13255)
    		// All events should have a target; Cordova deviceready doesn't
    		if ( !event.target ) {
    			event.target = document;
    		}
    
    		// Support: Safari 6.0+, Chrome<28
    		// Target should not be a text node (#504, #13143)
    		if ( event.target.nodeType === 3 ) {
    			event.target = event.target.parentNode;
    		}
    
    		return fixHook.filter ? fixHook.filter( event, originalEvent ) : event;
    	},
    
    	special: {
    		load: {
    
    			// Prevent triggered image.load events from bubbling to window.load
    			noBubble: true
    		},
    		focus: {
    
    			// Fire native event if possible so blur/focus sequence is correct
    			trigger: function() {
    				if ( this !== safeActiveElement() && this.focus ) {
    					this.focus();
    					return false;
    				}
    			},
    			delegateType: "focusin"
    		},
    		blur: {
    			trigger: function() {
    				if ( this === safeActiveElement() && this.blur ) {
    					this.blur();
    					return false;
    				}
    			},
    			delegateType: "focusout"
    		},
    		click: {
    
    			// For checkbox, fire native event so checked state will be right
    			trigger: function() {
    				if ( this.type === "checkbox" && this.click && jQuery.nodeName( this, "input" ) ) {
    					this.click();
    					return false;
    				}
    			},
    
    			// For cross-browser consistency, don't fire native .click() on links
    			_default: function( event ) {
    				return jQuery.nodeName( event.target, "a" );
    			}
    		},
    
    		beforeunload: {
    			postDispatch: function( event ) {
    
    				// Support: Firefox 20+
    				// Firefox doesn't alert if the returnValue field is not set.
    				if ( event.result !== undefined && event.originalEvent ) {
    					event.originalEvent.returnValue = event.result;
    				}
    			}
    		}
    	}
    };
    
    jQuery.removeEvent = function( elem, type, handle ) {
    
    	// This "if" is needed for plain objects
    	if ( elem.removeEventListener ) {
    		elem.removeEventListener( type, handle );
    	}
    };
    
    jQuery.Event = function( src, props ) {
    
    	// Allow instantiation without the 'new' keyword
    	if ( !( this instanceof jQuery.Event ) ) {
    		return new jQuery.Event( src, props );
    	}
    
    	// Event object
    	if ( src && src.type ) {
    		this.originalEvent = src;
    		this.type = src.type;
    
    		// Events bubbling up the document may have been marked as prevented
    		// by a handler lower down the tree; reflect the correct value.
    		this.isDefaultPrevented = src.defaultPrevented ||
    				src.defaultPrevented === undefined &&
    
    				// Support: Android<4.0
    				src.returnValue === false ?
    			returnTrue :
    			returnFalse;
    
    	// Event type
    	} else {
    		this.type = src;
    	}
    
    	// Put explicitly provided properties onto the event object
    	if ( props ) {
    		jQuery.extend( this, props );
    	}
    
    	// Create a timestamp if incoming event doesn't have one
    	this.timeStamp = src && src.timeStamp || jQuery.now();
    
    	// Mark it as fixed
    	this[ jQuery.expando ] = true;
    };
    
    // jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding
    // http://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html
    jQuery.Event.prototype = {
    	constructor: jQuery.Event,
    	isDefaultPrevented: returnFalse,
    	isPropagationStopped: returnFalse,
    	isImmediatePropagationStopped: returnFalse,
    
    	preventDefault: function() {
    		var e = this.originalEvent;
    
    		this.isDefaultPrevented = returnTrue;
    
    		if ( e ) {
    			e.preventDefault();
    		}
    	},
    	stopPropagation: function() {
    		var e = this.originalEvent;
    
    		this.isPropagationStopped = returnTrue;
    
    		if ( e ) {
    			e.stopPropagation();
    		}
    	},
    	stopImmediatePropagation: function() {
    		var e = this.originalEvent;
    
    		this.isImmediatePropagationStopped = returnTrue;
    
    		if ( e ) {
    			e.stopImmediatePropagation();
    		}
    
    		this.stopPropagation();
    	}
    };
    
    // Create mouseenter/leave events using mouseover/out and event-time checks
    // so that event delegation works in jQuery.
    // Do the same for pointerenter/pointerleave and pointerover/pointerout
    //
    // Support: Safari 7 only
    // Safari sends mouseenter too often; see:
    // https://code.google.com/p/chromium/issues/detail?id=470258
    // for the description of the bug (it existed in older Chrome versions as well).
    jQuery.each( {
    	mouseenter: "mouseover",
    	mouseleave: "mouseout",
    	pointerenter: "pointerover",
    	pointerleave: "pointerout"
    }, function( orig, fix ) {
    	jQuery.event.special[ orig ] = {
    		delegateType: fix,
    		bindType: fix,
    
    		handle: function( event ) {
    			var ret,
    				target = this,
    				related = event.relatedTarget,
    				handleObj = event.handleObj;
    
    			// For mouseenter/leave call the handler if related is outside the target.
    			// NB: No relatedTarget if the mouse left/entered the browser window
    			if ( !related || ( related !== target && !jQuery.contains( target, related ) ) ) {
    				event.type = handleObj.origType;
    				ret = handleObj.handler.apply( this, arguments );
    				event.type = fix;
    			}
    			return ret;
    		}
    	};
    } );
    
    jQuery.fn.extend( {
    	on: function( types, selector, data, fn ) {
    		return on( this, types, selector, data, fn );
    	},
    	one: function( types, selector, data, fn ) {
    		return on( this, types, selector, data, fn, 1 );
    	},
    	off: function( types, selector, fn ) {
    		var handleObj, type;
    		if ( types && types.preventDefault && types.handleObj ) {
    
    			// ( event )  dispatched jQuery.Event
    			handleObj = types.handleObj;
    			jQuery( types.delegateTarget ).off(
    				handleObj.namespace ?
    					handleObj.origType + "." + handleObj.namespace :
    					handleObj.origType,
    				handleObj.selector,
    				handleObj.handler
    			);
    			return this;
    		}
    		if ( typeof types === "object" ) {
    
    			// ( types-object [, selector] )
    			for ( type in types ) {
    				this.off( type, selector, types[ type ] );
    			}
    			return this;
    		}
    		if ( selector === false || typeof selector === "function" ) {
    
    			// ( types [, fn] )
    			fn = selector;
    			selector = undefined;
    		}
    		if ( fn === false ) {
    			fn = returnFalse;
    		}
    		return this.each( function() {
    			jQuery.event.remove( this, types, fn, selector );
    		} );
    	}
    } );
    
    
    var
    	rxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:-]+)[^>]*)\/>/gi,
    
    	// Support: IE 10-11, Edge 10240+
    	// In IE/Edge using regex groups here causes severe slowdowns.
    	// See https://connect.microsoft.com/IE/feedback/details/1736512/
    	rnoInnerhtml = /<script|<style|<link/i,
    
    	// checked="checked" or checked
    	rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i,
    	rscriptTypeMasked = /^true\/(.*)/,
    	rcleanScript = /^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g;
    
    // Manipulating tables requires a tbody
    function manipulationTarget( elem, content ) {
    	return jQuery.nodeName( elem, "table" ) &&
    		jQuery.nodeName( content.nodeType !== 11 ? content : content.firstChild, "tr" ) ?
    
    		elem.getElementsByTagName( "tbody" )[ 0 ] ||
    			elem.appendChild( elem.ownerDocument.createElement( "tbody" ) ) :
    		elem;
    }
    
    // Replace/restore the type attribute of script elements for safe DOM manipulation
    function disableScript( elem ) {
    	elem.type = ( elem.getAttribute( "type" ) !== null ) + "/" + elem.type;
    	return elem;
    }
    function restoreScript( elem ) {
    	var match = rscriptTypeMasked.exec( elem.type );
    
    	if ( match ) {
    		elem.type = match[ 1 ];
    	} else {
    		elem.removeAttribute( "type" );
    	}
    
    	return elem;
    }
    
    function cloneCopyEvent( src, dest ) {
    	var i, l, type, pdataOld, pdataCur, udataOld, udataCur, events;
    
    	if ( dest.nodeType !== 1 ) {
    		return;
    	}
    
    	// 1. Copy private data: events, handlers, etc.
    	if ( dataPriv.hasData( src ) ) {
    		pdataOld = dataPriv.access( src );
    		pdataCur = dataPriv.set( dest, pdataOld );
    		events = pdataOld.events;
    
    		if ( events ) {
    			delete pdataCur.handle;
    			pdataCur.events = {};
    
    			for ( type in events ) {
    				for ( i = 0, l = events[ type ].length; i < l; i++ ) {
    					jQuery.event.add( dest, type, events[ type ][ i ] );
    				}
    			}
    		}
    	}
    
    	// 2. Copy user data
    	if ( dataUser.hasData( src ) ) {
    		udataOld = dataUser.access( src );
    		udataCur = jQuery.extend( {}, udataOld );
    
    		dataUser.set( dest, udataCur );
    	}
    }
    
    // Fix IE bugs, see support tests
    function fixInput( src, dest ) {
    	var nodeName = dest.nodeName.toLowerCase();
    
    	// Fails to persist the checked state of a cloned checkbox or radio button.
    	if ( nodeName === "input" && rcheckableType.test( src.type ) ) {
    		dest.checked = src.checked;
    
    	// Fails to return the selected option to the default selected state when cloning options
    	} else if ( nodeName === "input" || nodeName === "textarea" ) {
    		dest.defaultValue = src.defaultValue;
    	}
    }
    
    function domManip( collection, args, callback, ignored ) {
    
    	// Flatten any nested arrays
    	args = concat.apply( [], args );
    
    	var fragment, first, scripts, hasScripts, node, doc,
    		i = 0,
    		l = collection.length,
    		iNoClone = l - 1,
    		value = args[ 0 ],
    		isFunction = jQuery.isFunction( value );
    
    	// We can't cloneNode fragments that contain checked, in WebKit
    	if ( isFunction ||
    			( l > 1 && typeof value === "string" &&
    				!support.checkClone && rchecked.test( value ) ) ) {
    		return collection.each( function( index ) {
    			var self = collection.eq( index );
    			if ( isFunction ) {
    				args[ 0 ] = value.call( this, index, self.html() );
    			}
    			domManip( self, args, callback, ignored );
    		} );
    	}
    
    	if ( l ) {
    		fragment = buildFragment( args, collection[ 0 ].ownerDocument, false, collection, ignored );
    		first = fragment.firstChild;
    
    		if ( fragment.childNodes.length === 1 ) {
    			fragment = first;
    		}
    
    		// Require either new content or an interest in ignored elements to invoke the callback
    		if ( first || ignored ) {
    			scripts = jQuery.map( getAll( fragment, "script" ), disableScript );
    			hasScripts = scripts.length;
    
    			// Use the original fragment for the last item
    			// instead of the first because it can end up
    			// being emptied incorrectly in certain situations (#8070).
    			for ( ; i < l; i++ ) {
    				node = fragment;
    
    				if ( i !== iNoClone ) {
    					node = jQuery.clone( node, true, true );
    
    					// Keep references to cloned scripts for later restoration
    					if ( hasScripts ) {
    
    						// Support: Android<4.1, PhantomJS<2
    						// push.apply(_, arraylike) throws on ancient WebKit
    						jQuery.merge( scripts, getAll( node, "script" ) );
    					}
    				}
    
    				callback.call( collection[ i ], node, i );
    			}
    
    			if ( hasScripts ) {
    				doc = scripts[ scripts.length - 1 ].ownerDocument;
    
    				// Reenable scripts
    				jQuery.map( scripts, restoreScript );
    
    				// Evaluate executable scripts on first document insertion
    				for ( i = 0; i < hasScripts; i++ ) {
    					node = scripts[ i ];
    					if ( rscriptType.test( node.type || "" ) &&
    						!dataPriv.access( node, "globalEval" ) &&
    						jQuery.contains( doc, node ) ) {
    
    						if ( node.src ) {
    
    							// Optional AJAX dependency, but won't run scripts if not present
    							if ( jQuery._evalUrl ) {
    								jQuery._evalUrl( node.src );
    							}
    						} else {
    							jQuery.globalEval( node.textContent.replace( rcleanScript, "" ) );
    						}
    					}
    				}
    			}
    		}
    	}
    
    	return collection;
    }
    
    function remove( elem, selector, keepData ) {
    	var node,
    		nodes = selector ? jQuery.filter( selector, elem ) : elem,
    		i = 0;
    
    	for ( ; ( node = nodes[ i ] ) != null; i++ ) {
    		if ( !keepData && node.nodeType === 1 ) {
    			jQuery.cleanData( getAll( node ) );
    		}
    
    		if ( node.parentNode ) {
    			if ( keepData && jQuery.contains( node.ownerDocument, node ) ) {
    				setGlobalEval( getAll( node, "script" ) );
    			}
    			node.parentNode.removeChild( node );
    		}
    	}
    
    	return elem;
    }
    
    jQuery.extend( {
    	htmlPrefilter: function( html ) {
    		return html.replace( rxhtmlTag, "<$1></$2>" );
    	},
    
    	clone: function( elem, dataAndEvents, deepDataAndEvents ) {
    		var i, l, srcElements, destElements,
    			clone = elem.cloneNode( true ),
    			inPage = jQuery.contains( elem.ownerDocument, elem );
    
    		// Fix IE cloning issues
    		if ( !support.noCloneChecked && ( elem.nodeType === 1 || elem.nodeType === 11 ) &&
    				!jQuery.isXMLDoc( elem ) ) {
    
    			// We eschew Sizzle here for performance reasons: http://jsperf.com/getall-vs-sizzle/2
    			destElements = getAll( clone );
    			srcElements = getAll( elem );
    
    			for ( i = 0, l = srcElements.length; i < l; i++ ) {
    				fixInput( srcElements[ i ], destElements[ i ] );
    			}
    		}
    
    		// Copy the events from the original to the clone
    		if ( dataAndEvents ) {
    			if ( deepDataAndEvents ) {
    				srcElements = srcElements || getAll( elem );
    				destElements = destElements || getAll( clone );
    
    				for ( i = 0, l = srcElements.length; i < l; i++ ) {
    					cloneCopyEvent( srcElements[ i ], destElements[ i ] );
    				}
    			} else {
    				cloneCopyEvent( elem, clone );
    			}
    		}
    
    		// Preserve script evaluation history
    		destElements = getAll( clone, "script" );
    		if ( destElements.length > 0 ) {
    			setGlobalEval( destElements, !inPage && getAll( elem, "script" ) );
    		}
    
    		// Return the cloned set
    		return clone;
    	},
    
    	cleanData: function( elems ) {
    		var data, elem, type,
    			special = jQuery.event.special,
    			i = 0;
    
    		for ( ; ( elem = elems[ i ] ) !== undefined; i++ ) {
    			if ( acceptData( elem ) ) {
    				if ( ( data = elem[ dataPriv.expando ] ) ) {
    					if ( data.events ) {
    						for ( type in data.events ) {
    							if ( special[ type ] ) {
    								jQuery.event.remove( elem, type );
    
    							// This is a shortcut to avoid jQuery.event.remove's overhead
    							} else {
    								jQuery.removeEvent( elem, type, data.handle );
    							}
    						}
    					}
    
    					// Support: Chrome <= 35-45+
    					// Assign undefined instead of using delete, see Data#remove
    					elem[ dataPriv.expando ] = undefined;
    				}
    				if ( elem[ dataUser.expando ] ) {
    
    					// Support: Chrome <= 35-45+
    					// Assign undefined instead of using delete, see Data#remove
    					elem[ dataUser.expando ] = undefined;
    				}
    			}
    		}
    	}
    } );
    
    jQuery.fn.extend( {
    
    	// Keep domManip exposed until 3.0 (gh-2225)
    	domManip: domManip,
    
    	detach: function( selector ) {
    		return remove( this, selector, true );
    	},
    
    	remove: function( selector ) {
    		return remove( this, selector );
    	},
    
    	text: function( value ) {
    		return access( this, function( value ) {
    			return value === undefined ?
    				jQuery.text( this ) :
    				this.empty().each( function() {
    					if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
    						this.textContent = value;
    					}
    				} );
    		}, null, value, arguments.length );
    	},
    
    	append: function() {
    		return domManip( this, arguments, function( elem ) {
    			if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
    				var target = manipulationTarget( this, elem );
    				target.appendChild( elem );
    			}
    		} );
    	},
    
    	prepend: function() {
    		return domManip( this, arguments, function( elem ) {
    			if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
    				var target = manipulationTarget( this, elem );
    				target.insertBefore( elem, target.firstChild );
    			}
    		} );
    	},
    
    	before: function() {
    		return domManip( this, arguments, function( elem ) {
    			if ( this.parentNode ) {
    				this.parentNode.insertBefore( elem, this );
    			}
    		} );
    	},
    
    	after: function() {
    		return domManip( this, arguments, function( elem ) {
    			if ( this.parentNode ) {
    				this.parentNode.insertBefore( elem, this.nextSibling );
    			}
    		} );
    	},
    
    	empty: function() {
    		var elem,
    			i = 0;
    
    		for ( ; ( elem = this[ i ] ) != null; i++ ) {
    			if ( elem.nodeType === 1 ) {
    
    				// Prevent memory leaks
    				jQuery.cleanData( getAll( elem, false ) );
    
    				// Remove any remaining nodes
    				elem.textContent = "";
    			}
    		}
    
    		return this;
    	},
    
    	clone: function( dataAndEvents, deepDataAndEvents ) {
    		dataAndEvents = dataAndEvents == null ? false : dataAndEvents;
    		deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;
    
    		return this.map( function() {
    			return jQuery.clone( this, dataAndEvents, deepDataAndEvents );
    		} );
    	},
    
    	html: function( value ) {
    		return access( this, function( value ) {
    			var elem = this[ 0 ] || {},
    				i = 0,
    				l = this.length;
    
    			if ( value === undefined && elem.nodeType === 1 ) {
    				return elem.innerHTML;
    			}
    
    			// See if we can take a shortcut and just use innerHTML
    			if ( typeof value === "string" && !rnoInnerhtml.test( value ) &&
    				!wrapMap[ ( rtagName.exec( value ) || [ "", "" ] )[ 1 ].toLowerCase() ] ) {
    
    				value = jQuery.htmlPrefilter( value );
    
    				try {
    					for ( ; i < l; i++ ) {
    						elem = this[ i ] || {};
    
    						// Remove element nodes and prevent memory leaks
    						if ( elem.nodeType === 1 ) {
    							jQuery.cleanData( getAll( elem, false ) );
    							elem.innerHTML = value;
    						}
    					}
    
    					elem = 0;
    
    				// If using innerHTML throws an exception, use the fallback method
    				} catch ( e ) {}
    			}
    
    			if ( elem ) {
    				this.empty().append( value );
    			}
    		}, null, value, arguments.length );
    	},
    
    	replaceWith: function() {
    		var ignored = [];
    
    		// Make the changes, replacing each non-ignored context element with the new content
    		return domManip( this, arguments, function( elem ) {
    			var parent = this.parentNode;
    
    			if ( jQuery.inArray( this, ignored ) < 0 ) {
    				jQuery.cleanData( getAll( this ) );
    				if ( parent ) {
    					parent.replaceChild( elem, this );
    				}
    			}
    
    		// Force callback invocation
    		}, ignored );
    	}
    } );
    
    jQuery.each( {
    	appendTo: "append",
    	prependTo: "prepend",
    	insertBefore: "before",
    	insertAfter: "after",
    	replaceAll: "replaceWith"
    }, function( name, original ) {
    	jQuery.fn[ name ] = function( selector ) {
    		var elems,
    			ret = [],
    			insert = jQuery( selector ),
    			last = insert.length - 1,
    			i = 0;
    
    		for ( ; i <= last; i++ ) {
    			elems = i === last ? this : this.clone( true );
    			jQuery( insert[ i ] )[ original ]( elems );
    
    			// Support: QtWebKit
    			// .get() because push.apply(_, arraylike) throws
    			push.apply( ret, elems.get() );
    		}
    
    		return this.pushStack( ret );
    	};
    } );
    
    
    var iframe,
    	elemdisplay = {
    
    		// Support: Firefox
    		// We have to pre-define these values for FF (#10227)
    		HTML: "block",
    		BODY: "block"
    	};
    
    /**
     * Retrieve the actual display of a element
     * @param {String} name nodeName of the element
     * @param {Object} doc Document object
     */
    
    // Called only from within defaultDisplay
    function actualDisplay( name, doc ) {
    	var elem = jQuery( doc.createElement( name ) ).appendTo( doc.body ),
    
    		display = jQuery.css( elem[ 0 ], "display" );
    
    	// We don't have any data stored on the element,
    	// so use "detach" method as fast way to get rid of the element
    	elem.detach();
    
    	return display;
    }
    
    /**
     * Try to determine the default display value of an element
     * @param {String} nodeName
     */
    function defaultDisplay( nodeName ) {
    	var doc = document,
    		display = elemdisplay[ nodeName ];
    
    	if ( !display ) {
    		display = actualDisplay( nodeName, doc );
    
    		// If the simple way fails, read from inside an iframe
    		if ( display === "none" || !display ) {
    
    			// Use the already-created iframe if possible
    			iframe = ( iframe || jQuery( "<iframe frameborder='0' width='0' height='0'/>" ) )
    				.appendTo( doc.documentElement );
    
    			// Always write a new HTML skeleton so Webkit and Firefox don't choke on reuse
    			doc = iframe[ 0 ].contentDocument;
    
    			// Support: IE
    			doc.write();
    			doc.close();
    
    			display = actualDisplay( nodeName, doc );
    			iframe.detach();
    		}
    
    		// Store the correct default display
    		elemdisplay[ nodeName ] = display;
    	}
    
    	return display;
    }
    var rmargin = ( /^margin/ );
    
    var rnumnonpx = new RegExp( "^(" + pnum + ")(?!px)[a-z%]+$", "i" );
    
    var getStyles = function( elem ) {
    
    		// Support: IE<=11+, Firefox<=30+ (#15098, #14150)
    		// IE throws on elements created in popups
    		// FF meanwhile throws on frame elements through "defaultView.getComputedStyle"
    		var view = elem.ownerDocument.defaultView;
    
    		if ( !view || !view.opener ) {
    			view = window;
    		}
    
    		return view.getComputedStyle( elem );
    	};
    
    var swap = function( elem, options, callback, args ) {
    	var ret, name,
    		old = {};
    
    	// Remember the old values, and insert the new ones
    	for ( name in options ) {
    		old[ name ] = elem.style[ name ];
    		elem.style[ name ] = options[ name ];
    	}
    
    	ret = callback.apply( elem, args || [] );
    
    	// Revert the old values
    	for ( name in options ) {
    		elem.style[ name ] = old[ name ];
    	}
    
    	return ret;
    };
    
    
    var documentElement = document.documentElement;
    
    
    
    ( function() {
    	var pixelPositionVal, boxSizingReliableVal, pixelMarginRightVal, reliableMarginLeftVal,
    		container = document.createElement( "div" ),
    		div = document.createElement( "div" );
    
    	// Finish early in limited (non-browser) environments
    	if ( !div.style ) {
    		return;
    	}
    
    	// Support: IE9-11+
    	// Style of cloned element affects source element cloned (#8908)
    	div.style.backgroundClip = "content-box";
    	div.cloneNode( true ).style.backgroundClip = "";
    	support.clearCloneStyle = div.style.backgroundClip === "content-box";
    
    	container.style.cssText = "border:0;width:8px;height:0;top:0;left:-9999px;" +
    		"padding:0;margin-top:1px;position:absolute";
    	container.appendChild( div );
    
    	// Executing both pixelPosition & boxSizingReliable tests require only one layout
    	// so they're executed at the same time to save the second computation.
    	function computeStyleTests() {
    		div.style.cssText =
    
    			// Support: Firefox<29, Android 2.3
    			// Vendor-prefix box-sizing
    			"-webkit-box-sizing:border-box;-moz-box-sizing:border-box;box-sizing:border-box;" +
    			"position:relative;display:block;" +
    			"margin:auto;border:1px;padding:1px;" +
    			"top:1%;width:50%";
    		div.innerHTML = "";
    		documentElement.appendChild( container );
    
    		var divStyle = window.getComputedStyle( div );
    		pixelPositionVal = divStyle.top !== "1%";
    		reliableMarginLeftVal = divStyle.marginLeft === "2px";
    		boxSizingReliableVal = divStyle.width === "4px";
    
    		// Support: Android 4.0 - 4.3 only
    		// Some styles come back with percentage values, even though they shouldn't
    		div.style.marginRight = "50%";
    		pixelMarginRightVal = divStyle.marginRight === "4px";
    
    		documentElement.removeChild( container );
    	}
    
    	jQuery.extend( support, {
    		pixelPosition: function() {
    
    			// This test is executed only once but we still do memoizing
    			// since we can use the boxSizingReliable pre-computing.
    			// No need to check if the test was already performed, though.
    			computeStyleTests();
    			return pixelPositionVal;
    		},
    		boxSizingReliable: function() {
    			if ( boxSizingReliableVal == null ) {
    				computeStyleTests();
    			}
    			return boxSizingReliableVal;
    		},
    		pixelMarginRight: function() {
    
    			// Support: Android 4.0-4.3
    			// We're checking for boxSizingReliableVal here instead of pixelMarginRightVal
    			// since that compresses better and they're computed together anyway.
    			if ( boxSizingReliableVal == null ) {
    				computeStyleTests();
    			}
    			return pixelMarginRightVal;
    		},
    		reliableMarginLeft: function() {
    
    			// Support: IE <=8 only, Android 4.0 - 4.3 only, Firefox <=3 - 37
    			if ( boxSizingReliableVal == null ) {
    				computeStyleTests();
    			}
    			return reliableMarginLeftVal;
    		},
    		reliableMarginRight: function() {
    
    			// Support: Android 2.3
    			// Check if div with explicit width and no margin-right incorrectly
    			// gets computed margin-right based on width of container. (#3333)
    			// WebKit Bug 13343 - getComputedStyle returns wrong value for margin-right
    			// This support function is only executed once so no memoizing is needed.
    			var ret,
    				marginDiv = div.appendChild( document.createElement( "div" ) );
    
    			// Reset CSS: box-sizing; display; margin; border; padding
    			marginDiv.style.cssText = div.style.cssText =
    
    				// Support: Android 2.3
    				// Vendor-prefix box-sizing
    				"-webkit-box-sizing:content-box;box-sizing:content-box;" +
    				"display:block;margin:0;border:0;padding:0";
    			marginDiv.style.marginRight = marginDiv.style.width = "0";
    			div.style.width = "1px";
    			documentElement.appendChild( container );
    
    			ret = !parseFloat( window.getComputedStyle( marginDiv ).marginRight );
    
    			documentElement.removeChild( container );
    			div.removeChild( marginDiv );
    
    			return ret;
    		}
    	} );
    } )();
    
    
    function curCSS( elem, name, computed ) {
    	var width, minWidth, maxWidth, ret,
    		style = elem.style;
    
    	computed = computed || getStyles( elem );
    	ret = computed ? computed.getPropertyValue( name ) || computed[ name ] : undefined;
    
    	// Support: Opera 12.1x only
    	// Fall back to style even without computed
    	// computed is undefined for elems on document fragments
    	if ( ( ret === "" || ret === undefined ) && !jQuery.contains( elem.ownerDocument, elem ) ) {
    		ret = jQuery.style( elem, name );
    	}
    
    	// Support: IE9
    	// getPropertyValue is only needed for .css('filter') (#12537)
    	if ( computed ) {
    
    		// A tribute to the "awesome hack by Dean Edwards"
    		// Android Browser returns percentage for some values,
    		// but width seems to be reliably pixels.
    		// This is against the CSSOM draft spec:
    		// http://dev.w3.org/csswg/cssom/#resolved-values
    		if ( !support.pixelMarginRight() && rnumnonpx.test( ret ) && rmargin.test( name ) ) {
    
    			// Remember the original values
    			width = style.width;
    			minWidth = style.minWidth;
    			maxWidth = style.maxWidth;
    
    			// Put in the new values to get a computed value out
    			style.minWidth = style.maxWidth = style.width = ret;
    			ret = computed.width;
    
    			// Revert the changed values
    			style.width = width;
    			style.minWidth = minWidth;
    			style.maxWidth = maxWidth;
    		}
    	}
    
    	return ret !== undefined ?
    
    		// Support: IE9-11+
    		// IE returns zIndex value as an integer.
    		ret + "" :
    		ret;
    }
    
    
    function addGetHookIf( conditionFn, hookFn ) {
    
    	// Define the hook, we'll check on the first run if it's really needed.
    	return {
    		get: function() {
    			if ( conditionFn() ) {
    
    				// Hook not needed (or it's not possible to use it due
    				// to missing dependency), remove it.
    				delete this.get;
    				return;
    			}
    
    			// Hook needed; redefine it so that the support test is not executed again.
    			return ( this.get = hookFn ).apply( this, arguments );
    		}
    	};
    }
    
    
    var
    
    	// Swappable if display is none or starts with table
    	// except "table", "table-cell", or "table-caption"
    	// See here for display values: https://developer.mozilla.org/en-US/docs/CSS/display
    	rdisplayswap = /^(none|table(?!-c[ea]).+)/,
    
    	cssShow = { position: "absolute", visibility: "hidden", display: "block" },
    	cssNormalTransform = {
    		letterSpacing: "0",
    		fontWeight: "400"
    	},
    
    	cssPrefixes = [ "Webkit", "O", "Moz", "ms" ],
    	emptyStyle = document.createElement( "div" ).style;
    
    // Return a css property mapped to a potentially vendor prefixed property
    function vendorPropName( name ) {
    
    	// Shortcut for names that are not vendor prefixed
    	if ( name in emptyStyle ) {
    		return name;
    	}
    
    	// Check for vendor prefixed names
    	var capName = name[ 0 ].toUpperCase() + name.slice( 1 ),
    		i = cssPrefixes.length;
    
    	while ( i-- ) {
    		name = cssPrefixes[ i ] + capName;
    		if ( name in emptyStyle ) {
    			return name;
    		}
    	}
    }
    
    function setPositiveNumber( elem, value, subtract ) {
    
    	// Any relative (+/-) values have already been
    	// normalized at this point
    	var matches = rcssNum.exec( value );
    	return matches ?
    
    		// Guard against undefined "subtract", e.g., when used as in cssHooks
    		Math.max( 0, matches[ 2 ] - ( subtract || 0 ) ) + ( matches[ 3 ] || "px" ) :
    		value;
    }
    
    function augmentWidthOrHeight( elem, name, extra, isBorderBox, styles ) {
    	var i = extra === ( isBorderBox ? "border" : "content" ) ?
    
    		// If we already have the right measurement, avoid augmentation
    		4 :
    
    		// Otherwise initialize for horizontal or vertical properties
    		name === "width" ? 1 : 0,
    
    		val = 0;
    
    	for ( ; i < 4; i += 2 ) {
    
    		// Both box models exclude margin, so add it if we want it
    		if ( extra === "margin" ) {
    			val += jQuery.css( elem, extra + cssExpand[ i ], true, styles );
    		}
    
    		if ( isBorderBox ) {
    
    			// border-box includes padding, so remove it if we want content
    			if ( extra === "content" ) {
    				val -= jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );
    			}
    
    			// At this point, extra isn't border nor margin, so remove border
    			if ( extra !== "margin" ) {
    				val -= jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );
    			}
    		} else {
    
    			// At this point, extra isn't content, so add padding
    			val += jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );
    
    			// At this point, extra isn't content nor padding, so add border
    			if ( extra !== "padding" ) {
    				val += jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );
    			}
    		}
    	}
    
    	return val;
    }
    
    function getWidthOrHeight( elem, name, extra ) {
    
    	// Start with offset property, which is equivalent to the border-box value
    	var valueIsBorderBox = true,
    		val = name === "width" ? elem.offsetWidth : elem.offsetHeight,
    		styles = getStyles( elem ),
    		isBorderBox = jQuery.css( elem, "boxSizing", false, styles ) === "border-box";
    
    	// Support: IE11 only
    	// In IE 11 fullscreen elements inside of an iframe have
    	// 100x too small dimensions (gh-1764).
    	if ( document.msFullscreenElement && window.top !== window ) {
    
    		// Support: IE11 only
    		// Running getBoundingClientRect on a disconnected node
    		// in IE throws an error.
    		if ( elem.getClientRects().length ) {
    			val = Math.round( elem.getBoundingClientRect()[ name ] * 100 );
    		}
    	}
    
    	// Some non-html elements return undefined for offsetWidth, so check for null/undefined
    	// svg - https://bugzilla.mozilla.org/show_bug.cgi?id=649285
    	// MathML - https://bugzilla.mozilla.org/show_bug.cgi?id=491668
    	if ( val <= 0 || val == null ) {
    
    		// Fall back to computed then uncomputed css if necessary
    		val = curCSS( elem, name, styles );
    		if ( val < 0 || val == null ) {
    			val = elem.style[ name ];
    		}
    
    		// Computed unit is not pixels. Stop here and return.
    		if ( rnumnonpx.test( val ) ) {
    			return val;
    		}
    
    		// Check for style in case a browser which returns unreliable values
    		// for getComputedStyle silently falls back to the reliable elem.style
    		valueIsBorderBox = isBorderBox &&
    			( support.boxSizingReliable() || val === elem.style[ name ] );
    
    		// Normalize "", auto, and prepare for extra
    		val = parseFloat( val ) || 0;
    	}
    
    	// Use the active box-sizing model to add/subtract irrelevant styles
    	return ( val +
    		augmentWidthOrHeight(
    			elem,
    			name,
    			extra || ( isBorderBox ? "border" : "content" ),
    			valueIsBorderBox,
    			styles
    		)
    	) + "px";
    }
    
    function showHide( elements, show ) {
    	var display, elem, hidden,
    		values = [],
    		index = 0,
    		length = elements.length;
    
    	for ( ; index < length; index++ ) {
    		elem = elements[ index ];
    		if ( !elem.style ) {
    			continue;
    		}
    
    		values[ index ] = dataPriv.get( elem, "olddisplay" );
    		display = elem.style.display;
    		if ( show ) {
    
    			// Reset the inline display of this element to learn if it is
    			// being hidden by cascaded rules or not
    			if ( !values[ index ] && display === "none" ) {
    				elem.style.display = "";
    			}
    
    			// Set elements which have been overridden with display: none
    			// in a stylesheet to whatever the default browser style is
    			// for such an element
    			if ( elem.style.display === "" && isHidden( elem ) ) {
    				values[ index ] = dataPriv.access(
    					elem,
    					"olddisplay",
    					defaultDisplay( elem.nodeName )
    				);
    			}
    		} else {
    			hidden = isHidden( elem );
    
    			if ( display !== "none" || !hidden ) {
    				dataPriv.set(
    					elem,
    					"olddisplay",
    					hidden ? display : jQuery.css( elem, "display" )
    				);
    			}
    		}
    	}
    
    	// Set the display of most of the elements in a second loop
    	// to avoid the constant reflow
    	for ( index = 0; index < length; index++ ) {
    		elem = elements[ index ];
    		if ( !elem.style ) {
    			continue;
    		}
    		if ( !show || elem.style.display === "none" || elem.style.display === "" ) {
    			elem.style.display = show ? values[ index ] || "" : "none";
    		}
    	}
    
    	return elements;
    }
    
    jQuery.extend( {
    
    	// Add in style property hooks for overriding the default
    	// behavior of getting and setting a style property
    	cssHooks: {
    		opacity: {
    			get: function( elem, computed ) {
    				if ( computed ) {
    
    					// We should always get a number back from opacity
    					var ret = curCSS( elem, "opacity" );
    					return ret === "" ? "1" : ret;
    				}
    			}
    		}
    	},
    
    	// Don't automatically add "px" to these possibly-unitless properties
    	cssNumber: {
    		"animationIterationCount": true,
    		"columnCount": true,
    		"fillOpacity": true,
    		"flexGrow": true,
    		"flexShrink": true,
    		"fontWeight": true,
    		"lineHeight": true,
    		"opacity": true,
    		"order": true,
    		"orphans": true,
    		"widows": true,
    		"zIndex": true,
    		"zoom": true
    	},
    
    	// Add in properties whose names you wish to fix before
    	// setting or getting the value
    	cssProps: {
    		"float": "cssFloat"
    	},
    
    	// Get and set the style property on a DOM Node
    	style: function( elem, name, value, extra ) {
    
    		// Don't set styles on text and comment nodes
    		if ( !elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style ) {
    			return;
    		}
    
    		// Make sure that we're working with the right name
    		var ret, type, hooks,
    			origName = jQuery.camelCase( name ),
    			style = elem.style;
    
    		name = jQuery.cssProps[ origName ] ||
    			( jQuery.cssProps[ origName ] = vendorPropName( origName ) || origName );
    
    		// Gets hook for the prefixed version, then unprefixed version
    		hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];
    
    		// Check if we're setting a value
    		if ( value !== undefined ) {
    			type = typeof value;
    
    			// Convert "+=" or "-=" to relative numbers (#7345)
    			if ( type === "string" && ( ret = rcssNum.exec( value ) ) && ret[ 1 ] ) {
    				value = adjustCSS( elem, name, ret );
    
    				// Fixes bug #9237
    				type = "number";
    			}
    
    			// Make sure that null and NaN values aren't set (#7116)
    			if ( value == null || value !== value ) {
    				return;
    			}
    
    			// If a number was passed in, add the unit (except for certain CSS properties)
    			if ( type === "number" ) {
    				value += ret && ret[ 3 ] || ( jQuery.cssNumber[ origName ] ? "" : "px" );
    			}
    
    			// Support: IE9-11+
    			// background-* props affect original clone's values
    			if ( !support.clearCloneStyle && value === "" && name.indexOf( "background" ) === 0 ) {
    				style[ name ] = "inherit";
    			}
    
    			// If a hook was provided, use that value, otherwise just set the specified value
    			if ( !hooks || !( "set" in hooks ) ||
    				( value = hooks.set( elem, value, extra ) ) !== undefined ) {
    
    				style[ name ] = value;
    			}
    
    		} else {
    
    			// If a hook was provided get the non-computed value from there
    			if ( hooks && "get" in hooks &&
    				( ret = hooks.get( elem, false, extra ) ) !== undefined ) {
    
    				return ret;
    			}
    
    			// Otherwise just get the value from the style object
    			return style[ name ];
    		}
    	},
    
    	css: function( elem, name, extra, styles ) {
    		var val, num, hooks,
    			origName = jQuery.camelCase( name );
    
    		// Make sure that we're working with the right name
    		name = jQuery.cssProps[ origName ] ||
    			( jQuery.cssProps[ origName ] = vendorPropName( origName ) || origName );
    
    		// Try prefixed name followed by the unprefixed name
    		hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];
    
    		// If a hook was provided get the computed value from there
    		if ( hooks && "get" in hooks ) {
    			val = hooks.get( elem, true, extra );
    		}
    
    		// Otherwise, if a way to get the computed value exists, use that
    		if ( val === undefined ) {
    			val = curCSS( elem, name, styles );
    		}
    
    		// Convert "normal" to computed value
    		if ( val === "normal" && name in cssNormalTransform ) {
    			val = cssNormalTransform[ name ];
    		}
    
    		// Make numeric if forced or a qualifier was provided and val looks numeric
    		if ( extra === "" || extra ) {
    			num = parseFloat( val );
    			return extra === true || isFinite( num ) ? num || 0 : val;
    		}
    		return val;
    	}
    } );
    
    jQuery.each( [ "height", "width" ], function( i, name ) {
    	jQuery.cssHooks[ name ] = {
    		get: function( elem, computed, extra ) {
    			if ( computed ) {
    
    				// Certain elements can have dimension info if we invisibly show them
    				// but it must have a current display style that would benefit
    				return rdisplayswap.test( jQuery.css( elem, "display" ) ) &&
    					elem.offsetWidth === 0 ?
    						swap( elem, cssShow, function() {
    							return getWidthOrHeight( elem, name, extra );
    						} ) :
    						getWidthOrHeight( elem, name, extra );
    			}
    		},
    
    		set: function( elem, value, extra ) {
    			var matches,
    				styles = extra && getStyles( elem ),
    				subtract = extra && augmentWidthOrHeight(
    					elem,
    					name,
    					extra,
    					jQuery.css( elem, "boxSizing", false, styles ) === "border-box",
    					styles
    				);
    
    			// Convert to pixels if value adjustment is needed
    			if ( subtract && ( matches = rcssNum.exec( value ) ) &&
    				( matches[ 3 ] || "px" ) !== "px" ) {
    
    				elem.style[ name ] = value;
    				value = jQuery.css( elem, name );
    			}
    
    			return setPositiveNumber( elem, value, subtract );
    		}
    	};
    } );
    
    jQuery.cssHooks.marginLeft = addGetHookIf( support.reliableMarginLeft,
    	function( elem, computed ) {
    		if ( computed ) {
    			return ( parseFloat( curCSS( elem, "marginLeft" ) ) ||
    				elem.getBoundingClientRect().left -
    					swap( elem, { marginLeft: 0 }, function() {
    						return elem.getBoundingClientRect().left;
    					} )
    				) + "px";
    		}
    	}
    );
    
    // Support: Android 2.3
    jQuery.cssHooks.marginRight = addGetHookIf( support.reliableMarginRight,
    	function( elem, computed ) {
    		if ( computed ) {
    			return swap( elem, { "display": "inline-block" },
    				curCSS, [ elem, "marginRight" ] );
    		}
    	}
    );
    
    // These hooks are used by animate to expand properties
    jQuery.each( {
    	margin: "",
    	padding: "",
    	border: "Width"
    }, function( prefix, suffix ) {
    	jQuery.cssHooks[ prefix + suffix ] = {
    		expand: function( value ) {
    			var i = 0,
    				expanded = {},
    
    				// Assumes a single number if not a string
    				parts = typeof value === "string" ? value.split( " " ) : [ value ];
    
    			for ( ; i < 4; i++ ) {
    				expanded[ prefix + cssExpand[ i ] + suffix ] =
    					parts[ i ] || parts[ i - 2 ] || parts[ 0 ];
    			}
    
    			return expanded;
    		}
    	};
    
    	if ( !rmargin.test( prefix ) ) {
    		jQuery.cssHooks[ prefix + suffix ].set = setPositiveNumber;
    	}
    } );
    
    jQuery.fn.extend( {
    	css: function( name, value ) {
    		return access( this, function( elem, name, value ) {
    			var styles, len,
    				map = {},
    				i = 0;
    
    			if ( jQuery.isArray( name ) ) {
    				styles = getStyles( elem );
    				len = name.length;
    
    				for ( ; i < len; i++ ) {
    					map[ name[ i ] ] = jQuery.css( elem, name[ i ], false, styles );
    				}
    
    				return map;
    			}
    
    			return value !== undefined ?
    				jQuery.style( elem, name, value ) :
    				jQuery.css( elem, name );
    		}, name, value, arguments.length > 1 );
    	},
    	show: function() {
    		return showHide( this, true );
    	},
    	hide: function() {
    		return showHide( this );
    	},
    	toggle: function( state ) {
    		if ( typeof state === "boolean" ) {
    			return state ? this.show() : this.hide();
    		}
    
    		return this.each( function() {
    			if ( isHidden( this ) ) {
    				jQuery( this ).show();
    			} else {
    				jQuery( this ).hide();
    			}
    		} );
    	}
    } );
    
    
    function Tween( elem, options, prop, end, easing ) {
    	return new Tween.prototype.init( elem, options, prop, end, easing );
    }
    jQuery.Tween = Tween;
    
    Tween.prototype = {
    	constructor: Tween,
    	init: function( elem, options, prop, end, easing, unit ) {
    		this.elem = elem;
    		this.prop = prop;
    		this.easing = easing || jQuery.easing._default;
    		this.options = options;
    		this.start = this.now = this.cur();
    		this.end = end;
    		this.unit = unit || ( jQuery.cssNumber[ prop ] ? "" : "px" );
    	},
    	cur: function() {
    		var hooks = Tween.propHooks[ this.prop ];
    
    		return hooks && hooks.get ?
    			hooks.get( this ) :
    			Tween.propHooks._default.get( this );
    	},
    	run: function( percent ) {
    		var eased,
    			hooks = Tween.propHooks[ this.prop ];
    
    		if ( this.options.duration ) {
    			this.pos = eased = jQuery.easing[ this.easing ](
    				percent, this.options.duration * percent, 0, 1, this.options.duration
    			);
    		} else {
    			this.pos = eased = percent;
    		}
    		this.now = ( this.end - this.start ) * eased + this.start;
    
    		if ( this.options.step ) {
    			this.options.step.call( this.elem, this.now, this );
    		}
    
    		if ( hooks && hooks.set ) {
    			hooks.set( this );
    		} else {
    			Tween.propHooks._default.set( this );
    		}
    		return this;
    	}
    };
    
    Tween.prototype.init.prototype = Tween.prototype;
    
    Tween.propHooks = {
    	_default: {
    		get: function( tween ) {
    			var result;
    
    			// Use a property on the element directly when it is not a DOM element,
    			// or when there is no matching style property that exists.
    			if ( tween.elem.nodeType !== 1 ||
    				tween.elem[ tween.prop ] != null && tween.elem.style[ tween.prop ] == null ) {
    				return tween.elem[ tween.prop ];
    			}
    
    			// Passing an empty string as a 3rd parameter to .css will automatically
    			// attempt a parseFloat and fallback to a string if the parse fails.
    			// Simple values such as "10px" are parsed to Float;
    			// complex values such as "rotate(1rad)" are returned as-is.
    			result = jQuery.css( tween.elem, tween.prop, "" );
    
    			// Empty strings, null, undefined and "auto" are converted to 0.
    			return !result || result === "auto" ? 0 : result;
    		},
    		set: function( tween ) {
    
    			// Use step hook for back compat.
    			// Use cssHook if its there.
    			// Use .style if available and use plain properties where available.
    			if ( jQuery.fx.step[ tween.prop ] ) {
    				jQuery.fx.step[ tween.prop ]( tween );
    			} else if ( tween.elem.nodeType === 1 &&
    				( tween.elem.style[ jQuery.cssProps[ tween.prop ] ] != null ||
    					jQuery.cssHooks[ tween.prop ] ) ) {
    				jQuery.style( tween.elem, tween.prop, tween.now + tween.unit );
    			} else {
    				tween.elem[ tween.prop ] = tween.now;
    			}
    		}
    	}
    };
    
    // Support: IE9
    // Panic based approach to setting things on disconnected nodes
    Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {
    	set: function( tween ) {
    		if ( tween.elem.nodeType && tween.elem.parentNode ) {
    			tween.elem[ tween.prop ] = tween.now;
    		}
    	}
    };
    
    jQuery.easing = {
    	linear: function( p ) {
    		return p;
    	},
    	swing: function( p ) {
    		return 0.5 - Math.cos( p * Math.PI ) / 2;
    	},
    	_default: "swing"
    };
    
    jQuery.fx = Tween.prototype.init;
    
    // Back Compat <1.8 extension point
    jQuery.fx.step = {};
    
    
    
    
    var
    	fxNow, timerId,
    	rfxtypes = /^(?:toggle|show|hide)$/,
    	rrun = /queueHooks$/;
    
    // Animations created synchronously will run synchronously
    function createFxNow() {
    	window.setTimeout( function() {
    		fxNow = undefined;
    	} );
    	return ( fxNow = jQuery.now() );
    }
    
    // Generate parameters to create a standard animation
    function genFx( type, includeWidth ) {
    	var which,
    		i = 0,
    		attrs = { height: type };
    
    	// If we include width, step value is 1 to do all cssExpand values,
    	// otherwise step value is 2 to skip over Left and Right
    	includeWidth = includeWidth ? 1 : 0;
    	for ( ; i < 4 ; i += 2 - includeWidth ) {
    		which = cssExpand[ i ];
    		attrs[ "margin" + which ] = attrs[ "padding" + which ] = type;
    	}
    
    	if ( includeWidth ) {
    		attrs.opacity = attrs.width = type;
    	}
    
    	return attrs;
    }
    
    function createTween( value, prop, animation ) {
    	var tween,
    		collection = ( Animation.tweeners[ prop ] || [] ).concat( Animation.tweeners[ "*" ] ),
    		index = 0,
    		length = collection.length;
    	for ( ; index < length; index++ ) {
    		if ( ( tween = collection[ index ].call( animation, prop, value ) ) ) {
    
    			// We're done with this property
    			return tween;
    		}
    	}
    }
    
    function defaultPrefilter( elem, props, opts ) {
    	/* jshint validthis: true */
    	var prop, value, toggle, tween, hooks, oldfire, display, checkDisplay,
    		anim = this,
    		orig = {},
    		style = elem.style,
    		hidden = elem.nodeType && isHidden( elem ),
    		dataShow = dataPriv.get( elem, "fxshow" );
    
    	// Handle queue: false promises
    	if ( !opts.queue ) {
    		hooks = jQuery._queueHooks( elem, "fx" );
    		if ( hooks.unqueued == null ) {
    			hooks.unqueued = 0;
    			oldfire = hooks.empty.fire;
    			hooks.empty.fire = function() {
    				if ( !hooks.unqueued ) {
    					oldfire();
    				}
    			};
    		}
    		hooks.unqueued++;
    
    		anim.always( function() {
    
    			// Ensure the complete handler is called before this completes
    			anim.always( function() {
    				hooks.unqueued--;
    				if ( !jQuery.queue( elem, "fx" ).length ) {
    					hooks.empty.fire();
    				}
    			} );
    		} );
    	}
    
    	// Height/width overflow pass
    	if ( elem.nodeType === 1 && ( "height" in props || "width" in props ) ) {
    
    		// Make sure that nothing sneaks out
    		// Record all 3 overflow attributes because IE9-10 do not
    		// change the overflow attribute when overflowX and
    		// overflowY are set to the same value
    		opts.overflow = [ style.overflow, style.overflowX, style.overflowY ];
    
    		// Set display property to inline-block for height/width
    		// animations on inline elements that are having width/height animated
    		display = jQuery.css( elem, "display" );
    
    		// Test default display if display is currently "none"
    		checkDisplay = display === "none" ?
    			dataPriv.get( elem, "olddisplay" ) || defaultDisplay( elem.nodeName ) : display;
    
    		if ( checkDisplay === "inline" && jQuery.css( elem, "float" ) === "none" ) {
    			style.display = "inline-block";
    		}
    	}
    
    	if ( opts.overflow ) {
    		style.overflow = "hidden";
    		anim.always( function() {
    			style.overflow = opts.overflow[ 0 ];
    			style.overflowX = opts.overflow[ 1 ];
    			style.overflowY = opts.overflow[ 2 ];
    		} );
    	}
    
    	// show/hide pass
    	for ( prop in props ) {
    		value = props[ prop ];
    		if ( rfxtypes.exec( value ) ) {
    			delete props[ prop ];
    			toggle = toggle || value === "toggle";
    			if ( value === ( hidden ? "hide" : "show" ) ) {
    
    				// If there is dataShow left over from a stopped hide or show
    				// and we are going to proceed with show, we should pretend to be hidden
    				if ( value === "show" && dataShow && dataShow[ prop ] !== undefined ) {
    					hidden = true;
    				} else {
    					continue;
    				}
    			}
    			orig[ prop ] = dataShow && dataShow[ prop ] || jQuery.style( elem, prop );
    
    		// Any non-fx value stops us from restoring the original display value
    		} else {
    			display = undefined;
    		}
    	}
    
    	if ( !jQuery.isEmptyObject( orig ) ) {
    		if ( dataShow ) {
    			if ( "hidden" in dataShow ) {
    				hidden = dataShow.hidden;
    			}
    		} else {
    			dataShow = dataPriv.access( elem, "fxshow", {} );
    		}
    
    		// Store state if its toggle - enables .stop().toggle() to "reverse"
    		if ( toggle ) {
    			dataShow.hidden = !hidden;
    		}
    		if ( hidden ) {
    			jQuery( elem ).show();
    		} else {
    			anim.done( function() {
    				jQuery( elem ).hide();
    			} );
    		}
    		anim.done( function() {
    			var prop;
    
    			dataPriv.remove( elem, "fxshow" );
    			for ( prop in orig ) {
    				jQuery.style( elem, prop, orig[ prop ] );
    			}
    		} );
    		for ( prop in orig ) {
    			tween = createTween( hidden ? dataShow[ prop ] : 0, prop, anim );
    
    			if ( !( prop in dataShow ) ) {
    				dataShow[ prop ] = tween.start;
    				if ( hidden ) {
    					tween.end = tween.start;
    					tween.start = prop === "width" || prop === "height" ? 1 : 0;
    				}
    			}
    		}
    
    	// If this is a noop like .hide().hide(), restore an overwritten display value
    	} else if ( ( display === "none" ? defaultDisplay( elem.nodeName ) : display ) === "inline" ) {
    		style.display = display;
    	}
    }
    
    function propFilter( props, specialEasing ) {
    	var index, name, easing, value, hooks;
    
    	// camelCase, specialEasing and expand cssHook pass
    	for ( index in props ) {
    		name = jQuery.camelCase( index );
    		easing = specialEasing[ name ];
    		value = props[ index ];
    		if ( jQuery.isArray( value ) ) {
    			easing = value[ 1 ];
    			value = props[ index ] = value[ 0 ];
    		}
    
    		if ( index !== name ) {
    			props[ name ] = value;
    			delete props[ index ];
    		}
    
    		hooks = jQuery.cssHooks[ name ];
    		if ( hooks && "expand" in hooks ) {
    			value = hooks.expand( value );
    			delete props[ name ];
    
    			// Not quite $.extend, this won't overwrite existing keys.
    			// Reusing 'index' because we have the correct "name"
    			for ( index in value ) {
    				if ( !( index in props ) ) {
    					props[ index ] = value[ index ];
    					specialEasing[ index ] = easing;
    				}
    			}
    		} else {
    			specialEasing[ name ] = easing;
    		}
    	}
    }
    
    function Animation( elem, properties, options ) {
    	var result,
    		stopped,
    		index = 0,
    		length = Animation.prefilters.length,
    		deferred = jQuery.Deferred().always( function() {
    
    			// Don't match elem in the :animated selector
    			delete tick.elem;
    		} ),
    		tick = function() {
    			if ( stopped ) {
    				return false;
    			}
    			var currentTime = fxNow || createFxNow(),
    				remaining = Math.max( 0, animation.startTime + animation.duration - currentTime ),
    
    				// Support: Android 2.3
    				// Archaic crash bug won't allow us to use `1 - ( 0.5 || 0 )` (#12497)
    				temp = remaining / animation.duration || 0,
    				percent = 1 - temp,
    				index = 0,
    				length = animation.tweens.length;
    
    			for ( ; index < length ; index++ ) {
    				animation.tweens[ index ].run( percent );
    			}
    
    			deferred.notifyWith( elem, [ animation, percent, remaining ] );
    
    			if ( percent < 1 && length ) {
    				return remaining;
    			} else {
    				deferred.resolveWith( elem, [ animation ] );
    				return false;
    			}
    		},
    		animation = deferred.promise( {
    			elem: elem,
    			props: jQuery.extend( {}, properties ),
    			opts: jQuery.extend( true, {
    				specialEasing: {},
    				easing: jQuery.easing._default
    			}, options ),
    			originalProperties: properties,
    			originalOptions: options,
    			startTime: fxNow || createFxNow(),
    			duration: options.duration,
    			tweens: [],
    			createTween: function( prop, end ) {
    				var tween = jQuery.Tween( elem, animation.opts, prop, end,
    						animation.opts.specialEasing[ prop ] || animation.opts.easing );
    				animation.tweens.push( tween );
    				return tween;
    			},
    			stop: function( gotoEnd ) {
    				var index = 0,
    
    					// If we are going to the end, we want to run all the tweens
    					// otherwise we skip this part
    					length = gotoEnd ? animation.tweens.length : 0;
    				if ( stopped ) {
    					return this;
    				}
    				stopped = true;
    				for ( ; index < length ; index++ ) {
    					animation.tweens[ index ].run( 1 );
    				}
    
    				// Resolve when we played the last frame; otherwise, reject
    				if ( gotoEnd ) {
    					deferred.notifyWith( elem, [ animation, 1, 0 ] );
    					deferred.resolveWith( elem, [ animation, gotoEnd ] );
    				} else {
    					deferred.rejectWith( elem, [ animation, gotoEnd ] );
    				}
    				return this;
    			}
    		} ),
    		props = animation.props;
    
    	propFilter( props, animation.opts.specialEasing );
    
    	for ( ; index < length ; index++ ) {
    		result = Animation.prefilters[ index ].call( animation, elem, props, animation.opts );
    		if ( result ) {
    			if ( jQuery.isFunction( result.stop ) ) {
    				jQuery._queueHooks( animation.elem, animation.opts.queue ).stop =
    					jQuery.proxy( result.stop, result );
    			}
    			return result;
    		}
    	}
    
    	jQuery.map( props, createTween, animation );
    
    	if ( jQuery.isFunction( animation.opts.start ) ) {
    		animation.opts.start.call( elem, animation );
    	}
    
    	jQuery.fx.timer(
    		jQuery.extend( tick, {
    			elem: elem,
    			anim: animation,
    			queue: animation.opts.queue
    		} )
    	);
    
    	// attach callbacks from options
    	return animation.progress( animation.opts.progress )
    		.done( animation.opts.done, animation.opts.complete )
    		.fail( animation.opts.fail )
    		.always( animation.opts.always );
    }
    
    jQuery.Animation = jQuery.extend( Animation, {
    	tweeners: {
    		"*": [ function( prop, value ) {
    			var tween = this.createTween( prop, value );
    			adjustCSS( tween.elem, prop, rcssNum.exec( value ), tween );
    			return tween;
    		} ]
    	},
    
    	tweener: function( props, callback ) {
    		if ( jQuery.isFunction( props ) ) {
    			callback = props;
    			props = [ "*" ];
    		} else {
    			props = props.match( rnotwhite );
    		}
    
    		var prop,
    			index = 0,
    			length = props.length;
    
    		for ( ; index < length ; index++ ) {
    			prop = props[ index ];
    			Animation.tweeners[ prop ] = Animation.tweeners[ prop ] || [];
    			Animation.tweeners[ prop ].unshift( callback );
    		}
    	},
    
    	prefilters: [ defaultPrefilter ],
    
    	prefilter: function( callback, prepend ) {
    		if ( prepend ) {
    			Animation.prefilters.unshift( callback );
    		} else {
    			Animation.prefilters.push( callback );
    		}
    	}
    } );
    
    jQuery.speed = function( speed, easing, fn ) {
    	var opt = speed && typeof speed === "object" ? jQuery.extend( {}, speed ) : {
    		complete: fn || !fn && easing ||
    			jQuery.isFunction( speed ) && speed,
    		duration: speed,
    		easing: fn && easing || easing && !jQuery.isFunction( easing ) && easing
    	};
    
    	opt.duration = jQuery.fx.off ? 0 : typeof opt.duration === "number" ?
    		opt.duration : opt.duration in jQuery.fx.speeds ?
    			jQuery.fx.speeds[ opt.duration ] : jQuery.fx.speeds._default;
    
    	// Normalize opt.queue - true/undefined/null -> "fx"
    	if ( opt.queue == null || opt.queue === true ) {
    		opt.queue = "fx";
    	}
    
    	// Queueing
    	opt.old = opt.complete;
    
    	opt.complete = function() {
    		if ( jQuery.isFunction( opt.old ) ) {
    			opt.old.call( this );
    		}
    
    		if ( opt.queue ) {
    			jQuery.dequeue( this, opt.queue );
    		}
    	};
    
    	return opt;
    };
    
    jQuery.fn.extend( {
    	fadeTo: function( speed, to, easing, callback ) {
    
    		// Show any hidden elements after setting opacity to 0
    		return this.filter( isHidden ).css( "opacity", 0 ).show()
    
    			// Animate to the value specified
    			.end().animate( { opacity: to }, speed, easing, callback );
    	},
    	animate: function( prop, speed, easing, callback ) {
    		var empty = jQuery.isEmptyObject( prop ),
    			optall = jQuery.speed( speed, easing, callback ),
    			doAnimation = function() {
    
    				// Operate on a copy of prop so per-property easing won't be lost
    				var anim = Animation( this, jQuery.extend( {}, prop ), optall );
    
    				// Empty animations, or finishing resolves immediately
    				if ( empty || dataPriv.get( this, "finish" ) ) {
    					anim.stop( true );
    				}
    			};
    			doAnimation.finish = doAnimation;
    
    		return empty || optall.queue === false ?
    			this.each( doAnimation ) :
    			this.queue( optall.queue, doAnimation );
    	},
    	stop: function( type, clearQueue, gotoEnd ) {
    		var stopQueue = function( hooks ) {
    			var stop = hooks.stop;
    			delete hooks.stop;
    			stop( gotoEnd );
    		};
    
    		if ( typeof type !== "string" ) {
    			gotoEnd = clearQueue;
    			clearQueue = type;
    			type = undefined;
    		}
    		if ( clearQueue && type !== false ) {
    			this.queue( type || "fx", [] );
    		}
    
    		return this.each( function() {
    			var dequeue = true,
    				index = type != null && type + "queueHooks",
    				timers = jQuery.timers,
    				data = dataPriv.get( this );
    
    			if ( index ) {
    				if ( data[ index ] && data[ index ].stop ) {
    					stopQueue( data[ index ] );
    				}
    			} else {
    				for ( index in data ) {
    					if ( data[ index ] && data[ index ].stop && rrun.test( index ) ) {
    						stopQueue( data[ index ] );
    					}
    				}
    			}
    
    			for ( index = timers.length; index--; ) {
    				if ( timers[ index ].elem === this &&
    					( type == null || timers[ index ].queue === type ) ) {
    
    					timers[ index ].anim.stop( gotoEnd );
    					dequeue = false;
    					timers.splice( index, 1 );
    				}
    			}
    
    			// Start the next in the queue if the last step wasn't forced.
    			// Timers currently will call their complete callbacks, which
    			// will dequeue but only if they were gotoEnd.
    			if ( dequeue || !gotoEnd ) {
    				jQuery.dequeue( this, type );
    			}
    		} );
    	},
    	finish: function( type ) {
    		if ( type !== false ) {
    			type = type || "fx";
    		}
    		return this.each( function() {
    			var index,
    				data = dataPriv.get( this ),
    				queue = data[ type + "queue" ],
    				hooks = data[ type + "queueHooks" ],
    				timers = jQuery.timers,
    				length = queue ? queue.length : 0;
    
    			// Enable finishing flag on private data
    			data.finish = true;
    
    			// Empty the queue first
    			jQuery.queue( this, type, [] );
    
    			if ( hooks && hooks.stop ) {
    				hooks.stop.call( this, true );
    			}
    
    			// Look for any active animations, and finish them
    			for ( index = timers.length; index--; ) {
    				if ( timers[ index ].elem === this && timers[ index ].queue === type ) {
    					timers[ index ].anim.stop( true );
    					timers.splice( index, 1 );
    				}
    			}
    
    			// Look for any animations in the old queue and finish them
    			for ( index = 0; index < length; index++ ) {
    				if ( queue[ index ] && queue[ index ].finish ) {
    					queue[ index ].finish.call( this );
    				}
    			}
    
    			// Turn off finishing flag
    			delete data.finish;
    		} );
    	}
    } );
    
    jQuery.each( [ "toggle", "show", "hide" ], function( i, name ) {
    	var cssFn = jQuery.fn[ name ];
    	jQuery.fn[ name ] = function( speed, easing, callback ) {
    		return speed == null || typeof speed === "boolean" ?
    			cssFn.apply( this, arguments ) :
    			this.animate( genFx( name, true ), speed, easing, callback );
    	};
    } );
    
    // Generate shortcuts for custom animations
    jQuery.each( {
    	slideDown: genFx( "show" ),
    	slideUp: genFx( "hide" ),
    	slideToggle: genFx( "toggle" ),
    	fadeIn: { opacity: "show" },
    	fadeOut: { opacity: "hide" },
    	fadeToggle: { opacity: "toggle" }
    }, function( name, props ) {
    	jQuery.fn[ name ] = function( speed, easing, callback ) {
    		return this.animate( props, speed, easing, callback );
    	};
    } );
    
    jQuery.timers = [];
    jQuery.fx.tick = function() {
    	var timer,
    		i = 0,
    		timers = jQuery.timers;
    
    	fxNow = jQuery.now();
    
    	for ( ; i < timers.length; i++ ) {
    		timer = timers[ i ];
    
    		// Checks the timer has not already been removed
    		if ( !timer() && timers[ i ] === timer ) {
    			timers.splice( i--, 1 );
    		}
    	}
    
    	if ( !timers.length ) {
    		jQuery.fx.stop();
    	}
    	fxNow = undefined;
    };
    
    jQuery.fx.timer = function( timer ) {
    	jQuery.timers.push( timer );
    	if ( timer() ) {
    		jQuery.fx.start();
    	} else {
    		jQuery.timers.pop();
    	}
    };
    
    jQuery.fx.interval = 13;
    jQuery.fx.start = function() {
    	if ( !timerId ) {
    		timerId = window.setInterval( jQuery.fx.tick, jQuery.fx.interval );
    	}
    };
    
    jQuery.fx.stop = function() {
    	window.clearInterval( timerId );
    
    	timerId = null;
    };
    
    jQuery.fx.speeds = {
    	slow: 600,
    	fast: 200,
    
    	// Default speed
    	_default: 400
    };
    
    
    // Based off of the plugin by Clint Helfers, with permission.
    // http://web.archive.org/web/20100324014747/http://blindsignals.com/index.php/2009/07/jquery-delay/
    jQuery.fn.delay = function( time, type ) {
    	time = jQuery.fx ? jQuery.fx.speeds[ time ] || time : time;
    	type = type || "fx";
    
    	return this.queue( type, function( next, hooks ) {
    		var timeout = window.setTimeout( next, time );
    		hooks.stop = function() {
    			window.clearTimeout( timeout );
    		};
    	} );
    };
    
    
    ( function() {
    	var input = document.createElement( "input" ),
    		select = document.createElement( "select" ),
    		opt = select.appendChild( document.createElement( "option" ) );
    
    	input.type = "checkbox";
    
    	// Support: iOS<=5.1, Android<=4.2+
    	// Default value for a checkbox should be "on"
    	support.checkOn = input.value !== "";
    
    	// Support: IE<=11+
    	// Must access selectedIndex to make default options select
    	support.optSelected = opt.selected;
    
    	// Support: Android<=2.3
    	// Options inside disabled selects are incorrectly marked as disabled
    	select.disabled = true;
    	support.optDisabled = !opt.disabled;
    
    	// Support: IE<=11+
    	// An input loses its value after becoming a radio
    	input = document.createElement( "input" );
    	input.value = "t";
    	input.type = "radio";
    	support.radioValue = input.value === "t";
    } )();
    
    
    var boolHook,
    	attrHandle = jQuery.expr.attrHandle;
    
    jQuery.fn.extend( {
    	attr: function( name, value ) {
    		return access( this, jQuery.attr, name, value, arguments.length > 1 );
    	},
    
    	removeAttr: function( name ) {
    		return this.each( function() {
    			jQuery.removeAttr( this, name );
    		} );
    	}
    } );
    
    jQuery.extend( {
    	attr: function( elem, name, value ) {
    		var ret, hooks,
    			nType = elem.nodeType;
    
    		// Don't get/set attributes on text, comment and attribute nodes
    		if ( nType === 3 || nType === 8 || nType === 2 ) {
    			return;
    		}
    
    		// Fallback to prop when attributes are not supported
    		if ( typeof elem.getAttribute === "undefined" ) {
    			return jQuery.prop( elem, name, value );
    		}
    
    		// All attributes are lowercase
    		// Grab necessary hook if one is defined
    		if ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {
    			name = name.toLowerCase();
    			hooks = jQuery.attrHooks[ name ] ||
    				( jQuery.expr.match.bool.test( name ) ? boolHook : undefined );
    		}
    
    		if ( value !== undefined ) {
    			if ( value === null ) {
    				jQuery.removeAttr( elem, name );
    				return;
    			}
    
    			if ( hooks && "set" in hooks &&
    				( ret = hooks.set( elem, value, name ) ) !== undefined ) {
    				return ret;
    			}
    
    			elem.setAttribute( name, value + "" );
    			return value;
    		}
    
    		if ( hooks && "get" in hooks && ( ret = hooks.get( elem, name ) ) !== null ) {
    			return ret;
    		}
    
    		ret = jQuery.find.attr( elem, name );
    
    		// Non-existent attributes return null, we normalize to undefined
    		return ret == null ? undefined : ret;
    	},
    
    	attrHooks: {
    		type: {
    			set: function( elem, value ) {
    				if ( !support.radioValue && value === "radio" &&
    					jQuery.nodeName( elem, "input" ) ) {
    					var val = elem.value;
    					elem.setAttribute( "type", value );
    					if ( val ) {
    						elem.value = val;
    					}
    					return value;
    				}
    			}
    		}
    	},
    
    	removeAttr: function( elem, value ) {
    		var name, propName,
    			i = 0,
    			attrNames = value && value.match( rnotwhite );
    
    		if ( attrNames && elem.nodeType === 1 ) {
    			while ( ( name = attrNames[ i++ ] ) ) {
    				propName = jQuery.propFix[ name ] || name;
    
    				// Boolean attributes get special treatment (#10870)
    				if ( jQuery.expr.match.bool.test( name ) ) {
    
    					// Set corresponding property to false
    					elem[ propName ] = false;
    				}
    
    				elem.removeAttribute( name );
    			}
    		}
    	}
    } );
    
    // Hooks for boolean attributes
    boolHook = {
    	set: function( elem, value, name ) {
    		if ( value === false ) {
    
    			// Remove boolean attributes when set to false
    			jQuery.removeAttr( elem, name );
    		} else {
    			elem.setAttribute( name, name );
    		}
    		return name;
    	}
    };
    jQuery.each( jQuery.expr.match.bool.source.match( /\w+/g ), function( i, name ) {
    	var getter = attrHandle[ name ] || jQuery.find.attr;
    
    	attrHandle[ name ] = function( elem, name, isXML ) {
    		var ret, handle;
    		if ( !isXML ) {
    
    			// Avoid an infinite loop by temporarily removing this function from the getter
    			handle = attrHandle[ name ];
    			attrHandle[ name ] = ret;
    			ret = getter( elem, name, isXML ) != null ?
    				name.toLowerCase() :
    				null;
    			attrHandle[ name ] = handle;
    		}
    		return ret;
    	};
    } );
    
    
    
    
    var rfocusable = /^(?:input|select|textarea|button)$/i,
    	rclickable = /^(?:a|area)$/i;
    
    jQuery.fn.extend( {
    	prop: function( name, value ) {
    		return access( this, jQuery.prop, name, value, arguments.length > 1 );
    	},
    
    	removeProp: function( name ) {
    		return this.each( function() {
    			delete this[ jQuery.propFix[ name ] || name ];
    		} );
    	}
    } );
    
    jQuery.extend( {
    	prop: function( elem, name, value ) {
    		var ret, hooks,
    			nType = elem.nodeType;
    
    		// Don't get/set properties on text, comment and attribute nodes
    		if ( nType === 3 || nType === 8 || nType === 2 ) {
    			return;
    		}
    
    		if ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {
    
    			// Fix name and attach hooks
    			name = jQuery.propFix[ name ] || name;
    			hooks = jQuery.propHooks[ name ];
    		}
    
    		if ( value !== undefined ) {
    			if ( hooks && "set" in hooks &&
    				( ret = hooks.set( elem, value, name ) ) !== undefined ) {
    				return ret;
    			}
    
    			return ( elem[ name ] = value );
    		}
    
    		if ( hooks && "get" in hooks && ( ret = hooks.get( elem, name ) ) !== null ) {
    			return ret;
    		}
    
    		return elem[ name ];
    	},
    
    	propHooks: {
    		tabIndex: {
    			get: function( elem ) {
    
    				// elem.tabIndex doesn't always return the
    				// correct value when it hasn't been explicitly set
    				// http://fluidproject.org/blog/2008/01/09/getting-setting-and-removing-tabindex-values-with-javascript/
    				// Use proper attribute retrieval(#12072)
    				var tabindex = jQuery.find.attr( elem, "tabindex" );
    
    				return tabindex ?
    					parseInt( tabindex, 10 ) :
    					rfocusable.test( elem.nodeName ) ||
    						rclickable.test( elem.nodeName ) && elem.href ?
    							0 :
    							-1;
    			}
    		}
    	},
    
    	propFix: {
    		"for": "htmlFor",
    		"class": "className"
    	}
    } );
    
    if ( !support.optSelected ) {
    	jQuery.propHooks.selected = {
    		get: function( elem ) {
    			var parent = elem.parentNode;
    			if ( parent && parent.parentNode ) {
    				parent.parentNode.selectedIndex;
    			}
    			return null;
    		}
    	};
    }
    
    jQuery.each( [
    	"tabIndex",
    	"readOnly",
    	"maxLength",
    	"cellSpacing",
    	"cellPadding",
    	"rowSpan",
    	"colSpan",
    	"useMap",
    	"frameBorder",
    	"contentEditable"
    ], function() {
    	jQuery.propFix[ this.toLowerCase() ] = this;
    } );
    
    
    
    
    var rclass = /[\t\r\n\f]/g;
    
    function getClass( elem ) {
    	return elem.getAttribute && elem.getAttribute( "class" ) || "";
    }
    
    jQuery.fn.extend( {
    	addClass: function( value ) {
    		var classes, elem, cur, curValue, clazz, j, finalValue,
    			i = 0;
    
    		if ( jQuery.isFunction( value ) ) {
    			return this.each( function( j ) {
    				jQuery( this ).addClass( value.call( this, j, getClass( this ) ) );
    			} );
    		}
    
    		if ( typeof value === "string" && value ) {
    			classes = value.match( rnotwhite ) || [];
    
    			while ( ( elem = this[ i++ ] ) ) {
    				curValue = getClass( elem );
    				cur = elem.nodeType === 1 &&
    					( " " + curValue + " " ).replace( rclass, " " );
    
    				if ( cur ) {
    					j = 0;
    					while ( ( clazz = classes[ j++ ] ) ) {
    						if ( cur.indexOf( " " + clazz + " " ) < 0 ) {
    							cur += clazz + " ";
    						}
    					}
    
    					// Only assign if different to avoid unneeded rendering.
    					finalValue = jQuery.trim( cur );
    					if ( curValue !== finalValue ) {
    						elem.setAttribute( "class", finalValue );
    					}
    				}
    			}
    		}
    
    		return this;
    	},
    
    	removeClass: function( value ) {
    		var classes, elem, cur, curValue, clazz, j, finalValue,
    			i = 0;
    
    		if ( jQuery.isFunction( value ) ) {
    			return this.each( function( j ) {
    				jQuery( this ).removeClass( value.call( this, j, getClass( this ) ) );
    			} );
    		}
    
    		if ( !arguments.length ) {
    			return this.attr( "class", "" );
    		}
    
    		if ( typeof value === "string" && value ) {
    			classes = value.match( rnotwhite ) || [];
    
    			while ( ( elem = this[ i++ ] ) ) {
    				curValue = getClass( elem );
    
    				// This expression is here for better compressibility (see addClass)
    				cur = elem.nodeType === 1 &&
    					( " " + curValue + " " ).replace( rclass, " " );
    
    				if ( cur ) {
    					j = 0;
    					while ( ( clazz = classes[ j++ ] ) ) {
    
    						// Remove *all* instances
    						while ( cur.indexOf( " " + clazz + " " ) > -1 ) {
    							cur = cur.replace( " " + clazz + " ", " " );
    						}
    					}
    
    					// Only assign if different to avoid unneeded rendering.
    					finalValue = jQuery.trim( cur );
    					if ( curValue !== finalValue ) {
    						elem.setAttribute( "class", finalValue );
    					}
    				}
    			}
    		}
    
    		return this;
    	},
    
    	toggleClass: function( value, stateVal ) {
    		var type = typeof value;
    
    		if ( typeof stateVal === "boolean" && type === "string" ) {
    			return stateVal ? this.addClass( value ) : this.removeClass( value );
    		}
    
    		if ( jQuery.isFunction( value ) ) {
    			return this.each( function( i ) {
    				jQuery( this ).toggleClass(
    					value.call( this, i, getClass( this ), stateVal ),
    					stateVal
    				);
    			} );
    		}
    
    		return this.each( function() {
    			var className, i, self, classNames;
    
    			if ( type === "string" ) {
    
    				// Toggle individual class names
    				i = 0;
    				self = jQuery( this );
    				classNames = value.match( rnotwhite ) || [];
    
    				while ( ( className = classNames[ i++ ] ) ) {
    
    					// Check each className given, space separated list
    					if ( self.hasClass( className ) ) {
    						self.removeClass( className );
    					} else {
    						self.addClass( className );
    					}
    				}
    
    			// Toggle whole class name
    			} else if ( value === undefined || type === "boolean" ) {
    				className = getClass( this );
    				if ( className ) {
    
    					// Store className if set
    					dataPriv.set( this, "__className__", className );
    				}
    
    				// If the element has a class name or if we're passed `false`,
    				// then remove the whole classname (if there was one, the above saved it).
    				// Otherwise bring back whatever was previously saved (if anything),
    				// falling back to the empty string if nothing was stored.
    				if ( this.setAttribute ) {
    					this.setAttribute( "class",
    						className || value === false ?
    						"" :
    						dataPriv.get( this, "__className__" ) || ""
    					);
    				}
    			}
    		} );
    	},
    
    	hasClass: function( selector ) {
    		var className, elem,
    			i = 0;
    
    		className = " " + selector + " ";
    		while ( ( elem = this[ i++ ] ) ) {
    			if ( elem.nodeType === 1 &&
    				( " " + getClass( elem ) + " " ).replace( rclass, " " )
    					.indexOf( className ) > -1
    			) {
    				return true;
    			}
    		}
    
    		return false;
    	}
    } );
    
    
    
    
    var rreturn = /\r/g;
    
    jQuery.fn.extend( {
    	val: function( value ) {
    		var hooks, ret, isFunction,
    			elem = this[ 0 ];
    
    		if ( !arguments.length ) {
    			if ( elem ) {
    				hooks = jQuery.valHooks[ elem.type ] ||
    					jQuery.valHooks[ elem.nodeName.toLowerCase() ];
    
    				if ( hooks &&
    					"get" in hooks &&
    					( ret = hooks.get( elem, "value" ) ) !== undefined
    				) {
    					return ret;
    				}
    
    				ret = elem.value;
    
    				return typeof ret === "string" ?
    
    					// Handle most common string cases
    					ret.replace( rreturn, "" ) :
    
    					// Handle cases where value is null/undef or number
    					ret == null ? "" : ret;
    			}
    
    			return;
    		}
    
    		isFunction = jQuery.isFunction( value );
    
    		return this.each( function( i ) {
    			var val;
    
    			if ( this.nodeType !== 1 ) {
    				return;
    			}
    
    			if ( isFunction ) {
    				val = value.call( this, i, jQuery( this ).val() );
    			} else {
    				val = value;
    			}
    
    			// Treat null/undefined as ""; convert numbers to string
    			if ( val == null ) {
    				val = "";
    
    			} else if ( typeof val === "number" ) {
    				val += "";
    
    			} else if ( jQuery.isArray( val ) ) {
    				val = jQuery.map( val, function( value ) {
    					return value == null ? "" : value + "";
    				} );
    			}
    
    			hooks = jQuery.valHooks[ this.type ] || jQuery.valHooks[ this.nodeName.toLowerCase() ];
    
    			// If set returns undefined, fall back to normal setting
    			if ( !hooks || !( "set" in hooks ) || hooks.set( this, val, "value" ) === undefined ) {
    				this.value = val;
    			}
    		} );
    	}
    } );
    
    jQuery.extend( {
    	valHooks: {
    		option: {
    			get: function( elem ) {
    
    				// Support: IE<11
    				// option.value not trimmed (#14858)
    				return jQuery.trim( elem.value );
    			}
    		},
    		select: {
    			get: function( elem ) {
    				var value, option,
    					options = elem.options,
    					index = elem.selectedIndex,
    					one = elem.type === "select-one" || index < 0,
    					values = one ? null : [],
    					max = one ? index + 1 : options.length,
    					i = index < 0 ?
    						max :
    						one ? index : 0;
    
    				// Loop through all the selected options
    				for ( ; i < max; i++ ) {
    					option = options[ i ];
    
    					// IE8-9 doesn't update selected after form reset (#2551)
    					if ( ( option.selected || i === index ) &&
    
    							// Don't return options that are disabled or in a disabled optgroup
    							( support.optDisabled ?
    								!option.disabled : option.getAttribute( "disabled" ) === null ) &&
    							( !option.parentNode.disabled ||
    								!jQuery.nodeName( option.parentNode, "optgroup" ) ) ) {
    
    						// Get the specific value for the option
    						value = jQuery( option ).val();
    
    						// We don't need an array for one selects
    						if ( one ) {
    							return value;
    						}
    
    						// Multi-Selects return an array
    						values.push( value );
    					}
    				}
    
    				return values;
    			},
    
    			set: function( elem, value ) {
    				var optionSet, option,
    					options = elem.options,
    					values = jQuery.makeArray( value ),
    					i = options.length;
    
    				while ( i-- ) {
    					option = options[ i ];
    					if ( option.selected =
    							jQuery.inArray( jQuery.valHooks.option.get( option ), values ) > -1
    					) {
    						optionSet = true;
    					}
    				}
    
    				// Force browsers to behave consistently when non-matching value is set
    				if ( !optionSet ) {
    					elem.selectedIndex = -1;
    				}
    				return values;
    			}
    		}
    	}
    } );
    
    // Radios and checkboxes getter/setter
    jQuery.each( [ "radio", "checkbox" ], function() {
    	jQuery.valHooks[ this ] = {
    		set: function( elem, value ) {
    			if ( jQuery.isArray( value ) ) {
    				return ( elem.checked = jQuery.inArray( jQuery( elem ).val(), value ) > -1 );
    			}
    		}
    	};
    	if ( !support.checkOn ) {
    		jQuery.valHooks[ this ].get = function( elem ) {
    			return elem.getAttribute( "value" ) === null ? "on" : elem.value;
    		};
    	}
    } );
    
    
    
    
    // Return jQuery for attributes-only inclusion
    
    
    var rfocusMorph = /^(?:focusinfocus|focusoutblur)$/;
    
    jQuery.extend( jQuery.event, {
    
    	trigger: function( event, data, elem, onlyHandlers ) {
    
    		var i, cur, tmp, bubbleType, ontype, handle, special,
    			eventPath = [ elem || document ],
    			type = hasOwn.call( event, "type" ) ? event.type : event,
    			namespaces = hasOwn.call( event, "namespace" ) ? event.namespace.split( "." ) : [];
    
    		cur = tmp = elem = elem || document;
    
    		// Don't do events on text and comment nodes
    		if ( elem.nodeType === 3 || elem.nodeType === 8 ) {
    			return;
    		}
    
    		// focus/blur morphs to focusin/out; ensure we're not firing them right now
    		if ( rfocusMorph.test( type + jQuery.event.triggered ) ) {
    			return;
    		}
    
    		if ( type.indexOf( "." ) > -1 ) {
    
    			// Namespaced trigger; create a regexp to match event type in handle()
    			namespaces = type.split( "." );
    			type = namespaces.shift();
    			namespaces.sort();
    		}
    		ontype = type.indexOf( ":" ) < 0 && "on" + type;
    
    		// Caller can pass in a jQuery.Event object, Object, or just an event type string
    		event = event[ jQuery.expando ] ?
    			event :
    			new jQuery.Event( type, typeof event === "object" && event );
    
    		// Trigger bitmask: & 1 for native handlers; & 2 for jQuery (always true)
    		event.isTrigger = onlyHandlers ? 2 : 3;
    		event.namespace = namespaces.join( "." );
    		event.rnamespace = event.namespace ?
    			new RegExp( "(^|\\.)" + namespaces.join( "\\.(?:.*\\.|)" ) + "(\\.|$)" ) :
    			null;
    
    		// Clean up the event in case it is being reused
    		event.result = undefined;
    		if ( !event.target ) {
    			event.target = elem;
    		}
    
    		// Clone any incoming data and prepend the event, creating the handler arg list
    		data = data == null ?
    			[ event ] :
    			jQuery.makeArray( data, [ event ] );
    
    		// Allow special events to draw outside the lines
    		special = jQuery.event.special[ type ] || {};
    		if ( !onlyHandlers && special.trigger && special.trigger.apply( elem, data ) === false ) {
    			return;
    		}
    
    		// Determine event propagation path in advance, per W3C events spec (#9951)
    		// Bubble up to document, then to window; watch for a global ownerDocument var (#9724)
    		if ( !onlyHandlers && !special.noBubble && !jQuery.isWindow( elem ) ) {
    
    			bubbleType = special.delegateType || type;
    			if ( !rfocusMorph.test( bubbleType + type ) ) {
    				cur = cur.parentNode;
    			}
    			for ( ; cur; cur = cur.parentNode ) {
    				eventPath.push( cur );
    				tmp = cur;
    			}
    
    			// Only add window if we got to document (e.g., not plain obj or detached DOM)
    			if ( tmp === ( elem.ownerDocument || document ) ) {
    				eventPath.push( tmp.defaultView || tmp.parentWindow || window );
    			}
    		}
    
    		// Fire handlers on the event path
    		i = 0;
    		while ( ( cur = eventPath[ i++ ] ) && !event.isPropagationStopped() ) {
    
    			event.type = i > 1 ?
    				bubbleType :
    				special.bindType || type;
    
    			// jQuery handler
    			handle = ( dataPriv.get( cur, "events" ) || {} )[ event.type ] &&
    				dataPriv.get( cur, "handle" );
    			if ( handle ) {
    				handle.apply( cur, data );
    			}
    
    			// Native handler
    			handle = ontype && cur[ ontype ];
    			if ( handle && handle.apply && acceptData( cur ) ) {
    				event.result = handle.apply( cur, data );
    				if ( event.result === false ) {
    					event.preventDefault();
    				}
    			}
    		}
    		event.type = type;
    
    		// If nobody prevented the default action, do it now
    		if ( !onlyHandlers && !event.isDefaultPrevented() ) {
    
    			if ( ( !special._default ||
    				special._default.apply( eventPath.pop(), data ) === false ) &&
    				acceptData( elem ) ) {
    
    				// Call a native DOM method on the target with the same name name as the event.
    				// Don't do default actions on window, that's where global variables be (#6170)
    				if ( ontype && jQuery.isFunction( elem[ type ] ) && !jQuery.isWindow( elem ) ) {
    
    					// Don't re-trigger an onFOO event when we call its FOO() method
    					tmp = elem[ ontype ];
    
    					if ( tmp ) {
    						elem[ ontype ] = null;
    					}
    
    					// Prevent re-triggering of the same event, since we already bubbled it above
    					jQuery.event.triggered = type;
    					elem[ type ]();
    					jQuery.event.triggered = undefined;
    
    					if ( tmp ) {
    						elem[ ontype ] = tmp;
    					}
    				}
    			}
    		}
    
    		return event.result;
    	},
    
    	// Piggyback on a donor event to simulate a different one
    	simulate: function( type, elem, event ) {
    		var e = jQuery.extend(
    			new jQuery.Event(),
    			event,
    			{
    				type: type,
    				isSimulated: true
    
    				// Previously, `originalEvent: {}` was set here, so stopPropagation call
    				// would not be triggered on donor event, since in our own
    				// jQuery.event.stopPropagation function we had a check for existence of
    				// originalEvent.stopPropagation method, so, consequently it would be a noop.
    				//
    				// But now, this "simulate" function is used only for events
    				// for which stopPropagation() is noop, so there is no need for that anymore.
    				//
    				// For the 1.x branch though, guard for "click" and "submit"
    				// events is still used, but was moved to jQuery.event.stopPropagation function
    				// because `originalEvent` should point to the original event for the constancy
    				// with other events and for more focused logic
    			}
    		);
    
    		jQuery.event.trigger( e, null, elem );
    
    		if ( e.isDefaultPrevented() ) {
    			event.preventDefault();
    		}
    	}
    
    } );
    
    jQuery.fn.extend( {
    
    	trigger: function( type, data ) {
    		return this.each( function() {
    			jQuery.event.trigger( type, data, this );
    		} );
    	},
    	triggerHandler: function( type, data ) {
    		var elem = this[ 0 ];
    		if ( elem ) {
    			return jQuery.event.trigger( type, data, elem, true );
    		}
    	}
    } );
    
    
    jQuery.each( ( "blur focus focusin focusout load resize scroll unload click dblclick " +
    	"mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave " +
    	"change select submit keydown keypress keyup error contextmenu" ).split( " " ),
    	function( i, name ) {
    
    	// Handle event binding
    	jQuery.fn[ name ] = function( data, fn ) {
    		return arguments.length > 0 ?
    			this.on( name, null, data, fn ) :
    			this.trigger( name );
    	};
    } );
    
    jQuery.fn.extend( {
    	hover: function( fnOver, fnOut ) {
    		return this.mouseenter( fnOver ).mouseleave( fnOut || fnOver );
    	}
    } );
    
    
    
    
    support.focusin = "onfocusin" in window;
    
    
    // Support: Firefox
    // Firefox doesn't have focus(in | out) events
    // Related ticket - https://bugzilla.mozilla.org/show_bug.cgi?id=687787
    //
    // Support: Chrome, Safari
    // focus(in | out) events fire after focus & blur events,
    // which is spec violation - http://www.w3.org/TR/DOM-Level-3-Events/#events-focusevent-event-order
    // Related ticket - https://code.google.com/p/chromium/issues/detail?id=449857
    if ( !support.focusin ) {
    	jQuery.each( { focus: "focusin", blur: "focusout" }, function( orig, fix ) {
    
    		// Attach a single capturing handler on the document while someone wants focusin/focusout
    		var handler = function( event ) {
    			jQuery.event.simulate( fix, event.target, jQuery.event.fix( event ) );
    		};
    
    		jQuery.event.special[ fix ] = {
    			setup: function() {
    				var doc = this.ownerDocument || this,
    					attaches = dataPriv.access( doc, fix );
    
    				if ( !attaches ) {
    					doc.addEventListener( orig, handler, true );
    				}
    				dataPriv.access( doc, fix, ( attaches || 0 ) + 1 );
    			},
    			teardown: function() {
    				var doc = this.ownerDocument || this,
    					attaches = dataPriv.access( doc, fix ) - 1;
    
    				if ( !attaches ) {
    					doc.removeEventListener( orig, handler, true );
    					dataPriv.remove( doc, fix );
    
    				} else {
    					dataPriv.access( doc, fix, attaches );
    				}
    			}
    		};
    	} );
    }
    var location = window.location;
    
    var nonce = jQuery.now();
    
    var rquery = ( /\?/ );
    
    
    
    // Support: Android 2.3
    // Workaround failure to string-cast null input
    jQuery.parseJSON = function( data ) {
    	return JSON.parse( data + "" );
    };
    
    
    // Cross-browser xml parsing
    jQuery.parseXML = function( data ) {
    	var xml;
    	if ( !data || typeof data !== "string" ) {
    		return null;
    	}
    
    	// Support: IE9
    	try {
    		xml = ( new window.DOMParser() ).parseFromString( data, "text/xml" );
    	} catch ( e ) {
    		xml = undefined;
    	}
    
    	if ( !xml || xml.getElementsByTagName( "parsererror" ).length ) {
    		jQuery.error( "Invalid XML: " + data );
    	}
    	return xml;
    };
    
    
    var
    	rhash = /#.*$/,
    	rts = /([?&])_=[^&]*/,
    	rheaders = /^(.*?):[ \t]*([^\r\n]*)$/mg,
    
    	// #7653, #8125, #8152: local protocol detection
    	rlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,
    	rnoContent = /^(?:GET|HEAD)$/,
    	rprotocol = /^\/\//,
    
    	/* Prefilters
    	 * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)
    	 * 2) These are called:
    	 *    - BEFORE asking for a transport
    	 *    - AFTER param serialization (s.data is a string if s.processData is true)
    	 * 3) key is the dataType
    	 * 4) the catchall symbol "*" can be used
    	 * 5) execution will start with transport dataType and THEN continue down to "*" if needed
    	 */
    	prefilters = {},
    
    	/* Transports bindings
    	 * 1) key is the dataType
    	 * 2) the catchall symbol "*" can be used
    	 * 3) selection will start with transport dataType and THEN go to "*" if needed
    	 */
    	transports = {},
    
    	// Avoid comment-prolog char sequence (#10098); must appease lint and evade compression
    	allTypes = "*/".concat( "*" ),
    
    	// Anchor tag for parsing the document origin
    	originAnchor = document.createElement( "a" );
    	originAnchor.href = location.href;
    
    // Base "constructor" for jQuery.ajaxPrefilter and jQuery.ajaxTransport
    function addToPrefiltersOrTransports( structure ) {
    
    	// dataTypeExpression is optional and defaults to "*"
    	return function( dataTypeExpression, func ) {
    
    		if ( typeof dataTypeExpression !== "string" ) {
    			func = dataTypeExpression;
    			dataTypeExpression = "*";
    		}
    
    		var dataType,
    			i = 0,
    			dataTypes = dataTypeExpression.toLowerCase().match( rnotwhite ) || [];
    
    		if ( jQuery.isFunction( func ) ) {
    
    			// For each dataType in the dataTypeExpression
    			while ( ( dataType = dataTypes[ i++ ] ) ) {
    
    				// Prepend if requested
    				if ( dataType[ 0 ] === "+" ) {
    					dataType = dataType.slice( 1 ) || "*";
    					( structure[ dataType ] = structure[ dataType ] || [] ).unshift( func );
    
    				// Otherwise append
    				} else {
    					( structure[ dataType ] = structure[ dataType ] || [] ).push( func );
    				}
    			}
    		}
    	};
    }
    
    // Base inspection function for prefilters and transports
    function inspectPrefiltersOrTransports( structure, options, originalOptions, jqXHR ) {
    
    	var inspected = {},
    		seekingTransport = ( structure === transports );
    
    	function inspect( dataType ) {
    		var selected;
    		inspected[ dataType ] = true;
    		jQuery.each( structure[ dataType ] || [], function( _, prefilterOrFactory ) {
    			var dataTypeOrTransport = prefilterOrFactory( options, originalOptions, jqXHR );
    			if ( typeof dataTypeOrTransport === "string" &&
    				!seekingTransport && !inspected[ dataTypeOrTransport ] ) {
    
    				options.dataTypes.unshift( dataTypeOrTransport );
    				inspect( dataTypeOrTransport );
    				return false;
    			} else if ( seekingTransport ) {
    				return !( selected = dataTypeOrTransport );
    			}
    		} );
    		return selected;
    	}
    
    	return inspect( options.dataTypes[ 0 ] ) || !inspected[ "*" ] && inspect( "*" );
    }
    
    // A special extend for ajax options
    // that takes "flat" options (not to be deep extended)
    // Fixes #9887
    function ajaxExtend( target, src ) {
    	var key, deep,
    		flatOptions = jQuery.ajaxSettings.flatOptions || {};
    
    	for ( key in src ) {
    		if ( src[ key ] !== undefined ) {
    			( flatOptions[ key ] ? target : ( deep || ( deep = {} ) ) )[ key ] = src[ key ];
    		}
    	}
    	if ( deep ) {
    		jQuery.extend( true, target, deep );
    	}
    
    	return target;
    }
    
    /* Handles responses to an ajax request:
     * - finds the right dataType (mediates between content-type and expected dataType)
     * - returns the corresponding response
     */
    function ajaxHandleResponses( s, jqXHR, responses ) {
    
    	var ct, type, finalDataType, firstDataType,
    		contents = s.contents,
    		dataTypes = s.dataTypes;
    
    	// Remove auto dataType and get content-type in the process
    	while ( dataTypes[ 0 ] === "*" ) {
    		dataTypes.shift();
    		if ( ct === undefined ) {
    			ct = s.mimeType || jqXHR.getResponseHeader( "Content-Type" );
    		}
    	}
    
    	// Check if we're dealing with a known content-type
    	if ( ct ) {
    		for ( type in contents ) {
    			if ( contents[ type ] && contents[ type ].test( ct ) ) {
    				dataTypes.unshift( type );
    				break;
    			}
    		}
    	}
    
    	// Check to see if we have a response for the expected dataType
    	if ( dataTypes[ 0 ] in responses ) {
    		finalDataType = dataTypes[ 0 ];
    	} else {
    
    		// Try convertible dataTypes
    		for ( type in responses ) {
    			if ( !dataTypes[ 0 ] || s.converters[ type + " " + dataTypes[ 0 ] ] ) {
    				finalDataType = type;
    				break;
    			}
    			if ( !firstDataType ) {
    				firstDataType = type;
    			}
    		}
    
    		// Or just use first one
    		finalDataType = finalDataType || firstDataType;
    	}
    
    	// If we found a dataType
    	// We add the dataType to the list if needed
    	// and return the corresponding response
    	if ( finalDataType ) {
    		if ( finalDataType !== dataTypes[ 0 ] ) {
    			dataTypes.unshift( finalDataType );
    		}
    		return responses[ finalDataType ];
    	}
    }
    
    /* Chain conversions given the request and the original response
     * Also sets the responseXXX fields on the jqXHR instance
     */
    function ajaxConvert( s, response, jqXHR, isSuccess ) {
    	var conv2, current, conv, tmp, prev,
    		converters = {},
    
    		// Work with a copy of dataTypes in case we need to modify it for conversion
    		dataTypes = s.dataTypes.slice();
    
    	// Create converters map with lowercased keys
    	if ( dataTypes[ 1 ] ) {
    		for ( conv in s.converters ) {
    			converters[ conv.toLowerCase() ] = s.converters[ conv ];
    		}
    	}
    
    	current = dataTypes.shift();
    
    	// Convert to each sequential dataType
    	while ( current ) {
    
    		if ( s.responseFields[ current ] ) {
    			jqXHR[ s.responseFields[ current ] ] = response;
    		}
    
    		// Apply the dataFilter if provided
    		if ( !prev && isSuccess && s.dataFilter ) {
    			response = s.dataFilter( response, s.dataType );
    		}
    
    		prev = current;
    		current = dataTypes.shift();
    
    		if ( current ) {
    
    		// There's only work to do if current dataType is non-auto
    			if ( current === "*" ) {
    
    				current = prev;
    
    			// Convert response if prev dataType is non-auto and differs from current
    			} else if ( prev !== "*" && prev !== current ) {
    
    				// Seek a direct converter
    				conv = converters[ prev + " " + current ] || converters[ "* " + current ];
    
    				// If none found, seek a pair
    				if ( !conv ) {
    					for ( conv2 in converters ) {
    
    						// If conv2 outputs current
    						tmp = conv2.split( " " );
    						if ( tmp[ 1 ] === current ) {
    
    							// If prev can be converted to accepted input
    							conv = converters[ prev + " " + tmp[ 0 ] ] ||
    								converters[ "* " + tmp[ 0 ] ];
    							if ( conv ) {
    
    								// Condense equivalence converters
    								if ( conv === true ) {
    									conv = converters[ conv2 ];
    
    								// Otherwise, insert the intermediate dataType
    								} else if ( converters[ conv2 ] !== true ) {
    									current = tmp[ 0 ];
    									dataTypes.unshift( tmp[ 1 ] );
    								}
    								break;
    							}
    						}
    					}
    				}
    
    				// Apply converter (if not an equivalence)
    				if ( conv !== true ) {
    
    					// Unless errors are allowed to bubble, catch and return them
    					if ( conv && s.throws ) {
    						response = conv( response );
    					} else {
    						try {
    							response = conv( response );
    						} catch ( e ) {
    							return {
    								state: "parsererror",
    								error: conv ? e : "No conversion from " + prev + " to " + current
    							};
    						}
    					}
    				}
    			}
    		}
    	}
    
    	return { state: "success", data: response };
    }
    
    jQuery.extend( {
    
    	// Counter for holding the number of active queries
    	active: 0,
    
    	// Last-Modified header cache for next request
    	lastModified: {},
    	etag: {},
    
    	ajaxSettings: {
    		url: location.href,
    		type: "GET",
    		isLocal: rlocalProtocol.test( location.protocol ),
    		global: true,
    		processData: true,
    		async: true,
    		contentType: "application/x-www-form-urlencoded; charset=UTF-8",
    		/*
    		timeout: 0,
    		data: null,
    		dataType: null,
    		username: null,
    		password: null,
    		cache: null,
    		throws: false,
    		traditional: false,
    		headers: {},
    		*/
    
    		accepts: {
    			"*": allTypes,
    			text: "text/plain",
    			html: "text/html",
    			xml: "application/xml, text/xml",
    			json: "application/json, text/javascript"
    		},
    
    		contents: {
    			xml: /\bxml\b/,
    			html: /\bhtml/,
    			json: /\bjson\b/
    		},
    
    		responseFields: {
    			xml: "responseXML",
    			text: "responseText",
    			json: "responseJSON"
    		},
    
    		// Data converters
    		// Keys separate source (or catchall "*") and destination types with a single space
    		converters: {
    
    			// Convert anything to text
    			"* text": String,
    
    			// Text to html (true = no transformation)
    			"text html": true,
    
    			// Evaluate text as a json expression
    			"text json": jQuery.parseJSON,
    
    			// Parse text as xml
    			"text xml": jQuery.parseXML
    		},
    
    		// For options that shouldn't be deep extended:
    		// you can add your own custom options here if
    		// and when you create one that shouldn't be
    		// deep extended (see ajaxExtend)
    		flatOptions: {
    			url: true,
    			context: true
    		}
    	},
    
    	// Creates a full fledged settings object into target
    	// with both ajaxSettings and settings fields.
    	// If target is omitted, writes into ajaxSettings.
    	ajaxSetup: function( target, settings ) {
    		return settings ?
    
    			// Building a settings object
    			ajaxExtend( ajaxExtend( target, jQuery.ajaxSettings ), settings ) :
    
    			// Extending ajaxSettings
    			ajaxExtend( jQuery.ajaxSettings, target );
    	},
    
    	ajaxPrefilter: addToPrefiltersOrTransports( prefilters ),
    	ajaxTransport: addToPrefiltersOrTransports( transports ),
    
    	// Main method
    	ajax: function( url, options ) {
    
    		// If url is an object, simulate pre-1.5 signature
    		if ( typeof url === "object" ) {
    			options = url;
    			url = undefined;
    		}
    
    		// Force options to be an object
    		options = options || {};
    
    		var transport,
    
    			// URL without anti-cache param
    			cacheURL,
    
    			// Response headers
    			responseHeadersString,
    			responseHeaders,
    
    			// timeout handle
    			timeoutTimer,
    
    			// Url cleanup var
    			urlAnchor,
    
    			// To know if global events are to be dispatched
    			fireGlobals,
    
    			// Loop variable
    			i,
    
    			// Create the final options object
    			s = jQuery.ajaxSetup( {}, options ),
    
    			// Callbacks context
    			callbackContext = s.context || s,
    
    			// Context for global events is callbackContext if it is a DOM node or jQuery collection
    			globalEventContext = s.context &&
    				( callbackContext.nodeType || callbackContext.jquery ) ?
    					jQuery( callbackContext ) :
    					jQuery.event,
    
    			// Deferreds
    			deferred = jQuery.Deferred(),
    			completeDeferred = jQuery.Callbacks( "once memory" ),
    
    			// Status-dependent callbacks
    			statusCode = s.statusCode || {},
    
    			// Headers (they are sent all at once)
    			requestHeaders = {},
    			requestHeadersNames = {},
    
    			// The jqXHR state
    			state = 0,
    
    			// Default abort message
    			strAbort = "canceled",
    
    			// Fake xhr
    			jqXHR = {
    				readyState: 0,
    
    				// Builds headers hashtable if needed
    				getResponseHeader: function( key ) {
    					var match;
    					if ( state === 2 ) {
    						if ( !responseHeaders ) {
    							responseHeaders = {};
    							while ( ( match = rheaders.exec( responseHeadersString ) ) ) {
    								responseHeaders[ match[ 1 ].toLowerCase() ] = match[ 2 ];
    							}
    						}
    						match = responseHeaders[ key.toLowerCase() ];
    					}
    					return match == null ? null : match;
    				},
    
    				// Raw string
    				getAllResponseHeaders: function() {
    					return state === 2 ? responseHeadersString : null;
    				},
    
    				// Caches the header
    				setRequestHeader: function( name, value ) {
    					var lname = name.toLowerCase();
    					if ( !state ) {
    						name = requestHeadersNames[ lname ] = requestHeadersNames[ lname ] || name;
    						requestHeaders[ name ] = value;
    					}
    					return this;
    				},
    
    				// Overrides response content-type header
    				overrideMimeType: function( type ) {
    					if ( !state ) {
    						s.mimeType = type;
    					}
    					return this;
    				},
    
    				// Status-dependent callbacks
    				statusCode: function( map ) {
    					var code;
    					if ( map ) {
    						if ( state < 2 ) {
    							for ( code in map ) {
    
    								// Lazy-add the new callback in a way that preserves old ones
    								statusCode[ code ] = [ statusCode[ code ], map[ code ] ];
    							}
    						} else {
    
    							// Execute the appropriate callbacks
    							jqXHR.always( map[ jqXHR.status ] );
    						}
    					}
    					return this;
    				},
    
    				// Cancel the request
    				abort: function( statusText ) {
    					var finalText = statusText || strAbort;
    					if ( transport ) {
    						transport.abort( finalText );
    					}
    					done( 0, finalText );
    					return this;
    				}
    			};
    
    		// Attach deferreds
    		deferred.promise( jqXHR ).complete = completeDeferred.add;
    		jqXHR.success = jqXHR.done;
    		jqXHR.error = jqXHR.fail;
    
    		// Remove hash character (#7531: and string promotion)
    		// Add protocol if not provided (prefilters might expect it)
    		// Handle falsy url in the settings object (#10093: consistency with old signature)
    		// We also use the url parameter if available
    		s.url = ( ( url || s.url || location.href ) + "" ).replace( rhash, "" )
    			.replace( rprotocol, location.protocol + "//" );
    
    		// Alias method option to type as per ticket #12004
    		s.type = options.method || options.type || s.method || s.type;
    
    		// Extract dataTypes list
    		s.dataTypes = jQuery.trim( s.dataType || "*" ).toLowerCase().match( rnotwhite ) || [ "" ];
    
    		// A cross-domain request is in order when the origin doesn't match the current origin.
    		if ( s.crossDomain == null ) {
    			urlAnchor = document.createElement( "a" );
    
    			// Support: IE8-11+
    			// IE throws exception if url is malformed, e.g. http://example.com:80x/
    			try {
    				urlAnchor.href = s.url;
    
    				// Support: IE8-11+
    				// Anchor's host property isn't correctly set when s.url is relative
    				urlAnchor.href = urlAnchor.href;
    				s.crossDomain = originAnchor.protocol + "//" + originAnchor.host !==
    					urlAnchor.protocol + "//" + urlAnchor.host;
    			} catch ( e ) {
    
    				// If there is an error parsing the URL, assume it is crossDomain,
    				// it can be rejected by the transport if it is invalid
    				s.crossDomain = true;
    			}
    		}
    
    		// Convert data if not already a string
    		if ( s.data && s.processData && typeof s.data !== "string" ) {
    			s.data = jQuery.param( s.data, s.traditional );
    		}
    
    		// Apply prefilters
    		inspectPrefiltersOrTransports( prefilters, s, options, jqXHR );
    
    		// If request was aborted inside a prefilter, stop there
    		if ( state === 2 ) {
    			return jqXHR;
    		}
    
    		// We can fire global events as of now if asked to
    		// Don't fire events if jQuery.event is undefined in an AMD-usage scenario (#15118)
    		fireGlobals = jQuery.event && s.global;
    
    		// Watch for a new set of requests
    		if ( fireGlobals && jQuery.active++ === 0 ) {
    			jQuery.event.trigger( "ajaxStart" );
    		}
    
    		// Uppercase the type
    		s.type = s.type.toUpperCase();
    
    		// Determine if request has content
    		s.hasContent = !rnoContent.test( s.type );
    
    		// Save the URL in case we're toying with the If-Modified-Since
    		// and/or If-None-Match header later on
    		cacheURL = s.url;
    
    		// More options handling for requests with no content
    		if ( !s.hasContent ) {
    
    			// If data is available, append data to url
    			if ( s.data ) {
    				cacheURL = ( s.url += ( rquery.test( cacheURL ) ? "&" : "?" ) + s.data );
    
    				// #9682: remove data so that it's not used in an eventual retry
    				delete s.data;
    			}
    
    			// Add anti-cache in url if needed
    			if ( s.cache === false ) {
    				s.url = rts.test( cacheURL ) ?
    
    					// If there is already a '_' parameter, set its value
    					cacheURL.replace( rts, "$1_=" + nonce++ ) :
    
    					// Otherwise add one to the end
    					cacheURL + ( rquery.test( cacheURL ) ? "&" : "?" ) + "_=" + nonce++;
    			}
    		}
    
    		// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
    		if ( s.ifModified ) {
    			if ( jQuery.lastModified[ cacheURL ] ) {
    				jqXHR.setRequestHeader( "If-Modified-Since", jQuery.lastModified[ cacheURL ] );
    			}
    			if ( jQuery.etag[ cacheURL ] ) {
    				jqXHR.setRequestHeader( "If-None-Match", jQuery.etag[ cacheURL ] );
    			}
    		}
    
    		// Set the correct header, if data is being sent
    		if ( s.data && s.hasContent && s.contentType !== false || options.contentType ) {
    			jqXHR.setRequestHeader( "Content-Type", s.contentType );
    		}
    
    		// Set the Accepts header for the server, depending on the dataType
    		jqXHR.setRequestHeader(
    			"Accept",
    			s.dataTypes[ 0 ] && s.accepts[ s.dataTypes[ 0 ] ] ?
    				s.accepts[ s.dataTypes[ 0 ] ] +
    					( s.dataTypes[ 0 ] !== "*" ? ", " + allTypes + "; q=0.01" : "" ) :
    				s.accepts[ "*" ]
    		);
    
    		// Check for headers option
    		for ( i in s.headers ) {
    			jqXHR.setRequestHeader( i, s.headers[ i ] );
    		}
    
    		// Allow custom headers/mimetypes and early abort
    		if ( s.beforeSend &&
    			( s.beforeSend.call( callbackContext, jqXHR, s ) === false || state === 2 ) ) {
    
    			// Abort if not done already and return
    			return jqXHR.abort();
    		}
    
    		// Aborting is no longer a cancellation
    		strAbort = "abort";
    
    		// Install callbacks on deferreds
    		for ( i in { success: 1, error: 1, complete: 1 } ) {
    			jqXHR[ i ]( s[ i ] );
    		}
    
    		// Get transport
    		transport = inspectPrefiltersOrTransports( transports, s, options, jqXHR );
    
    		// If no transport, we auto-abort
    		if ( !transport ) {
    			done( -1, "No Transport" );
    		} else {
    			jqXHR.readyState = 1;
    
    			// Send global event
    			if ( fireGlobals ) {
    				globalEventContext.trigger( "ajaxSend", [ jqXHR, s ] );
    			}
    
    			// If request was aborted inside ajaxSend, stop there
    			if ( state === 2 ) {
    				return jqXHR;
    			}
    
    			// Timeout
    			if ( s.async && s.timeout > 0 ) {
    				timeoutTimer = window.setTimeout( function() {
    					jqXHR.abort( "timeout" );
    				}, s.timeout );
    			}
    
    			try {
    				state = 1;
    				transport.send( requestHeaders, done );
    			} catch ( e ) {
    
    				// Propagate exception as error if not done
    				if ( state < 2 ) {
    					done( -1, e );
    
    				// Simply rethrow otherwise
    				} else {
    					throw e;
    				}
    			}
    		}
    
    		// Callback for when everything is done
    		function done( status, nativeStatusText, responses, headers ) {
    			var isSuccess, success, error, response, modified,
    				statusText = nativeStatusText;
    
    			// Called once
    			if ( state === 2 ) {
    				return;
    			}
    
    			// State is "done" now
    			state = 2;
    
    			// Clear timeout if it exists
    			if ( timeoutTimer ) {
    				window.clearTimeout( timeoutTimer );
    			}
    
    			// Dereference transport for early garbage collection
    			// (no matter how long the jqXHR object will be used)
    			transport = undefined;
    
    			// Cache response headers
    			responseHeadersString = headers || "";
    
    			// Set readyState
    			jqXHR.readyState = status > 0 ? 4 : 0;
    
    			// Determine if successful
    			isSuccess = status >= 200 && status < 300 || status === 304;
    
    			// Get response data
    			if ( responses ) {
    				response = ajaxHandleResponses( s, jqXHR, responses );
    			}
    
    			// Convert no matter what (that way responseXXX fields are always set)
    			response = ajaxConvert( s, response, jqXHR, isSuccess );
    
    			// If successful, handle type chaining
    			if ( isSuccess ) {
    
    				// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
    				if ( s.ifModified ) {
    					modified = jqXHR.getResponseHeader( "Last-Modified" );
    					if ( modified ) {
    						jQuery.lastModified[ cacheURL ] = modified;
    					}
    					modified = jqXHR.getResponseHeader( "etag" );
    					if ( modified ) {
    						jQuery.etag[ cacheURL ] = modified;
    					}
    				}
    
    				// if no content
    				if ( status === 204 || s.type === "HEAD" ) {
    					statusText = "nocontent";
    
    				// if not modified
    				} else if ( status === 304 ) {
    					statusText = "notmodified";
    
    				// If we have data, let's convert it
    				} else {
    					statusText = response.state;
    					success = response.data;
    					error = response.error;
    					isSuccess = !error;
    				}
    			} else {
    
    				// Extract error from statusText and normalize for non-aborts
    				error = statusText;
    				if ( status || !statusText ) {
    					statusText = "error";
    					if ( status < 0 ) {
    						status = 0;
    					}
    				}
    			}
    
    			// Set data for the fake xhr object
    			jqXHR.status = status;
    			jqXHR.statusText = ( nativeStatusText || statusText ) + "";
    
    			// Success/Error
    			if ( isSuccess ) {
    				deferred.resolveWith( callbackContext, [ success, statusText, jqXHR ] );
    			} else {
    				deferred.rejectWith( callbackContext, [ jqXHR, statusText, error ] );
    			}
    
    			// Status-dependent callbacks
    			jqXHR.statusCode( statusCode );
    			statusCode = undefined;
    
    			if ( fireGlobals ) {
    				globalEventContext.trigger( isSuccess ? "ajaxSuccess" : "ajaxError",
    					[ jqXHR, s, isSuccess ? success : error ] );
    			}
    
    			// Complete
    			completeDeferred.fireWith( callbackContext, [ jqXHR, statusText ] );
    
    			if ( fireGlobals ) {
    				globalEventContext.trigger( "ajaxComplete", [ jqXHR, s ] );
    
    				// Handle the global AJAX counter
    				if ( !( --jQuery.active ) ) {
    					jQuery.event.trigger( "ajaxStop" );
    				}
    			}
    		}
    
    		return jqXHR;
    	},
    
    	getJSON: function( url, data, callback ) {
    		return jQuery.get( url, data, callback, "json" );
    	},
    
    	getScript: function( url, callback ) {
    		return jQuery.get( url, undefined, callback, "script" );
    	}
    } );
    
    jQuery.each( [ "get", "post" ], function( i, method ) {
    	jQuery[ method ] = function( url, data, callback, type ) {
    
    		// Shift arguments if data argument was omitted
    		if ( jQuery.isFunction( data ) ) {
    			type = type || callback;
    			callback = data;
    			data = undefined;
    		}
    
    		// The url can be an options object (which then must have .url)
    		return jQuery.ajax( jQuery.extend( {
    			url: url,
    			type: method,
    			dataType: type,
    			data: data,
    			success: callback
    		}, jQuery.isPlainObject( url ) && url ) );
    	};
    } );
    
    
    jQuery._evalUrl = function( url ) {
    	return jQuery.ajax( {
    		url: url,
    
    		// Make this explicit, since user can override this through ajaxSetup (#11264)
    		type: "GET",
    		dataType: "script",
    		async: false,
    		global: false,
    		"throws": true
    	} );
    };
    
    
    jQuery.fn.extend( {
    	wrapAll: function( html ) {
    		var wrap;
    
    		if ( jQuery.isFunction( html ) ) {
    			return this.each( function( i ) {
    				jQuery( this ).wrapAll( html.call( this, i ) );
    			} );
    		}
    
    		if ( this[ 0 ] ) {
    
    			// The elements to wrap the target around
    			wrap = jQuery( html, this[ 0 ].ownerDocument ).eq( 0 ).clone( true );
    
    			if ( this[ 0 ].parentNode ) {
    				wrap.insertBefore( this[ 0 ] );
    			}
    
    			wrap.map( function() {
    				var elem = this;
    
    				while ( elem.firstElementChild ) {
    					elem = elem.firstElementChild;
    				}
    
    				return elem;
    			} ).append( this );
    		}
    
    		return this;
    	},
    
    	wrapInner: function( html ) {
    		if ( jQuery.isFunction( html ) ) {
    			return this.each( function( i ) {
    				jQuery( this ).wrapInner( html.call( this, i ) );
    			} );
    		}
    
    		return this.each( function() {
    			var self = jQuery( this ),
    				contents = self.contents();
    
    			if ( contents.length ) {
    				contents.wrapAll( html );
    
    			} else {
    				self.append( html );
    			}
    		} );
    	},
    
    	wrap: function( html ) {
    		var isFunction = jQuery.isFunction( html );
    
    		return this.each( function( i ) {
    			jQuery( this ).wrapAll( isFunction ? html.call( this, i ) : html );
    		} );
    	},
    
    	unwrap: function() {
    		return this.parent().each( function() {
    			if ( !jQuery.nodeName( this, "body" ) ) {
    				jQuery( this ).replaceWith( this.childNodes );
    			}
    		} ).end();
    	}
    } );
    
    
    jQuery.expr.filters.hidden = function( elem ) {
    	return !jQuery.expr.filters.visible( elem );
    };
    jQuery.expr.filters.visible = function( elem ) {
    
    	// Support: Opera <= 12.12
    	// Opera reports offsetWidths and offsetHeights less than zero on some elements
    	// Use OR instead of AND as the element is not visible if either is true
    	// See tickets #10406 and #13132
    	return elem.offsetWidth > 0 || elem.offsetHeight > 0 || elem.getClientRects().length > 0;
    };
    
    
    
    
    var r20 = /%20/g,
    	rbracket = /\[\]$/,
    	rCRLF = /\r?\n/g,
    	rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i,
    	rsubmittable = /^(?:input|select|textarea|keygen)/i;
    
    function buildParams( prefix, obj, traditional, add ) {
    	var name;
    
    	if ( jQuery.isArray( obj ) ) {
    
    		// Serialize array item.
    		jQuery.each( obj, function( i, v ) {
    			if ( traditional || rbracket.test( prefix ) ) {
    
    				// Treat each array item as a scalar.
    				add( prefix, v );
    
    			} else {
    
    				// Item is non-scalar (array or object), encode its numeric index.
    				buildParams(
    					prefix + "[" + ( typeof v === "object" && v != null ? i : "" ) + "]",
    					v,
    					traditional,
    					add
    				);
    			}
    		} );
    
    	} else if ( !traditional && jQuery.type( obj ) === "object" ) {
    
    		// Serialize object item.
    		for ( name in obj ) {
    			buildParams( prefix + "[" + name + "]", obj[ name ], traditional, add );
    		}
    
    	} else {
    
    		// Serialize scalar item.
    		add( prefix, obj );
    	}
    }
    
    // Serialize an array of form elements or a set of
    // key/values into a query string
    jQuery.param = function( a, traditional ) {
    	var prefix,
    		s = [],
    		add = function( key, value ) {
    
    			// If value is a function, invoke it and return its value
    			value = jQuery.isFunction( value ) ? value() : ( value == null ? "" : value );
    			s[ s.length ] = encodeURIComponent( key ) + "=" + encodeURIComponent( value );
    		};
    
    	// Set traditional to true for jQuery <= 1.3.2 behavior.
    	if ( traditional === undefined ) {
    		traditional = jQuery.ajaxSettings && jQuery.ajaxSettings.traditional;
    	}
    
    	// If an array was passed in, assume that it is an array of form elements.
    	if ( jQuery.isArray( a ) || ( a.jquery && !jQuery.isPlainObject( a ) ) ) {
    
    		// Serialize the form elements
    		jQuery.each( a, function() {
    			add( this.name, this.value );
    		} );
    
    	} else {
    
    		// If traditional, encode the "old" way (the way 1.3.2 or older
    		// did it), otherwise encode params recursively.
    		for ( prefix in a ) {
    			buildParams( prefix, a[ prefix ], traditional, add );
    		}
    	}
    
    	// Return the resulting serialization
    	return s.join( "&" ).replace( r20, "+" );
    };
    
    jQuery.fn.extend( {
    	serialize: function() {
    		return jQuery.param( this.serializeArray() );
    	},
    	serializeArray: function() {
    		return this.map( function() {
    
    			// Can add propHook for "elements" to filter or add form elements
    			var elements = jQuery.prop( this, "elements" );
    			return elements ? jQuery.makeArray( elements ) : this;
    		} )
    		.filter( function() {
    			var type = this.type;
    
    			// Use .is( ":disabled" ) so that fieldset[disabled] works
    			return this.name && !jQuery( this ).is( ":disabled" ) &&
    				rsubmittable.test( this.nodeName ) && !rsubmitterTypes.test( type ) &&
    				( this.checked || !rcheckableType.test( type ) );
    		} )
    		.map( function( i, elem ) {
    			var val = jQuery( this ).val();
    
    			return val == null ?
    				null :
    				jQuery.isArray( val ) ?
    					jQuery.map( val, function( val ) {
    						return { name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
    					} ) :
    					{ name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
    		} ).get();
    	}
    } );
    
    
    jQuery.ajaxSettings.xhr = function() {
    	try {
    		return new window.XMLHttpRequest();
    	} catch ( e ) {}
    };
    
    var xhrSuccessStatus = {
    
    		// File protocol always yields status code 0, assume 200
    		0: 200,
    
    		// Support: IE9
    		// #1450: sometimes IE returns 1223 when it should be 204
    		1223: 204
    	},
    	xhrSupported = jQuery.ajaxSettings.xhr();
    
    support.cors = !!xhrSupported && ( "withCredentials" in xhrSupported );
    support.ajax = xhrSupported = !!xhrSupported;
    
    jQuery.ajaxTransport( function( options ) {
    	var callback, errorCallback;
    
    	// Cross domain only allowed if supported through XMLHttpRequest
    	if ( support.cors || xhrSupported && !options.crossDomain ) {
    		return {
    			send: function( headers, complete ) {
    				var i,
    					xhr = options.xhr();
    
    				xhr.open(
    					options.type,
    					options.url,
    					options.async,
    					options.username,
    					options.password
    				);
    
    				// Apply custom fields if provided
    				if ( options.xhrFields ) {
    					for ( i in options.xhrFields ) {
    						xhr[ i ] = options.xhrFields[ i ];
    					}
    				}
    
    				// Override mime type if needed
    				if ( options.mimeType && xhr.overrideMimeType ) {
    					xhr.overrideMimeType( options.mimeType );
    				}
    
    				// X-Requested-With header
    				// For cross-domain requests, seeing as conditions for a preflight are
    				// akin to a jigsaw puzzle, we simply never set it to be sure.
    				// (it can always be set on a per-request basis or even using ajaxSetup)
    				// For same-domain requests, won't change header if already provided.
    				if ( !options.crossDomain && !headers[ "X-Requested-With" ] ) {
    					headers[ "X-Requested-With" ] = "XMLHttpRequest";
    				}
    
    				// Set headers
    				for ( i in headers ) {
    					xhr.setRequestHeader( i, headers[ i ] );
    				}
    
    				// Callback
    				callback = function( type ) {
    					return function() {
    						if ( callback ) {
    							callback = errorCallback = xhr.onload =
    								xhr.onerror = xhr.onabort = xhr.onreadystatechange = null;
    
    							if ( type === "abort" ) {
    								xhr.abort();
    							} else if ( type === "error" ) {
    
    								// Support: IE9
    								// On a manual native abort, IE9 throws
    								// errors on any property access that is not readyState
    								if ( typeof xhr.status !== "number" ) {
    									complete( 0, "error" );
    								} else {
    									complete(
    
    										// File: protocol always yields status 0; see #8605, #14207
    										xhr.status,
    										xhr.statusText
    									);
    								}
    							} else {
    								complete(
    									xhrSuccessStatus[ xhr.status ] || xhr.status,
    									xhr.statusText,
    
    									// Support: IE9 only
    									// IE9 has no XHR2 but throws on binary (trac-11426)
    									// For XHR2 non-text, let the caller handle it (gh-2498)
    									( xhr.responseType || "text" ) !== "text"  ||
    									typeof xhr.responseText !== "string" ?
    										{ binary: xhr.response } :
    										{ text: xhr.responseText },
    									xhr.getAllResponseHeaders()
    								);
    							}
    						}
    					};
    				};
    
    				// Listen to events
    				xhr.onload = callback();
    				errorCallback = xhr.onerror = callback( "error" );
    
    				// Support: IE9
    				// Use onreadystatechange to replace onabort
    				// to handle uncaught aborts
    				if ( xhr.onabort !== undefined ) {
    					xhr.onabort = errorCallback;
    				} else {
    					xhr.onreadystatechange = function() {
    
    						// Check readyState before timeout as it changes
    						if ( xhr.readyState === 4 ) {
    
    							// Allow onerror to be called first,
    							// but that will not handle a native abort
    							// Also, save errorCallback to a variable
    							// as xhr.onerror cannot be accessed
    							window.setTimeout( function() {
    								if ( callback ) {
    									errorCallback();
    								}
    							} );
    						}
    					};
    				}
    
    				// Create the abort callback
    				callback = callback( "abort" );
    
    				try {
    
    					// Do send the request (this may raise an exception)
    					xhr.send( options.hasContent && options.data || null );
    				} catch ( e ) {
    
    					// #14683: Only rethrow if this hasn't been notified as an error yet
    					if ( callback ) {
    						throw e;
    					}
    				}
    			},
    
    			abort: function() {
    				if ( callback ) {
    					callback();
    				}
    			}
    		};
    	}
    } );
    
    
    
    
    // Install script dataType
    jQuery.ajaxSetup( {
    	accepts: {
    		script: "text/javascript, application/javascript, " +
    			"application/ecmascript, application/x-ecmascript"
    	},
    	contents: {
    		script: /\b(?:java|ecma)script\b/
    	},
    	converters: {
    		"text script": function( text ) {
    			jQuery.globalEval( text );
    			return text;
    		}
    	}
    } );
    
    // Handle cache's special case and crossDomain
    jQuery.ajaxPrefilter( "script", function( s ) {
    	if ( s.cache === undefined ) {
    		s.cache = false;
    	}
    	if ( s.crossDomain ) {
    		s.type = "GET";
    	}
    } );
    
    // Bind script tag hack transport
    jQuery.ajaxTransport( "script", function( s ) {
    
    	// This transport only deals with cross domain requests
    	if ( s.crossDomain ) {
    		var script, callback;
    		return {
    			send: function( _, complete ) {
    				script = jQuery( "<script>" ).prop( {
    					charset: s.scriptCharset,
    					src: s.url
    				} ).on(
    					"load error",
    					callback = function( evt ) {
    						script.remove();
    						callback = null;
    						if ( evt ) {
    							complete( evt.type === "error" ? 404 : 200, evt.type );
    						}
    					}
    				);
    
    				// Use native DOM manipulation to avoid our domManip AJAX trickery
    				document.head.appendChild( script[ 0 ] );
    			},
    			abort: function() {
    				if ( callback ) {
    					callback();
    				}
    			}
    		};
    	}
    } );
    
    
    
    
    var oldCallbacks = [],
    	rjsonp = /(=)\?(?=&|$)|\?\?/;
    
    // Default jsonp settings
    jQuery.ajaxSetup( {
    	jsonp: "callback",
    	jsonpCallback: function() {
    		var callback = oldCallbacks.pop() || ( jQuery.expando + "_" + ( nonce++ ) );
    		this[ callback ] = true;
    		return callback;
    	}
    } );
    
    // Detect, normalize options and install callbacks for jsonp requests
    jQuery.ajaxPrefilter( "json jsonp", function( s, originalSettings, jqXHR ) {
    
    	var callbackName, overwritten, responseContainer,
    		jsonProp = s.jsonp !== false && ( rjsonp.test( s.url ) ?
    			"url" :
    			typeof s.data === "string" &&
    				( s.contentType || "" )
    					.indexOf( "application/x-www-form-urlencoded" ) === 0 &&
    				rjsonp.test( s.data ) && "data"
    		);
    
    	// Handle iff the expected data type is "jsonp" or we have a parameter to set
    	if ( jsonProp || s.dataTypes[ 0 ] === "jsonp" ) {
    
    		// Get callback name, remembering preexisting value associated with it
    		callbackName = s.jsonpCallback = jQuery.isFunction( s.jsonpCallback ) ?
    			s.jsonpCallback() :
    			s.jsonpCallback;
    
    		// Insert callback into url or form data
    		if ( jsonProp ) {
    			s[ jsonProp ] = s[ jsonProp ].replace( rjsonp, "$1" + callbackName );
    		} else if ( s.jsonp !== false ) {
    			s.url += ( rquery.test( s.url ) ? "&" : "?" ) + s.jsonp + "=" + callbackName;
    		}
    
    		// Use data converter to retrieve json after script execution
    		s.converters[ "script json" ] = function() {
    			if ( !responseContainer ) {
    				jQuery.error( callbackName + " was not called" );
    			}
    			return responseContainer[ 0 ];
    		};
    
    		// Force json dataType
    		s.dataTypes[ 0 ] = "json";
    
    		// Install callback
    		overwritten = window[ callbackName ];
    		window[ callbackName ] = function() {
    			responseContainer = arguments;
    		};
    
    		// Clean-up function (fires after converters)
    		jqXHR.always( function() {
    
    			// If previous value didn't exist - remove it
    			if ( overwritten === undefined ) {
    				jQuery( window ).removeProp( callbackName );
    
    			// Otherwise restore preexisting value
    			} else {
    				window[ callbackName ] = overwritten;
    			}
    
    			// Save back as free
    			if ( s[ callbackName ] ) {
    
    				// Make sure that re-using the options doesn't screw things around
    				s.jsonpCallback = originalSettings.jsonpCallback;
    
    				// Save the callback name for future use
    				oldCallbacks.push( callbackName );
    			}
    
    			// Call if it was a function and we have a response
    			if ( responseContainer && jQuery.isFunction( overwritten ) ) {
    				overwritten( responseContainer[ 0 ] );
    			}
    
    			responseContainer = overwritten = undefined;
    		} );
    
    		// Delegate to script
    		return "script";
    	}
    } );
    
    
    
    
    // Support: Safari 8+
    // In Safari 8 documents created via document.implementation.createHTMLDocument
    // collapse sibling forms: the second one becomes a child of the first one.
    // Because of that, this security measure has to be disabled in Safari 8.
    // https://bugs.webkit.org/show_bug.cgi?id=137337
    support.createHTMLDocument = ( function() {
    	var body = document.implementation.createHTMLDocument( "" ).body;
    	body.innerHTML = "<form></form><form></form>";
    	return body.childNodes.length === 2;
    } )();
    
    
    // Argument "data" should be string of html
    // context (optional): If specified, the fragment will be created in this context,
    // defaults to document
    // keepScripts (optional): If true, will include scripts passed in the html string
    jQuery.parseHTML = function( data, context, keepScripts ) {
    	if ( !data || typeof data !== "string" ) {
    		return null;
    	}
    	if ( typeof context === "boolean" ) {
    		keepScripts = context;
    		context = false;
    	}
    
    	// Stop scripts or inline event handlers from being executed immediately
    	// by using document.implementation
    	context = context || ( support.createHTMLDocument ?
    		document.implementation.createHTMLDocument( "" ) :
    		document );
    
    	var parsed = rsingleTag.exec( data ),
    		scripts = !keepScripts && [];
    
    	// Single tag
    	if ( parsed ) {
    		return [ context.createElement( parsed[ 1 ] ) ];
    	}
    
    	parsed = buildFragment( [ data ], context, scripts );
    
    	if ( scripts && scripts.length ) {
    		jQuery( scripts ).remove();
    	}
    
    	return jQuery.merge( [], parsed.childNodes );
    };
    
    
    // Keep a copy of the old load method
    var _load = jQuery.fn.load;
    
    /**
     * Load a url into a page
     */
    jQuery.fn.load = function( url, params, callback ) {
    	if ( typeof url !== "string" && _load ) {
    		return _load.apply( this, arguments );
    	}
    
    	var selector, type, response,
    		self = this,
    		off = url.indexOf( " " );
    
    	if ( off > -1 ) {
    		selector = jQuery.trim( url.slice( off ) );
    		url = url.slice( 0, off );
    	}
    
    	// If it's a function
    	if ( jQuery.isFunction( params ) ) {
    
    		// We assume that it's the callback
    		callback = params;
    		params = undefined;
    
    	// Otherwise, build a param string
    	} else if ( params && typeof params === "object" ) {
    		type = "POST";
    	}
    
    	// If we have elements to modify, make the request
    	if ( self.length > 0 ) {
    		jQuery.ajax( {
    			url: url,
    
    			// If "type" variable is undefined, then "GET" method will be used.
    			// Make value of this field explicit since
    			// user can override it through ajaxSetup method
    			type: type || "GET",
    			dataType: "html",
    			data: params
    		} ).done( function( responseText ) {
    
    			// Save response for use in complete callback
    			response = arguments;
    
    			self.html( selector ?
    
    				// If a selector was specified, locate the right elements in a dummy div
    				// Exclude scripts to avoid IE 'Permission Denied' errors
    				jQuery( "<div>" ).append( jQuery.parseHTML( responseText ) ).find( selector ) :
    
    				// Otherwise use the full result
    				responseText );
    
    		// If the request succeeds, this function gets "data", "status", "jqXHR"
    		// but they are ignored because response was set above.
    		// If it fails, this function gets "jqXHR", "status", "error"
    		} ).always( callback && function( jqXHR, status ) {
    			self.each( function() {
    				callback.apply( self, response || [ jqXHR.responseText, status, jqXHR ] );
    			} );
    		} );
    	}
    
    	return this;
    };
    
    
    
    
    // Attach a bunch of functions for handling common AJAX events
    jQuery.each( [
    	"ajaxStart",
    	"ajaxStop",
    	"ajaxComplete",
    	"ajaxError",
    	"ajaxSuccess",
    	"ajaxSend"
    ], function( i, type ) {
    	jQuery.fn[ type ] = function( fn ) {
    		return this.on( type, fn );
    	};
    } );
    
    
    
    
    jQuery.expr.filters.animated = function( elem ) {
    	return jQuery.grep( jQuery.timers, function( fn ) {
    		return elem === fn.elem;
    	} ).length;
    };
    
    
    
    
    /**
     * Gets a window from an element
     */
    function getWindow( elem ) {
    	return jQuery.isWindow( elem ) ? elem : elem.nodeType === 9 && elem.defaultView;
    }
    
    jQuery.offset = {
    	setOffset: function( elem, options, i ) {
    		var curPosition, curLeft, curCSSTop, curTop, curOffset, curCSSLeft, calculatePosition,
    			position = jQuery.css( elem, "position" ),
    			curElem = jQuery( elem ),
    			props = {};
    
    		// Set position first, in-case top/left are set even on static elem
    		if ( position === "static" ) {
    			elem.style.position = "relative";
    		}
    
    		curOffset = curElem.offset();
    		curCSSTop = jQuery.css( elem, "top" );
    		curCSSLeft = jQuery.css( elem, "left" );
    		calculatePosition = ( position === "absolute" || position === "fixed" ) &&
    			( curCSSTop + curCSSLeft ).indexOf( "auto" ) > -1;
    
    		// Need to be able to calculate position if either
    		// top or left is auto and position is either absolute or fixed
    		if ( calculatePosition ) {
    			curPosition = curElem.position();
    			curTop = curPosition.top;
    			curLeft = curPosition.left;
    
    		} else {
    			curTop = parseFloat( curCSSTop ) || 0;
    			curLeft = parseFloat( curCSSLeft ) || 0;
    		}
    
    		if ( jQuery.isFunction( options ) ) {
    
    			// Use jQuery.extend here to allow modification of coordinates argument (gh-1848)
    			options = options.call( elem, i, jQuery.extend( {}, curOffset ) );
    		}
    
    		if ( options.top != null ) {
    			props.top = ( options.top - curOffset.top ) + curTop;
    		}
    		if ( options.left != null ) {
    			props.left = ( options.left - curOffset.left ) + curLeft;
    		}
    
    		if ( "using" in options ) {
    			options.using.call( elem, props );
    
    		} else {
    			curElem.css( props );
    		}
    	}
    };
    
    jQuery.fn.extend( {
    	offset: function( options ) {
    		if ( arguments.length ) {
    			return options === undefined ?
    				this :
    				this.each( function( i ) {
    					jQuery.offset.setOffset( this, options, i );
    				} );
    		}
    
    		var docElem, win,
    			elem = this[ 0 ],
    			box = { top: 0, left: 0 },
    			doc = elem && elem.ownerDocument;
    
    		if ( !doc ) {
    			return;
    		}
    
    		docElem = doc.documentElement;
    
    		// Make sure it's not a disconnected DOM node
    		if ( !jQuery.contains( docElem, elem ) ) {
    			return box;
    		}
    
    		box = elem.getBoundingClientRect();
    		win = getWindow( doc );
    		return {
    			top: box.top + win.pageYOffset - docElem.clientTop,
    			left: box.left + win.pageXOffset - docElem.clientLeft
    		};
    	},
    
    	position: function() {
    		if ( !this[ 0 ] ) {
    			return;
    		}
    
    		var offsetParent, offset,
    			elem = this[ 0 ],
    			parentOffset = { top: 0, left: 0 };
    
    		// Fixed elements are offset from window (parentOffset = {top:0, left: 0},
    		// because it is its only offset parent
    		if ( jQuery.css( elem, "position" ) === "fixed" ) {
    
    			// Assume getBoundingClientRect is there when computed position is fixed
    			offset = elem.getBoundingClientRect();
    
    		} else {
    
    			// Get *real* offsetParent
    			offsetParent = this.offsetParent();
    
    			// Get correct offsets
    			offset = this.offset();
    			if ( !jQuery.nodeName( offsetParent[ 0 ], "html" ) ) {
    				parentOffset = offsetParent.offset();
    			}
    
    			// Add offsetParent borders
    			parentOffset.top += jQuery.css( offsetParent[ 0 ], "borderTopWidth", true );
    			parentOffset.left += jQuery.css( offsetParent[ 0 ], "borderLeftWidth", true );
    		}
    
    		// Subtract parent offsets and element margins
    		return {
    			top: offset.top - parentOffset.top - jQuery.css( elem, "marginTop", true ),
    			left: offset.left - parentOffset.left - jQuery.css( elem, "marginLeft", true )
    		};
    	},
    
    	// This method will return documentElement in the following cases:
    	// 1) For the element inside the iframe without offsetParent, this method will return
    	//    documentElement of the parent window
    	// 2) For the hidden or detached element
    	// 3) For body or html element, i.e. in case of the html node - it will return itself
    	//
    	// but those exceptions were never presented as a real life use-cases
    	// and might be considered as more preferable results.
    	//
    	// This logic, however, is not guaranteed and can change at any point in the future
    	offsetParent: function() {
    		return this.map( function() {
    			var offsetParent = this.offsetParent;
    
    			while ( offsetParent && jQuery.css( offsetParent, "position" ) === "static" ) {
    				offsetParent = offsetParent.offsetParent;
    			}
    
    			return offsetParent || documentElement;
    		} );
    	}
    } );
    
    // Create scrollLeft and scrollTop methods
    jQuery.each( { scrollLeft: "pageXOffset", scrollTop: "pageYOffset" }, function( method, prop ) {
    	var top = "pageYOffset" === prop;
    
    	jQuery.fn[ method ] = function( val ) {
    		return access( this, function( elem, method, val ) {
    			var win = getWindow( elem );
    
    			if ( val === undefined ) {
    				return win ? win[ prop ] : elem[ method ];
    			}
    
    			if ( win ) {
    				win.scrollTo(
    					!top ? val : win.pageXOffset,
    					top ? val : win.pageYOffset
    				);
    
    			} else {
    				elem[ method ] = val;
    			}
    		}, method, val, arguments.length );
    	};
    } );
    
    // Support: Safari<7-8+, Chrome<37-44+
    // Add the top/left cssHooks using jQuery.fn.position
    // Webkit bug: https://bugs.webkit.org/show_bug.cgi?id=29084
    // Blink bug: https://code.google.com/p/chromium/issues/detail?id=229280
    // getComputedStyle returns percent when specified for top/left/bottom/right;
    // rather than make the css module depend on the offset module, just check for it here
    jQuery.each( [ "top", "left" ], function( i, prop ) {
    	jQuery.cssHooks[ prop ] = addGetHookIf( support.pixelPosition,
    		function( elem, computed ) {
    			if ( computed ) {
    				computed = curCSS( elem, prop );
    
    				// If curCSS returns percentage, fallback to offset
    				return rnumnonpx.test( computed ) ?
    					jQuery( elem ).position()[ prop ] + "px" :
    					computed;
    			}
    		}
    	);
    } );
    
    
    // Create innerHeight, innerWidth, height, width, outerHeight and outerWidth methods
    jQuery.each( { Height: "height", Width: "width" }, function( name, type ) {
    	jQuery.each( { padding: "inner" + name, content: type, "": "outer" + name },
    		function( defaultExtra, funcName ) {
    
    		// Margin is only for outerHeight, outerWidth
    		jQuery.fn[ funcName ] = function( margin, value ) {
    			var chainable = arguments.length && ( defaultExtra || typeof margin !== "boolean" ),
    				extra = defaultExtra || ( margin === true || value === true ? "margin" : "border" );
    
    			return access( this, function( elem, type, value ) {
    				var doc;
    
    				if ( jQuery.isWindow( elem ) ) {
    
    					// As of 5/8/2012 this will yield incorrect results for Mobile Safari, but there
    					// isn't a whole lot we can do. See pull request at this URL for discussion:
    					// https://github.com/jquery/jquery/pull/764
    					return elem.document.documentElement[ "client" + name ];
    				}
    
    				// Get document width or height
    				if ( elem.nodeType === 9 ) {
    					doc = elem.documentElement;
    
    					// Either scroll[Width/Height] or offset[Width/Height] or client[Width/Height],
    					// whichever is greatest
    					return Math.max(
    						elem.body[ "scroll" + name ], doc[ "scroll" + name ],
    						elem.body[ "offset" + name ], doc[ "offset" + name ],
    						doc[ "client" + name ]
    					);
    				}
    
    				return value === undefined ?
    
    					// Get width or height on the element, requesting but not forcing parseFloat
    					jQuery.css( elem, type, extra ) :
    
    					// Set width or height on the element
    					jQuery.style( elem, type, value, extra );
    			}, type, chainable ? margin : undefined, chainable, null );
    		};
    	} );
    } );
    
    
    jQuery.fn.extend( {
    
    	bind: function( types, data, fn ) {
    		return this.on( types, null, data, fn );
    	},
    	unbind: function( types, fn ) {
    		return this.off( types, null, fn );
    	},
    
    	delegate: function( selector, types, data, fn ) {
    		return this.on( types, selector, data, fn );
    	},
    	undelegate: function( selector, types, fn ) {
    
    		// ( namespace ) or ( selector, types [, fn] )
    		return arguments.length === 1 ?
    			this.off( selector, "**" ) :
    			this.off( types, selector || "**", fn );
    	},
    	size: function() {
    		return this.length;
    	}
    } );
    
    jQuery.fn.andSelf = jQuery.fn.addBack;
    
    
    
    
    // Register as a named AMD module, since jQuery can be concatenated with other
    // files that may use define, but not via a proper concatenation script that
    // understands anonymous AMD modules. A named AMD is safest and most robust
    // way to register. Lowercase jquery is used because AMD module names are
    // derived from file names, and jQuery is normally delivered in a lowercase
    // file name. Do this after creating the global so that if an AMD module wants
    // to call noConflict to hide this version of jQuery, it will work.
    
    // Note that for maximum portability, libraries that are not jQuery should
    // declare themselves as anonymous modules, and avoid setting a global if an
    // AMD loader is present. jQuery is a special case. For more information, see
    // https://github.com/jrburke/requirejs/wiki/Updating-existing-libraries#wiki-anon
    
    if ( typeof define === "function" && define.amd ) {
    	define( "jquery", [], function() {
    		return jQuery;
    	} );
    }
    
    
    
    var
    
    	// Map over jQuery in case of overwrite
    	_jQuery = window.jQuery,
    
    	// Map over the $ in case of overwrite
    	_$ = window.$;
    
    jQuery.noConflict = function( deep ) {
    	if ( window.$ === jQuery ) {
    		window.$ = _$;
    	}
    
    	if ( deep && window.jQuery === jQuery ) {
    		window.jQuery = _jQuery;
    	}
    
    	return jQuery;
    };
    
    // Expose jQuery and $ identifiers, even in AMD
    // (#7102#comment:10, https://github.com/jquery/jquery/pull/557)
    // and CommonJS for browser emulators (#13566)
    if ( !noGlobal ) {
    	window.jQuery = window.$ = jQuery;
    }
    
    return jQuery;
    }));
    
  provide("jquery", module.exports);
}(global));

// pakmanager:vue
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /*!
     * Vue.js v1.0.16
     * (c) 2016 Evan You
     * Released under the MIT License.
     */
    'use strict';
    
    function set(obj, key, val) {
      if (hasOwn(obj, key)) {
        obj[key] = val;
        return;
      }
      if (obj._isVue) {
        set(obj._data, key, val);
        return;
      }
      var ob = obj.__ob__;
      if (!ob) {
        obj[key] = val;
        return;
      }
      ob.convert(key, val);
      ob.dep.notify();
      if (ob.vms) {
        var i = ob.vms.length;
        while (i--) {
          var vm = ob.vms[i];
          vm._proxy(key);
          vm._digest();
        }
      }
      return val;
    }
    
    /**
     * Delete a property and trigger change if necessary.
     *
     * @param {Object} obj
     * @param {String} key
     */
    
    function del(obj, key) {
      if (!hasOwn(obj, key)) {
        return;
      }
      delete obj[key];
      var ob = obj.__ob__;
      if (!ob) {
        return;
      }
      ob.dep.notify();
      if (ob.vms) {
        var i = ob.vms.length;
        while (i--) {
          var vm = ob.vms[i];
          vm._unproxy(key);
          vm._digest();
        }
      }
    }
    
    var hasOwnProperty = Object.prototype.hasOwnProperty;
    /**
     * Check whether the object has the property.
     *
     * @param {Object} obj
     * @param {String} key
     * @return {Boolean}
     */
    
    function hasOwn(obj, key) {
      return hasOwnProperty.call(obj, key);
    }
    
    /**
     * Check if an expression is a literal value.
     *
     * @param {String} exp
     * @return {Boolean}
     */
    
    var literalValueRE = /^\s?(true|false|-?[\d\.]+|'[^']*'|"[^"]*")\s?$/;
    
    function isLiteral(exp) {
      return literalValueRE.test(exp);
    }
    
    /**
     * Check if a string starts with $ or _
     *
     * @param {String} str
     * @return {Boolean}
     */
    
    function isReserved(str) {
      var c = (str + '').charCodeAt(0);
      return c === 0x24 || c === 0x5F;
    }
    
    /**
     * Guard text output, make sure undefined outputs
     * empty string
     *
     * @param {*} value
     * @return {String}
     */
    
    function _toString(value) {
      return value == null ? '' : value.toString();
    }
    
    /**
     * Check and convert possible numeric strings to numbers
     * before setting back to data
     *
     * @param {*} value
     * @return {*|Number}
     */
    
    function toNumber(value) {
      if (typeof value !== 'string') {
        return value;
      } else {
        var parsed = Number(value);
        return isNaN(parsed) ? value : parsed;
      }
    }
    
    /**
     * Convert string boolean literals into real booleans.
     *
     * @param {*} value
     * @return {*|Boolean}
     */
    
    function toBoolean(value) {
      return value === 'true' ? true : value === 'false' ? false : value;
    }
    
    /**
     * Strip quotes from a string
     *
     * @param {String} str
     * @return {String | false}
     */
    
    function stripQuotes(str) {
      var a = str.charCodeAt(0);
      var b = str.charCodeAt(str.length - 1);
      return a === b && (a === 0x22 || a === 0x27) ? str.slice(1, -1) : str;
    }
    
    /**
     * Camelize a hyphen-delmited string.
     *
     * @param {String} str
     * @return {String}
     */
    
    var camelizeRE = /-(\w)/g;
    
    function camelize(str) {
      return str.replace(camelizeRE, toUpper);
    }
    
    function toUpper(_, c) {
      return c ? c.toUpperCase() : '';
    }
    
    /**
     * Hyphenate a camelCase string.
     *
     * @param {String} str
     * @return {String}
     */
    
    var hyphenateRE = /([a-z\d])([A-Z])/g;
    
    function hyphenate(str) {
      return str.replace(hyphenateRE, '$1-$2').toLowerCase();
    }
    
    /**
     * Converts hyphen/underscore/slash delimitered names into
     * camelized classNames.
     *
     * e.g. my-component => MyComponent
     *      some_else    => SomeElse
     *      some/comp    => SomeComp
     *
     * @param {String} str
     * @return {String}
     */
    
    var classifyRE = /(?:^|[-_\/])(\w)/g;
    
    function classify(str) {
      return str.replace(classifyRE, toUpper);
    }
    
    /**
     * Simple bind, faster than native
     *
     * @param {Function} fn
     * @param {Object} ctx
     * @return {Function}
     */
    
    function bind$1(fn, ctx) {
      return function (a) {
        var l = arguments.length;
        return l ? l > 1 ? fn.apply(ctx, arguments) : fn.call(ctx, a) : fn.call(ctx);
      };
    }
    
    /**
     * Convert an Array-like object to a real Array.
     *
     * @param {Array-like} list
     * @param {Number} [start] - start index
     * @return {Array}
     */
    
    function toArray(list, start) {
      start = start || 0;
      var i = list.length - start;
      var ret = new Array(i);
      while (i--) {
        ret[i] = list[i + start];
      }
      return ret;
    }
    
    /**
     * Mix properties into target object.
     *
     * @param {Object} to
     * @param {Object} from
     */
    
    function extend(to, from) {
      var keys = Object.keys(from);
      var i = keys.length;
      while (i--) {
        to[keys[i]] = from[keys[i]];
      }
      return to;
    }
    
    /**
     * Quick object check - this is primarily used to tell
     * Objects from primitive values when we know the value
     * is a JSON-compliant type.
     *
     * @param {*} obj
     * @return {Boolean}
     */
    
    function isObject(obj) {
      return obj !== null && typeof obj === 'object';
    }
    
    /**
     * Strict object type check. Only returns true
     * for plain JavaScript objects.
     *
     * @param {*} obj
     * @return {Boolean}
     */
    
    var toString = Object.prototype.toString;
    var OBJECT_STRING = '[object Object]';
    
    function isPlainObject(obj) {
      return toString.call(obj) === OBJECT_STRING;
    }
    
    /**
     * Array type check.
     *
     * @param {*} obj
     * @return {Boolean}
     */
    
    var isArray = Array.isArray;
    
    /**
     * Define a non-enumerable property
     *
     * @param {Object} obj
     * @param {String} key
     * @param {*} val
     * @param {Boolean} [enumerable]
     */
    
    function def(obj, key, val, enumerable) {
      Object.defineProperty(obj, key, {
        value: val,
        enumerable: !!enumerable,
        writable: true,
        configurable: true
      });
    }
    
    /**
     * Debounce a function so it only gets called after the
     * input stops arriving after the given wait period.
     *
     * @param {Function} func
     * @param {Number} wait
     * @return {Function} - the debounced function
     */
    
    function _debounce(func, wait) {
      var timeout, args, context, timestamp, result;
      var later = function later() {
        var last = Date.now() - timestamp;
        if (last < wait && last >= 0) {
          timeout = setTimeout(later, wait - last);
        } else {
          timeout = null;
          result = func.apply(context, args);
          if (!timeout) context = args = null;
        }
      };
      return function () {
        context = this;
        args = arguments;
        timestamp = Date.now();
        if (!timeout) {
          timeout = setTimeout(later, wait);
        }
        return result;
      };
    }
    
    /**
     * Manual indexOf because it's slightly faster than
     * native.
     *
     * @param {Array} arr
     * @param {*} obj
     */
    
    function indexOf(arr, obj) {
      var i = arr.length;
      while (i--) {
        if (arr[i] === obj) return i;
      }
      return -1;
    }
    
    /**
     * Make a cancellable version of an async callback.
     *
     * @param {Function} fn
     * @return {Function}
     */
    
    function cancellable(fn) {
      var cb = function cb() {
        if (!cb.cancelled) {
          return fn.apply(this, arguments);
        }
      };
      cb.cancel = function () {
        cb.cancelled = true;
      };
      return cb;
    }
    
    /**
     * Check if two values are loosely equal - that is,
     * if they are plain objects, do they have the same shape?
     *
     * @param {*} a
     * @param {*} b
     * @return {Boolean}
     */
    
    function looseEqual(a, b) {
      /* eslint-disable eqeqeq */
      return a == b || (isObject(a) && isObject(b) ? JSON.stringify(a) === JSON.stringify(b) : false);
      /* eslint-enable eqeqeq */
    }
    
    var hasProto = ('__proto__' in {});
    
    // Browser environment sniffing
    var inBrowser = typeof window !== 'undefined' && Object.prototype.toString.call(window) !== '[object Object]';
    
    var devtools = inBrowser && window.__VUE_DEVTOOLS_GLOBAL_HOOK__;
    
    var isIE9 = inBrowser && navigator.userAgent.toLowerCase().indexOf('msie 9.0') > 0;
    
    var isAndroid = inBrowser && navigator.userAgent.toLowerCase().indexOf('android') > 0;
    
    var transitionProp = undefined;
    var transitionEndEvent = undefined;
    var animationProp = undefined;
    var animationEndEvent = undefined;
    
    // Transition property/event sniffing
    if (inBrowser && !isIE9) {
      var isWebkitTrans = window.ontransitionend === undefined && window.onwebkittransitionend !== undefined;
      var isWebkitAnim = window.onanimationend === undefined && window.onwebkitanimationend !== undefined;
      transitionProp = isWebkitTrans ? 'WebkitTransition' : 'transition';
      transitionEndEvent = isWebkitTrans ? 'webkitTransitionEnd' : 'transitionend';
      animationProp = isWebkitAnim ? 'WebkitAnimation' : 'animation';
      animationEndEvent = isWebkitAnim ? 'webkitAnimationEnd' : 'animationend';
    }
    
    /**
     * Defer a task to execute it asynchronously. Ideally this
     * should be executed as a microtask, so we leverage
     * MutationObserver if it's available, and fallback to
     * setTimeout(0).
     *
     * @param {Function} cb
     * @param {Object} ctx
     */
    
    var nextTick = (function () {
      var callbacks = [];
      var pending = false;
      var timerFunc;
      function nextTickHandler() {
        pending = false;
        var copies = callbacks.slice(0);
        callbacks = [];
        for (var i = 0; i < copies.length; i++) {
          copies[i]();
        }
      }
    
      /* istanbul ignore if */
      if (typeof MutationObserver !== 'undefined') {
        var counter = 1;
        var observer = new MutationObserver(nextTickHandler);
        var textNode = document.createTextNode(counter);
        observer.observe(textNode, {
          characterData: true
        });
        timerFunc = function () {
          counter = (counter + 1) % 2;
          textNode.data = counter;
        };
      } else {
        // webpack attempts to inject a shim for setImmediate
        // if it is used as a global, so we have to work around that to
        // avoid bundling unnecessary code.
        var context = inBrowser ? window : typeof global !== 'undefined' ? global : {};
        timerFunc = context.setImmediate || setTimeout;
      }
      return function (cb, ctx) {
        var func = ctx ? function () {
          cb.call(ctx);
        } : cb;
        callbacks.push(func);
        if (pending) return;
        pending = true;
        timerFunc(nextTickHandler, 0);
      };
    })();
    
    function Cache(limit) {
      this.size = 0;
      this.limit = limit;
      this.head = this.tail = undefined;
      this._keymap = Object.create(null);
    }
    
    var p = Cache.prototype;
    
    /**
     * Put <value> into the cache associated with <key>.
     * Returns the entry which was removed to make room for
     * the new entry. Otherwise undefined is returned.
     * (i.e. if there was enough room already).
     *
     * @param {String} key
     * @param {*} value
     * @return {Entry|undefined}
     */
    
    p.put = function (key, value) {
      var removed;
      if (this.size === this.limit) {
        removed = this.shift();
      }
    
      var entry = this.get(key, true);
      if (!entry) {
        entry = {
          key: key
        };
        this._keymap[key] = entry;
        if (this.tail) {
          this.tail.newer = entry;
          entry.older = this.tail;
        } else {
          this.head = entry;
        }
        this.tail = entry;
        this.size++;
      }
      entry.value = value;
    
      return removed;
    };
    
    /**
     * Purge the least recently used (oldest) entry from the
     * cache. Returns the removed entry or undefined if the
     * cache was empty.
     */
    
    p.shift = function () {
      var entry = this.head;
      if (entry) {
        this.head = this.head.newer;
        this.head.older = undefined;
        entry.newer = entry.older = undefined;
        this._keymap[entry.key] = undefined;
        this.size--;
      }
      return entry;
    };
    
    /**
     * Get and register recent use of <key>. Returns the value
     * associated with <key> or undefined if not in cache.
     *
     * @param {String} key
     * @param {Boolean} returnEntry
     * @return {Entry|*}
     */
    
    p.get = function (key, returnEntry) {
      var entry = this._keymap[key];
      if (entry === undefined) return;
      if (entry === this.tail) {
        return returnEntry ? entry : entry.value;
      }
      // HEAD--------------TAIL
      //   <.older   .newer>
      //  <--- add direction --
      //   A  B  C  <D>  E
      if (entry.newer) {
        if (entry === this.head) {
          this.head = entry.newer;
        }
        entry.newer.older = entry.older; // C <-- E.
      }
      if (entry.older) {
        entry.older.newer = entry.newer; // C. --> E
      }
      entry.newer = undefined; // D --x
      entry.older = this.tail; // D. --> E
      if (this.tail) {
        this.tail.newer = entry; // E. <-- D
      }
      this.tail = entry;
      return returnEntry ? entry : entry.value;
    };
    
    var cache$1 = new Cache(1000);
    var filterTokenRE = /[^\s'"]+|'[^']*'|"[^"]*"/g;
    var reservedArgRE = /^in$|^-?\d+/;
    
    /**
     * Parser state
     */
    
    var str;
    var dir;
    var c;
    var prev;
    var i;
    var l;
    var lastFilterIndex;
    var inSingle;
    var inDouble;
    var curly;
    var square;
    var paren;
    /**
     * Push a filter to the current directive object
     */
    
    function pushFilter() {
      var exp = str.slice(lastFilterIndex, i).trim();
      var filter;
      if (exp) {
        filter = {};
        var tokens = exp.match(filterTokenRE);
        filter.name = tokens[0];
        if (tokens.length > 1) {
          filter.args = tokens.slice(1).map(processFilterArg);
        }
      }
      if (filter) {
        (dir.filters = dir.filters || []).push(filter);
      }
      lastFilterIndex = i + 1;
    }
    
    /**
     * Check if an argument is dynamic and strip quotes.
     *
     * @param {String} arg
     * @return {Object}
     */
    
    function processFilterArg(arg) {
      if (reservedArgRE.test(arg)) {
        return {
          value: toNumber(arg),
          dynamic: false
        };
      } else {
        var stripped = stripQuotes(arg);
        var dynamic = stripped === arg;
        return {
          value: dynamic ? arg : stripped,
          dynamic: dynamic
        };
      }
    }
    
    /**
     * Parse a directive value and extract the expression
     * and its filters into a descriptor.
     *
     * Example:
     *
     * "a + 1 | uppercase" will yield:
     * {
     *   expression: 'a + 1',
     *   filters: [
     *     { name: 'uppercase', args: null }
     *   ]
     * }
     *
     * @param {String} str
     * @return {Object}
     */
    
    function parseDirective(s) {
    
      var hit = cache$1.get(s);
      if (hit) {
        return hit;
      }
    
      // reset parser state
      str = s;
      inSingle = inDouble = false;
      curly = square = paren = 0;
      lastFilterIndex = 0;
      dir = {};
    
      for (i = 0, l = str.length; i < l; i++) {
        prev = c;
        c = str.charCodeAt(i);
        if (inSingle) {
          // check single quote
          if (c === 0x27 && prev !== 0x5C) inSingle = !inSingle;
        } else if (inDouble) {
          // check double quote
          if (c === 0x22 && prev !== 0x5C) inDouble = !inDouble;
        } else if (c === 0x7C && // pipe
        str.charCodeAt(i + 1) !== 0x7C && str.charCodeAt(i - 1) !== 0x7C) {
          if (dir.expression == null) {
            // first filter, end of expression
            lastFilterIndex = i + 1;
            dir.expression = str.slice(0, i).trim();
          } else {
            // already has filter
            pushFilter();
          }
        } else {
          switch (c) {
            case 0x22:
              inDouble = true;break; // "
            case 0x27:
              inSingle = true;break; // '
            case 0x28:
              paren++;break; // (
            case 0x29:
              paren--;break; // )
            case 0x5B:
              square++;break; // [
            case 0x5D:
              square--;break; // ]
            case 0x7B:
              curly++;break; // {
            case 0x7D:
              curly--;break; // }
          }
        }
      }
    
      if (dir.expression == null) {
        dir.expression = str.slice(0, i).trim();
      } else if (lastFilterIndex !== 0) {
        pushFilter();
      }
    
      cache$1.put(s, dir);
      return dir;
    }
    
    var directive = Object.freeze({
      parseDirective: parseDirective
    });
    
    var regexEscapeRE = /[-.*+?^${}()|[\]\/\\]/g;
    var cache = undefined;
    var tagRE = undefined;
    var htmlRE = undefined;
    /**
     * Escape a string so it can be used in a RegExp
     * constructor.
     *
     * @param {String} str
     */
    
    function escapeRegex(str) {
      return str.replace(regexEscapeRE, '\\$&');
    }
    
    function compileRegex() {
      var open = escapeRegex(config.delimiters[0]);
      var close = escapeRegex(config.delimiters[1]);
      var unsafeOpen = escapeRegex(config.unsafeDelimiters[0]);
      var unsafeClose = escapeRegex(config.unsafeDelimiters[1]);
      tagRE = new RegExp(unsafeOpen + '(.+?)' + unsafeClose + '|' + open + '(.+?)' + close, 'g');
      htmlRE = new RegExp('^' + unsafeOpen + '.*' + unsafeClose + '$');
      // reset cache
      cache = new Cache(1000);
    }
    
    /**
     * Parse a template text string into an array of tokens.
     *
     * @param {String} text
     * @return {Array<Object> | null}
     *               - {String} type
     *               - {String} value
     *               - {Boolean} [html]
     *               - {Boolean} [oneTime]
     */
    
    function parseText(text) {
      if (!cache) {
        compileRegex();
      }
      var hit = cache.get(text);
      if (hit) {
        return hit;
      }
      text = text.replace(/\n/g, '');
      if (!tagRE.test(text)) {
        return null;
      }
      var tokens = [];
      var lastIndex = tagRE.lastIndex = 0;
      var match, index, html, value, first, oneTime;
      /* eslint-disable no-cond-assign */
      while (match = tagRE.exec(text)) {
        /* eslint-enable no-cond-assign */
        index = match.index;
        // push text token
        if (index > lastIndex) {
          tokens.push({
            value: text.slice(lastIndex, index)
          });
        }
        // tag token
        html = htmlRE.test(match[0]);
        value = html ? match[1] : match[2];
        first = value.charCodeAt(0);
        oneTime = first === 42; // *
        value = oneTime ? value.slice(1) : value;
        tokens.push({
          tag: true,
          value: value.trim(),
          html: html,
          oneTime: oneTime
        });
        lastIndex = index + match[0].length;
      }
      if (lastIndex < text.length) {
        tokens.push({
          value: text.slice(lastIndex)
        });
      }
      cache.put(text, tokens);
      return tokens;
    }
    
    /**
     * Format a list of tokens into an expression.
     * e.g. tokens parsed from 'a {{b}} c' can be serialized
     * into one single expression as '"a " + b + " c"'.
     *
     * @param {Array} tokens
     * @param {Vue} [vm]
     * @return {String}
     */
    
    function tokensToExp(tokens, vm) {
      if (tokens.length > 1) {
        return tokens.map(function (token) {
          return formatToken(token, vm);
        }).join('+');
      } else {
        return formatToken(tokens[0], vm, true);
      }
    }
    
    /**
     * Format a single token.
     *
     * @param {Object} token
     * @param {Vue} [vm]
     * @param {Boolean} [single]
     * @return {String}
     */
    
    function formatToken(token, vm, single) {
      return token.tag ? token.oneTime && vm ? '"' + vm.$eval(token.value) + '"' : inlineFilters(token.value, single) : '"' + token.value + '"';
    }
    
    /**
     * For an attribute with multiple interpolation tags,
     * e.g. attr="some-{{thing | filter}}", in order to combine
     * the whole thing into a single watchable expression, we
     * have to inline those filters. This function does exactly
     * that. This is a bit hacky but it avoids heavy changes
     * to directive parser and watcher mechanism.
     *
     * @param {String} exp
     * @param {Boolean} single
     * @return {String}
     */
    
    var filterRE$1 = /[^|]\|[^|]/;
    function inlineFilters(exp, single) {
      if (!filterRE$1.test(exp)) {
        return single ? exp : '(' + exp + ')';
      } else {
        var dir = parseDirective(exp);
        if (!dir.filters) {
          return '(' + exp + ')';
        } else {
          return 'this._applyFilters(' + dir.expression + // value
          ',null,' + // oldValue (null for read)
          JSON.stringify(dir.filters) + // filter descriptors
          ',false)'; // write?
        }
      }
    }
    
    var text$1 = Object.freeze({
      compileRegex: compileRegex,
      parseText: parseText,
      tokensToExp: tokensToExp
    });
    
    var delimiters = ['{{', '}}'];
    var unsafeDelimiters = ['{{{', '}}}'];
    
    var config = Object.defineProperties({
    
      /**
       * Whether to print debug messages.
       * Also enables stack trace for warnings.
       *
       * @type {Boolean}
       */
    
      debug: false,
    
      /**
       * Whether to suppress warnings.
       *
       * @type {Boolean}
       */
    
      silent: false,
    
      /**
       * Whether to use async rendering.
       */
    
      async: true,
    
      /**
       * Whether to warn against errors caught when evaluating
       * expressions.
       */
    
      warnExpressionErrors: true,
    
      /**
       * Whether or not to handle fully object properties which
       * are already backed by getters and seters. Depending on
       * use case and environment, this might introduce non-neglible
       * performance penalties.
       */
      convertAllProperties: false,
    
      /**
       * Internal flag to indicate the delimiters have been
       * changed.
       *
       * @type {Boolean}
       */
    
      _delimitersChanged: true,
    
      /**
       * List of asset types that a component can own.
       *
       * @type {Array}
       */
    
      _assetTypes: ['component', 'directive', 'elementDirective', 'filter', 'transition', 'partial'],
    
      /**
       * prop binding modes
       */
    
      _propBindingModes: {
        ONE_WAY: 0,
        TWO_WAY: 1,
        ONE_TIME: 2
      },
    
      /**
       * Max circular updates allowed in a batcher flush cycle.
       */
    
      _maxUpdateCount: 100
    
    }, {
      delimiters: { /**
                     * Interpolation delimiters. Changing these would trigger
                     * the text parser to re-compile the regular expressions.
                     *
                     * @type {Array<String>}
                     */
    
        get: function get() {
          return delimiters;
        },
        set: function set(val) {
          delimiters = val;
          compileRegex();
        },
        configurable: true,
        enumerable: true
      },
      unsafeDelimiters: {
        get: function get() {
          return unsafeDelimiters;
        },
        set: function set(val) {
          unsafeDelimiters = val;
          compileRegex();
        },
        configurable: true,
        enumerable: true
      }
    });
    
    var warn = undefined;
    
    if (process.env.NODE_ENV !== 'production') {
      (function () {
        var hasConsole = typeof console !== 'undefined';
        warn = function (msg, e) {
          if (hasConsole && (!config.silent || config.debug)) {
            console.warn('[Vue warn]: ' + msg);
            /* istanbul ignore if */
            if (config.debug) {
              if (e) {
                throw e;
              } else {
                console.warn(new Error('Warning Stack Trace').stack);
              }
            }
          }
        };
      })();
    }
    
    /**
     * Append with transition.
     *
     * @param {Element} el
     * @param {Element} target
     * @param {Vue} vm
     * @param {Function} [cb]
     */
    
    function appendWithTransition(el, target, vm, cb) {
      applyTransition(el, 1, function () {
        target.appendChild(el);
      }, vm, cb);
    }
    
    /**
     * InsertBefore with transition.
     *
     * @param {Element} el
     * @param {Element} target
     * @param {Vue} vm
     * @param {Function} [cb]
     */
    
    function beforeWithTransition(el, target, vm, cb) {
      applyTransition(el, 1, function () {
        before(el, target);
      }, vm, cb);
    }
    
    /**
     * Remove with transition.
     *
     * @param {Element} el
     * @param {Vue} vm
     * @param {Function} [cb]
     */
    
    function removeWithTransition(el, vm, cb) {
      applyTransition(el, -1, function () {
        remove(el);
      }, vm, cb);
    }
    
    /**
     * Apply transitions with an operation callback.
     *
     * @param {Element} el
     * @param {Number} direction
     *                  1: enter
     *                 -1: leave
     * @param {Function} op - the actual DOM operation
     * @param {Vue} vm
     * @param {Function} [cb]
     */
    
    function applyTransition(el, direction, op, vm, cb) {
      var transition = el.__v_trans;
      if (!transition ||
      // skip if there are no js hooks and CSS transition is
      // not supported
      !transition.hooks && !transitionEndEvent ||
      // skip transitions for initial compile
      !vm._isCompiled ||
      // if the vm is being manipulated by a parent directive
      // during the parent's compilation phase, skip the
      // animation.
      vm.$parent && !vm.$parent._isCompiled) {
        op();
        if (cb) cb();
        return;
      }
      var action = direction > 0 ? 'enter' : 'leave';
      transition[action](op, cb);
    }
    
    /**
     * Query an element selector if it's not an element already.
     *
     * @param {String|Element} el
     * @return {Element}
     */
    
    function query(el) {
      if (typeof el === 'string') {
        var selector = el;
        el = document.querySelector(el);
        if (!el) {
          process.env.NODE_ENV !== 'production' && warn('Cannot find element: ' + selector);
        }
      }
      return el;
    }
    
    /**
     * Check if a node is in the document.
     * Note: document.documentElement.contains should work here
     * but always returns false for comment nodes in phantomjs,
     * making unit tests difficult. This is fixed by doing the
     * contains() check on the node's parentNode instead of
     * the node itself.
     *
     * @param {Node} node
     * @return {Boolean}
     */
    
    function inDoc(node) {
      var doc = document.documentElement;
      var parent = node && node.parentNode;
      return doc === node || doc === parent || !!(parent && parent.nodeType === 1 && doc.contains(parent));
    }
    
    /**
     * Get and remove an attribute from a node.
     *
     * @param {Node} node
     * @param {String} _attr
     */
    
    function getAttr(node, _attr) {
      var val = node.getAttribute(_attr);
      if (val !== null) {
        node.removeAttribute(_attr);
      }
      return val;
    }
    
    /**
     * Get an attribute with colon or v-bind: prefix.
     *
     * @param {Node} node
     * @param {String} name
     * @return {String|null}
     */
    
    function getBindAttr(node, name) {
      var val = getAttr(node, ':' + name);
      if (val === null) {
        val = getAttr(node, 'v-bind:' + name);
      }
      return val;
    }
    
    /**
     * Check the presence of a bind attribute.
     *
     * @param {Node} node
     * @param {String} name
     * @return {Boolean}
     */
    
    function hasBindAttr(node, name) {
      return node.hasAttribute(name) || node.hasAttribute(':' + name) || node.hasAttribute('v-bind:' + name);
    }
    
    /**
     * Insert el before target
     *
     * @param {Element} el
     * @param {Element} target
     */
    
    function before(el, target) {
      target.parentNode.insertBefore(el, target);
    }
    
    /**
     * Insert el after target
     *
     * @param {Element} el
     * @param {Element} target
     */
    
    function after(el, target) {
      if (target.nextSibling) {
        before(el, target.nextSibling);
      } else {
        target.parentNode.appendChild(el);
      }
    }
    
    /**
     * Remove el from DOM
     *
     * @param {Element} el
     */
    
    function remove(el) {
      el.parentNode.removeChild(el);
    }
    
    /**
     * Prepend el to target
     *
     * @param {Element} el
     * @param {Element} target
     */
    
    function prepend(el, target) {
      if (target.firstChild) {
        before(el, target.firstChild);
      } else {
        target.appendChild(el);
      }
    }
    
    /**
     * Replace target with el
     *
     * @param {Element} target
     * @param {Element} el
     */
    
    function replace(target, el) {
      var parent = target.parentNode;
      if (parent) {
        parent.replaceChild(el, target);
      }
    }
    
    /**
     * Add event listener shorthand.
     *
     * @param {Element} el
     * @param {String} event
     * @param {Function} cb
     * @param {Boolean} [useCapture]
     */
    
    function on$1(el, event, cb, useCapture) {
      el.addEventListener(event, cb, useCapture);
    }
    
    /**
     * Remove event listener shorthand.
     *
     * @param {Element} el
     * @param {String} event
     * @param {Function} cb
     */
    
    function off(el, event, cb) {
      el.removeEventListener(event, cb);
    }
    
    /**
     * In IE9, setAttribute('class') will result in empty class
     * if the element also has the :class attribute; However in
     * PhantomJS, setting `className` does not work on SVG elements...
     * So we have to do a conditional check here.
     *
     * @param {Element} el
     * @param {String} cls
     */
    
    function setClass(el, cls) {
      /* istanbul ignore if */
      if (isIE9 && !(el instanceof SVGElement)) {
        el.className = cls;
      } else {
        el.setAttribute('class', cls);
      }
    }
    
    /**
     * Add class with compatibility for IE & SVG
     *
     * @param {Element} el
     * @param {String} cls
     */
    
    function addClass(el, cls) {
      if (el.classList) {
        el.classList.add(cls);
      } else {
        var cur = ' ' + (el.getAttribute('class') || '') + ' ';
        if (cur.indexOf(' ' + cls + ' ') < 0) {
          setClass(el, (cur + cls).trim());
        }
      }
    }
    
    /**
     * Remove class with compatibility for IE & SVG
     *
     * @param {Element} el
     * @param {String} cls
     */
    
    function removeClass(el, cls) {
      if (el.classList) {
        el.classList.remove(cls);
      } else {
        var cur = ' ' + (el.getAttribute('class') || '') + ' ';
        var tar = ' ' + cls + ' ';
        while (cur.indexOf(tar) >= 0) {
          cur = cur.replace(tar, ' ');
        }
        setClass(el, cur.trim());
      }
      if (!el.className) {
        el.removeAttribute('class');
      }
    }
    
    /**
     * Extract raw content inside an element into a temporary
     * container div
     *
     * @param {Element} el
     * @param {Boolean} asFragment
     * @return {Element}
     */
    
    function extractContent(el, asFragment) {
      var child;
      var rawContent;
      /* istanbul ignore if */
      if (isTemplate(el) && el.content instanceof DocumentFragment) {
        el = el.content;
      }
      if (el.hasChildNodes()) {
        trimNode(el);
        rawContent = asFragment ? document.createDocumentFragment() : document.createElement('div');
        /* eslint-disable no-cond-assign */
        while (child = el.firstChild) {
          /* eslint-enable no-cond-assign */
          rawContent.appendChild(child);
        }
      }
      return rawContent;
    }
    
    /**
     * Trim possible empty head/tail text and comment
     * nodes inside a parent.
     *
     * @param {Node} node
     */
    
    function trimNode(node) {
      var child;
      /* eslint-disable no-sequences */
      while ((child = node.firstChild, isTrimmable(child))) {
        node.removeChild(child);
      }
      while ((child = node.lastChild, isTrimmable(child))) {
        node.removeChild(child);
      }
      /* eslint-enable no-sequences */
    }
    
    function isTrimmable(node) {
      return node && (node.nodeType === 3 && !node.data.trim() || node.nodeType === 8);
    }
    
    /**
     * Check if an element is a template tag.
     * Note if the template appears inside an SVG its tagName
     * will be in lowercase.
     *
     * @param {Element} el
     */
    
    function isTemplate(el) {
      return el.tagName && el.tagName.toLowerCase() === 'template';
    }
    
    /**
     * Create an "anchor" for performing dom insertion/removals.
     * This is used in a number of scenarios:
     * - fragment instance
     * - v-html
     * - v-if
     * - v-for
     * - component
     *
     * @param {String} content
     * @param {Boolean} persist - IE trashes empty textNodes on
     *                            cloneNode(true), so in certain
     *                            cases the anchor needs to be
     *                            non-empty to be persisted in
     *                            templates.
     * @return {Comment|Text}
     */
    
    function createAnchor(content, persist) {
      var anchor = config.debug ? document.createComment(content) : document.createTextNode(persist ? ' ' : '');
      anchor.__vue_anchor = true;
      return anchor;
    }
    
    /**
     * Find a component ref attribute that starts with $.
     *
     * @param {Element} node
     * @return {String|undefined}
     */
    
    var refRE = /^v-ref:/;
    
    function findRef(node) {
      if (node.hasAttributes()) {
        var attrs = node.attributes;
        for (var i = 0, l = attrs.length; i < l; i++) {
          var name = attrs[i].name;
          if (refRE.test(name)) {
            return camelize(name.replace(refRE, ''));
          }
        }
      }
    }
    
    /**
     * Map a function to a range of nodes .
     *
     * @param {Node} node
     * @param {Node} end
     * @param {Function} op
     */
    
    function mapNodeRange(node, end, op) {
      var next;
      while (node !== end) {
        next = node.nextSibling;
        op(node);
        node = next;
      }
      op(end);
    }
    
    /**
     * Remove a range of nodes with transition, store
     * the nodes in a fragment with correct ordering,
     * and call callback when done.
     *
     * @param {Node} start
     * @param {Node} end
     * @param {Vue} vm
     * @param {DocumentFragment} frag
     * @param {Function} cb
     */
    
    function removeNodeRange(start, end, vm, frag, cb) {
      var done = false;
      var removed = 0;
      var nodes = [];
      mapNodeRange(start, end, function (node) {
        if (node === end) done = true;
        nodes.push(node);
        removeWithTransition(node, vm, onRemoved);
      });
      function onRemoved() {
        removed++;
        if (done && removed >= nodes.length) {
          for (var i = 0; i < nodes.length; i++) {
            frag.appendChild(nodes[i]);
          }
          cb && cb();
        }
      }
    }
    
    var commonTagRE = /^(div|p|span|img|a|b|i|br|ul|ol|li|h1|h2|h3|h4|h5|h6|code|pre|table|th|td|tr|form|label|input|select|option|nav|article|section|header|footer)$/;
    var reservedTagRE = /^(slot|partial|component)$/;
    
    /**
     * Check if an element is a component, if yes return its
     * component id.
     *
     * @param {Element} el
     * @param {Object} options
     * @return {Object|undefined}
     */
    
    function checkComponentAttr(el, options) {
      var tag = el.tagName.toLowerCase();
      var hasAttrs = el.hasAttributes();
      if (!commonTagRE.test(tag) && !reservedTagRE.test(tag)) {
        if (resolveAsset(options, 'components', tag)) {
          return { id: tag };
        } else {
          var is = hasAttrs && getIsBinding(el);
          if (is) {
            return is;
          } else if (process.env.NODE_ENV !== 'production') {
            if (tag.indexOf('-') > -1 || /HTMLUnknownElement/.test(el.toString()) &&
            // Chrome returns unknown for several HTML5 elements.
            // https://code.google.com/p/chromium/issues/detail?id=540526
            !/^(data|time|rtc|rb)$/.test(tag)) {
              warn('Unknown custom element: <' + tag + '> - did you ' + 'register the component correctly? For recursive components, ' + 'make sure to provide the "name" option.');
            }
          }
        }
      } else if (hasAttrs) {
        return getIsBinding(el);
      }
    }
    
    /**
     * Get "is" binding from an element.
     *
     * @param {Element} el
     * @return {Object|undefined}
     */
    
    function getIsBinding(el) {
      // dynamic syntax
      var exp = getAttr(el, 'is');
      if (exp != null) {
        return { id: exp };
      } else {
        exp = getBindAttr(el, 'is');
        if (exp != null) {
          return { id: exp, dynamic: true };
        }
      }
    }
    
    /**
     * Set a prop's initial value on a vm and its data object.
     *
     * @param {Vue} vm
     * @param {Object} prop
     * @param {*} value
     */
    
    function initProp(vm, prop, value) {
      var key = prop.path;
      value = coerceProp(prop, value);
      vm[key] = vm._data[key] = assertProp(prop, value) ? value : undefined;
    }
    
    /**
     * Assert whether a prop is valid.
     *
     * @param {Object} prop
     * @param {*} value
     */
    
    function assertProp(prop, value) {
      // if a prop is not provided and is not required,
      // skip the check.
      if (prop.raw === null && !prop.required) {
        return true;
      }
      var options = prop.options;
      var type = options.type;
      var valid = true;
      var expectedType;
      if (type) {
        if (type === String) {
          expectedType = 'string';
          valid = typeof value === expectedType;
        } else if (type === Number) {
          expectedType = 'number';
          valid = typeof value === 'number';
        } else if (type === Boolean) {
          expectedType = 'boolean';
          valid = typeof value === 'boolean';
        } else if (type === Function) {
          expectedType = 'function';
          valid = typeof value === 'function';
        } else if (type === Object) {
          expectedType = 'object';
          valid = isPlainObject(value);
        } else if (type === Array) {
          expectedType = 'array';
          valid = isArray(value);
        } else {
          valid = value instanceof type;
        }
      }
      if (!valid) {
        process.env.NODE_ENV !== 'production' && warn('Invalid prop: type check failed for ' + prop.path + '="' + prop.raw + '".' + ' Expected ' + formatType(expectedType) + ', got ' + formatValue(value) + '.');
        return false;
      }
      var validator = options.validator;
      if (validator) {
        if (!validator.call(null, value)) {
          process.env.NODE_ENV !== 'production' && warn('Invalid prop: custom validator check failed for ' + prop.path + '="' + prop.raw + '"');
          return false;
        }
      }
      return true;
    }
    
    /**
     * Force parsing value with coerce option.
     *
     * @param {*} value
     * @param {Object} options
     * @return {*}
     */
    
    function coerceProp(prop, value) {
      var coerce = prop.options.coerce;
      if (!coerce) {
        return value;
      }
      // coerce is a function
      return coerce(value);
    }
    
    function formatType(val) {
      return val ? val.charAt(0).toUpperCase() + val.slice(1) : 'custom type';
    }
    
    function formatValue(val) {
      return Object.prototype.toString.call(val).slice(8, -1);
    }
    
    /**
     * Option overwriting strategies are functions that handle
     * how to merge a parent option value and a child option
     * value into the final value.
     *
     * All strategy functions follow the same signature:
     *
     * @param {*} parentVal
     * @param {*} childVal
     * @param {Vue} [vm]
     */
    
    var strats = config.optionMergeStrategies = Object.create(null);
    
    /**
     * Helper that recursively merges two data objects together.
     */
    
    function mergeData(to, from) {
      var key, toVal, fromVal;
      for (key in from) {
        toVal = to[key];
        fromVal = from[key];
        if (!hasOwn(to, key)) {
          set(to, key, fromVal);
        } else if (isObject(toVal) && isObject(fromVal)) {
          mergeData(toVal, fromVal);
        }
      }
      return to;
    }
    
    /**
     * Data
     */
    
    strats.data = function (parentVal, childVal, vm) {
      if (!vm) {
        // in a Vue.extend merge, both should be functions
        if (!childVal) {
          return parentVal;
        }
        if (typeof childVal !== 'function') {
          process.env.NODE_ENV !== 'production' && warn('The "data" option should be a function ' + 'that returns a per-instance value in component ' + 'definitions.');
          return parentVal;
        }
        if (!parentVal) {
          return childVal;
        }
        // when parentVal & childVal are both present,
        // we need to return a function that returns the
        // merged result of both functions... no need to
        // check if parentVal is a function here because
        // it has to be a function to pass previous merges.
        return function mergedDataFn() {
          return mergeData(childVal.call(this), parentVal.call(this));
        };
      } else if (parentVal || childVal) {
        return function mergedInstanceDataFn() {
          // instance merge
          var instanceData = typeof childVal === 'function' ? childVal.call(vm) : childVal;
          var defaultData = typeof parentVal === 'function' ? parentVal.call(vm) : undefined;
          if (instanceData) {
            return mergeData(instanceData, defaultData);
          } else {
            return defaultData;
          }
        };
      }
    };
    
    /**
     * El
     */
    
    strats.el = function (parentVal, childVal, vm) {
      if (!vm && childVal && typeof childVal !== 'function') {
        process.env.NODE_ENV !== 'production' && warn('The "el" option should be a function ' + 'that returns a per-instance value in component ' + 'definitions.');
        return;
      }
      var ret = childVal || parentVal;
      // invoke the element factory if this is instance merge
      return vm && typeof ret === 'function' ? ret.call(vm) : ret;
    };
    
    /**
     * Hooks and param attributes are merged as arrays.
     */
    
    strats.init = strats.created = strats.ready = strats.attached = strats.detached = strats.beforeCompile = strats.compiled = strats.beforeDestroy = strats.destroyed = function (parentVal, childVal) {
      return childVal ? parentVal ? parentVal.concat(childVal) : isArray(childVal) ? childVal : [childVal] : parentVal;
    };
    
    /**
     * 0.11 deprecation warning
     */
    
    strats.paramAttributes = function () {
      /* istanbul ignore next */
      process.env.NODE_ENV !== 'production' && warn('"paramAttributes" option has been deprecated in 0.12. ' + 'Use "props" instead.');
    };
    
    /**
     * Assets
     *
     * When a vm is present (instance creation), we need to do
     * a three-way merge between constructor options, instance
     * options and parent options.
     */
    
    function mergeAssets(parentVal, childVal) {
      var res = Object.create(parentVal);
      return childVal ? extend(res, guardArrayAssets(childVal)) : res;
    }
    
    config._assetTypes.forEach(function (type) {
      strats[type + 's'] = mergeAssets;
    });
    
    /**
     * Events & Watchers.
     *
     * Events & watchers hashes should not overwrite one
     * another, so we merge them as arrays.
     */
    
    strats.watch = strats.events = function (parentVal, childVal) {
      if (!childVal) return parentVal;
      if (!parentVal) return childVal;
      var ret = {};
      extend(ret, parentVal);
      for (var key in childVal) {
        var parent = ret[key];
        var child = childVal[key];
        if (parent && !isArray(parent)) {
          parent = [parent];
        }
        ret[key] = parent ? parent.concat(child) : [child];
      }
      return ret;
    };
    
    /**
     * Other object hashes.
     */
    
    strats.props = strats.methods = strats.computed = function (parentVal, childVal) {
      if (!childVal) return parentVal;
      if (!parentVal) return childVal;
      var ret = Object.create(null);
      extend(ret, parentVal);
      extend(ret, childVal);
      return ret;
    };
    
    /**
     * Default strategy.
     */
    
    var defaultStrat = function defaultStrat(parentVal, childVal) {
      return childVal === undefined ? parentVal : childVal;
    };
    
    /**
     * Make sure component options get converted to actual
     * constructors.
     *
     * @param {Object} options
     */
    
    function guardComponents(options) {
      if (options.components) {
        var components = options.components = guardArrayAssets(options.components);
        var def;
        var ids = Object.keys(components);
        for (var i = 0, l = ids.length; i < l; i++) {
          var key = ids[i];
          if (commonTagRE.test(key) || reservedTagRE.test(key)) {
            process.env.NODE_ENV !== 'production' && warn('Do not use built-in or reserved HTML elements as component ' + 'id: ' + key);
            continue;
          }
          def = components[key];
          if (isPlainObject(def)) {
            components[key] = Vue.extend(def);
          }
        }
      }
    }
    
    /**
     * Ensure all props option syntax are normalized into the
     * Object-based format.
     *
     * @param {Object} options
     */
    
    function guardProps(options) {
      var props = options.props;
      var i, val;
      if (isArray(props)) {
        options.props = {};
        i = props.length;
        while (i--) {
          val = props[i];
          if (typeof val === 'string') {
            options.props[val] = null;
          } else if (val.name) {
            options.props[val.name] = val;
          }
        }
      } else if (isPlainObject(props)) {
        var keys = Object.keys(props);
        i = keys.length;
        while (i--) {
          val = props[keys[i]];
          if (typeof val === 'function') {
            props[keys[i]] = { type: val };
          }
        }
      }
    }
    
    /**
     * Guard an Array-format assets option and converted it
     * into the key-value Object format.
     *
     * @param {Object|Array} assets
     * @return {Object}
     */
    
    function guardArrayAssets(assets) {
      if (isArray(assets)) {
        var res = {};
        var i = assets.length;
        var asset;
        while (i--) {
          asset = assets[i];
          var id = typeof asset === 'function' ? asset.options && asset.options.name || asset.id : asset.name || asset.id;
          if (!id) {
            process.env.NODE_ENV !== 'production' && warn('Array-syntax assets must provide a "name" or "id" field.');
          } else {
            res[id] = asset;
          }
        }
        return res;
      }
      return assets;
    }
    
    /**
     * Merge two option objects into a new one.
     * Core utility used in both instantiation and inheritance.
     *
     * @param {Object} parent
     * @param {Object} child
     * @param {Vue} [vm] - if vm is present, indicates this is
     *                     an instantiation merge.
     */
    
    function mergeOptions(parent, child, vm) {
      guardComponents(child);
      guardProps(child);
      var options = {};
      var key;
      if (child.mixins) {
        for (var i = 0, l = child.mixins.length; i < l; i++) {
          parent = mergeOptions(parent, child.mixins[i], vm);
        }
      }
      for (key in parent) {
        mergeField(key);
      }
      for (key in child) {
        if (!hasOwn(parent, key)) {
          mergeField(key);
        }
      }
      function mergeField(key) {
        var strat = strats[key] || defaultStrat;
        options[key] = strat(parent[key], child[key], vm, key);
      }
      return options;
    }
    
    /**
     * Resolve an asset.
     * This function is used because child instances need access
     * to assets defined in its ancestor chain.
     *
     * @param {Object} options
     * @param {String} type
     * @param {String} id
     * @return {Object|Function}
     */
    
    function resolveAsset(options, type, id) {
      /* istanbul ignore if */
      if (typeof id !== 'string') {
        return;
      }
      var assets = options[type];
      var camelizedId;
      return assets[id] ||
      // camelCase ID
      assets[camelizedId = camelize(id)] ||
      // Pascal Case ID
      assets[camelizedId.charAt(0).toUpperCase() + camelizedId.slice(1)];
    }
    
    /**
     * Assert asset exists
     */
    
    function assertAsset(val, type, id) {
      if (!val) {
        process.env.NODE_ENV !== 'production' && warn('Failed to resolve ' + type + ': ' + id);
      }
    }
    
    var arrayProto = Array.prototype;
    var arrayMethods = Object.create(arrayProto)
    
    /**
     * Intercept mutating methods and emit events
     */
    
    ;['push', 'pop', 'shift', 'unshift', 'splice', 'sort', 'reverse'].forEach(function (method) {
      // cache original method
      var original = arrayProto[method];
      def(arrayMethods, method, function mutator() {
        // avoid leaking arguments:
        // http://jsperf.com/closure-with-arguments
        var i = arguments.length;
        var args = new Array(i);
        while (i--) {
          args[i] = arguments[i];
        }
        var result = original.apply(this, args);
        var ob = this.__ob__;
        var inserted;
        switch (method) {
          case 'push':
            inserted = args;
            break;
          case 'unshift':
            inserted = args;
            break;
          case 'splice':
            inserted = args.slice(2);
            break;
        }
        if (inserted) ob.observeArray(inserted);
        // notify change
        ob.dep.notify();
        return result;
      });
    });
    
    /**
     * Swap the element at the given index with a new value
     * and emits corresponding event.
     *
     * @param {Number} index
     * @param {*} val
     * @return {*} - replaced element
     */
    
    def(arrayProto, '$set', function $set(index, val) {
      if (index >= this.length) {
        this.length = Number(index) + 1;
      }
      return this.splice(index, 1, val)[0];
    });
    
    /**
     * Convenience method to remove the element at given index.
     *
     * @param {Number} index
     * @param {*} val
     */
    
    def(arrayProto, '$remove', function $remove(item) {
      /* istanbul ignore if */
      if (!this.length) return;
      var index = indexOf(this, item);
      if (index > -1) {
        return this.splice(index, 1);
      }
    });
    
    var uid$3 = 0;
    
    /**
     * A dep is an observable that can have multiple
     * directives subscribing to it.
     *
     * @constructor
     */
    function Dep() {
      this.id = uid$3++;
      this.subs = [];
    }
    
    // the current target watcher being evaluated.
    // this is globally unique because there could be only one
    // watcher being evaluated at any time.
    Dep.target = null;
    
    /**
     * Add a directive subscriber.
     *
     * @param {Directive} sub
     */
    
    Dep.prototype.addSub = function (sub) {
      this.subs.push(sub);
    };
    
    /**
     * Remove a directive subscriber.
     *
     * @param {Directive} sub
     */
    
    Dep.prototype.removeSub = function (sub) {
      this.subs.$remove(sub);
    };
    
    /**
     * Add self as a dependency to the target watcher.
     */
    
    Dep.prototype.depend = function () {
      Dep.target.addDep(this);
    };
    
    /**
     * Notify all subscribers of a new value.
     */
    
    Dep.prototype.notify = function () {
      // stablize the subscriber list first
      var subs = toArray(this.subs);
      for (var i = 0, l = subs.length; i < l; i++) {
        subs[i].update();
      }
    };
    
    var arrayKeys = Object.getOwnPropertyNames(arrayMethods);
    
    /**
     * Observer class that are attached to each observed
     * object. Once attached, the observer converts target
     * object's property keys into getter/setters that
     * collect dependencies and dispatches updates.
     *
     * @param {Array|Object} value
     * @constructor
     */
    
    function Observer(value) {
      this.value = value;
      this.dep = new Dep();
      def(value, '__ob__', this);
      if (isArray(value)) {
        var augment = hasProto ? protoAugment : copyAugment;
        augment(value, arrayMethods, arrayKeys);
        this.observeArray(value);
      } else {
        this.walk(value);
      }
    }
    
    // Instance methods
    
    /**
     * Walk through each property and convert them into
     * getter/setters. This method should only be called when
     * value type is Object.
     *
     * @param {Object} obj
     */
    
    Observer.prototype.walk = function (obj) {
      var keys = Object.keys(obj);
      for (var i = 0, l = keys.length; i < l; i++) {
        this.convert(keys[i], obj[keys[i]]);
      }
    };
    
    /**
     * Observe a list of Array items.
     *
     * @param {Array} items
     */
    
    Observer.prototype.observeArray = function (items) {
      for (var i = 0, l = items.length; i < l; i++) {
        observe(items[i]);
      }
    };
    
    /**
     * Convert a property into getter/setter so we can emit
     * the events when the property is accessed/changed.
     *
     * @param {String} key
     * @param {*} val
     */
    
    Observer.prototype.convert = function (key, val) {
      defineReactive(this.value, key, val);
    };
    
    /**
     * Add an owner vm, so that when $set/$delete mutations
     * happen we can notify owner vms to proxy the keys and
     * digest the watchers. This is only called when the object
     * is observed as an instance's root $data.
     *
     * @param {Vue} vm
     */
    
    Observer.prototype.addVm = function (vm) {
      (this.vms || (this.vms = [])).push(vm);
    };
    
    /**
     * Remove an owner vm. This is called when the object is
     * swapped out as an instance's $data object.
     *
     * @param {Vue} vm
     */
    
    Observer.prototype.removeVm = function (vm) {
      this.vms.$remove(vm);
    };
    
    // helpers
    
    /**
     * Augment an target Object or Array by intercepting
     * the prototype chain using __proto__
     *
     * @param {Object|Array} target
     * @param {Object} proto
     */
    
    function protoAugment(target, src) {
      target.__proto__ = src;
    }
    
    /**
     * Augment an target Object or Array by defining
     * hidden properties.
     *
     * @param {Object|Array} target
     * @param {Object} proto
     */
    
    function copyAugment(target, src, keys) {
      for (var i = 0, l = keys.length; i < l; i++) {
        var key = keys[i];
        def(target, key, src[key]);
      }
    }
    
    /**
     * Attempt to create an observer instance for a value,
     * returns the new observer if successfully observed,
     * or the existing observer if the value already has one.
     *
     * @param {*} value
     * @param {Vue} [vm]
     * @return {Observer|undefined}
     * @static
     */
    
    function observe(value, vm) {
      if (!value || typeof value !== 'object') {
        return;
      }
      var ob;
      if (hasOwn(value, '__ob__') && value.__ob__ instanceof Observer) {
        ob = value.__ob__;
      } else if ((isArray(value) || isPlainObject(value)) && Object.isExtensible(value) && !value._isVue) {
        ob = new Observer(value);
      }
      if (ob && vm) {
        ob.addVm(vm);
      }
      return ob;
    }
    
    /**
     * Define a reactive property on an Object.
     *
     * @param {Object} obj
     * @param {String} key
     * @param {*} val
     */
    
    function defineReactive(obj, key, val) {
      var dep = new Dep();
    
      // cater for pre-defined getter/setters
      var getter, setter;
      if (config.convertAllProperties) {
        var property = Object.getOwnPropertyDescriptor(obj, key);
        if (property && property.configurable === false) {
          return;
        }
        getter = property && property.get;
        setter = property && property.set;
      }
    
      var childOb = observe(val);
      Object.defineProperty(obj, key, {
        enumerable: true,
        configurable: true,
        get: function reactiveGetter() {
          var value = getter ? getter.call(obj) : val;
          if (Dep.target) {
            dep.depend();
            if (childOb) {
              childOb.dep.depend();
            }
            if (isArray(value)) {
              for (var e, i = 0, l = value.length; i < l; i++) {
                e = value[i];
                e && e.__ob__ && e.__ob__.dep.depend();
              }
            }
          }
          return value;
        },
        set: function reactiveSetter(newVal) {
          var value = getter ? getter.call(obj) : val;
          if (newVal === value) {
            return;
          }
          if (setter) {
            setter.call(obj, newVal);
          } else {
            val = newVal;
          }
          childOb = observe(newVal);
          dep.notify();
        }
      });
    }
    
    var util = Object.freeze({
    	defineReactive: defineReactive,
    	set: set,
    	del: del,
    	hasOwn: hasOwn,
    	isLiteral: isLiteral,
    	isReserved: isReserved,
    	_toString: _toString,
    	toNumber: toNumber,
    	toBoolean: toBoolean,
    	stripQuotes: stripQuotes,
    	camelize: camelize,
    	hyphenate: hyphenate,
    	classify: classify,
    	bind: bind$1,
    	toArray: toArray,
    	extend: extend,
    	isObject: isObject,
    	isPlainObject: isPlainObject,
    	def: def,
    	debounce: _debounce,
    	indexOf: indexOf,
    	cancellable: cancellable,
    	looseEqual: looseEqual,
    	isArray: isArray,
    	hasProto: hasProto,
    	inBrowser: inBrowser,
    	devtools: devtools,
    	isIE9: isIE9,
    	isAndroid: isAndroid,
    	get transitionProp () { return transitionProp; },
    	get transitionEndEvent () { return transitionEndEvent; },
    	get animationProp () { return animationProp; },
    	get animationEndEvent () { return animationEndEvent; },
    	nextTick: nextTick,
    	query: query,
    	inDoc: inDoc,
    	getAttr: getAttr,
    	getBindAttr: getBindAttr,
    	hasBindAttr: hasBindAttr,
    	before: before,
    	after: after,
    	remove: remove,
    	prepend: prepend,
    	replace: replace,
    	on: on$1,
    	off: off,
    	setClass: setClass,
    	addClass: addClass,
    	removeClass: removeClass,
    	extractContent: extractContent,
    	trimNode: trimNode,
    	isTemplate: isTemplate,
    	createAnchor: createAnchor,
    	findRef: findRef,
    	mapNodeRange: mapNodeRange,
    	removeNodeRange: removeNodeRange,
    	mergeOptions: mergeOptions,
    	resolveAsset: resolveAsset,
    	assertAsset: assertAsset,
    	checkComponentAttr: checkComponentAttr,
    	initProp: initProp,
    	assertProp: assertProp,
    	coerceProp: coerceProp,
    	commonTagRE: commonTagRE,
    	reservedTagRE: reservedTagRE,
    	get warn () { return warn; }
    });
    
    var uid = 0;
    
    function initMixin (Vue) {
    
      /**
       * The main init sequence. This is called for every
       * instance, including ones that are created from extended
       * constructors.
       *
       * @param {Object} options - this options object should be
       *                           the result of merging class
       *                           options and the options passed
       *                           in to the constructor.
       */
    
      Vue.prototype._init = function (options) {
    
        options = options || {};
    
        this.$el = null;
        this.$parent = options.parent;
        this.$root = this.$parent ? this.$parent.$root : this;
        this.$children = [];
        this.$refs = {}; // child vm references
        this.$els = {}; // element references
        this._watchers = []; // all watchers as an array
        this._directives = []; // all directives
    
        // a uid
        this._uid = uid++;
    
        // a flag to avoid this being observed
        this._isVue = true;
    
        // events bookkeeping
        this._events = {}; // registered callbacks
        this._eventsCount = {}; // for $broadcast optimization
    
        // fragment instance properties
        this._isFragment = false;
        this._fragment = // @type {DocumentFragment}
        this._fragmentStart = // @type {Text|Comment}
        this._fragmentEnd = null; // @type {Text|Comment}
    
        // lifecycle state
        this._isCompiled = this._isDestroyed = this._isReady = this._isAttached = this._isBeingDestroyed = this._vForRemoving = false;
        this._unlinkFn = null;
    
        // context:
        // if this is a transcluded component, context
        // will be the common parent vm of this instance
        // and its host.
        this._context = options._context || this.$parent;
    
        // scope:
        // if this is inside an inline v-for, the scope
        // will be the intermediate scope created for this
        // repeat fragment. this is used for linking props
        // and container directives.
        this._scope = options._scope;
    
        // fragment:
        // if this instance is compiled inside a Fragment, it
        // needs to reigster itself as a child of that fragment
        // for attach/detach to work properly.
        this._frag = options._frag;
        if (this._frag) {
          this._frag.children.push(this);
        }
    
        // push self into parent / transclusion host
        if (this.$parent) {
          this.$parent.$children.push(this);
        }
    
        // save raw constructor data before merge
        // so that we know which properties are provided at
        // instantiation.
        if (process.env.NODE_ENV !== 'production') {
          this._runtimeData = options.data;
        }
    
        // merge options.
        options = this.$options = mergeOptions(this.constructor.options, options, this);
    
        // set ref
        this._updateRef();
    
        // initialize data as empty object.
        // it will be filled up in _initScope().
        this._data = {};
    
        // call init hook
        this._callHook('init');
    
        // initialize data observation and scope inheritance.
        this._initState();
    
        // setup event system and option events.
        this._initEvents();
    
        // call created hook
        this._callHook('created');
    
        // if `el` option is passed, start compilation.
        if (options.el) {
          this.$mount(options.el);
        }
      };
    }
    
    var pathCache = new Cache(1000);
    
    // actions
    var APPEND = 0;
    var PUSH = 1;
    var INC_SUB_PATH_DEPTH = 2;
    var PUSH_SUB_PATH = 3;
    
    // states
    var BEFORE_PATH = 0;
    var IN_PATH = 1;
    var BEFORE_IDENT = 2;
    var IN_IDENT = 3;
    var IN_SUB_PATH = 4;
    var IN_SINGLE_QUOTE = 5;
    var IN_DOUBLE_QUOTE = 6;
    var AFTER_PATH = 7;
    var ERROR = 8;
    
    var pathStateMachine = [];
    
    pathStateMachine[BEFORE_PATH] = {
      'ws': [BEFORE_PATH],
      'ident': [IN_IDENT, APPEND],
      '[': [IN_SUB_PATH],
      'eof': [AFTER_PATH]
    };
    
    pathStateMachine[IN_PATH] = {
      'ws': [IN_PATH],
      '.': [BEFORE_IDENT],
      '[': [IN_SUB_PATH],
      'eof': [AFTER_PATH]
    };
    
    pathStateMachine[BEFORE_IDENT] = {
      'ws': [BEFORE_IDENT],
      'ident': [IN_IDENT, APPEND]
    };
    
    pathStateMachine[IN_IDENT] = {
      'ident': [IN_IDENT, APPEND],
      '0': [IN_IDENT, APPEND],
      'number': [IN_IDENT, APPEND],
      'ws': [IN_PATH, PUSH],
      '.': [BEFORE_IDENT, PUSH],
      '[': [IN_SUB_PATH, PUSH],
      'eof': [AFTER_PATH, PUSH]
    };
    
    pathStateMachine[IN_SUB_PATH] = {
      "'": [IN_SINGLE_QUOTE, APPEND],
      '"': [IN_DOUBLE_QUOTE, APPEND],
      '[': [IN_SUB_PATH, INC_SUB_PATH_DEPTH],
      ']': [IN_PATH, PUSH_SUB_PATH],
      'eof': ERROR,
      'else': [IN_SUB_PATH, APPEND]
    };
    
    pathStateMachine[IN_SINGLE_QUOTE] = {
      "'": [IN_SUB_PATH, APPEND],
      'eof': ERROR,
      'else': [IN_SINGLE_QUOTE, APPEND]
    };
    
    pathStateMachine[IN_DOUBLE_QUOTE] = {
      '"': [IN_SUB_PATH, APPEND],
      'eof': ERROR,
      'else': [IN_DOUBLE_QUOTE, APPEND]
    };
    
    /**
     * Determine the type of a character in a keypath.
     *
     * @param {Char} ch
     * @return {String} type
     */
    
    function getPathCharType(ch) {
      if (ch === undefined) {
        return 'eof';
      }
    
      var code = ch.charCodeAt(0);
    
      switch (code) {
        case 0x5B: // [
        case 0x5D: // ]
        case 0x2E: // .
        case 0x22: // "
        case 0x27: // '
        case 0x30:
          // 0
          return ch;
    
        case 0x5F: // _
        case 0x24:
          // $
          return 'ident';
    
        case 0x20: // Space
        case 0x09: // Tab
        case 0x0A: // Newline
        case 0x0D: // Return
        case 0xA0: // No-break space
        case 0xFEFF: // Byte Order Mark
        case 0x2028: // Line Separator
        case 0x2029:
          // Paragraph Separator
          return 'ws';
      }
    
      // a-z, A-Z
      if (code >= 0x61 && code <= 0x7A || code >= 0x41 && code <= 0x5A) {
        return 'ident';
      }
    
      // 1-9
      if (code >= 0x31 && code <= 0x39) {
        return 'number';
      }
    
      return 'else';
    }
    
    /**
     * Format a subPath, return its plain form if it is
     * a literal string or number. Otherwise prepend the
     * dynamic indicator (*).
     *
     * @param {String} path
     * @return {String}
     */
    
    function formatSubPath(path) {
      var trimmed = path.trim();
      // invalid leading 0
      if (path.charAt(0) === '0' && isNaN(path)) {
        return false;
      }
      return isLiteral(trimmed) ? stripQuotes(trimmed) : '*' + trimmed;
    }
    
    /**
     * Parse a string path into an array of segments
     *
     * @param {String} path
     * @return {Array|undefined}
     */
    
    function parse(path) {
      var keys = [];
      var index = -1;
      var mode = BEFORE_PATH;
      var subPathDepth = 0;
      var c, newChar, key, type, transition, action, typeMap;
    
      var actions = [];
    
      actions[PUSH] = function () {
        if (key !== undefined) {
          keys.push(key);
          key = undefined;
        }
      };
    
      actions[APPEND] = function () {
        if (key === undefined) {
          key = newChar;
        } else {
          key += newChar;
        }
      };
    
      actions[INC_SUB_PATH_DEPTH] = function () {
        actions[APPEND]();
        subPathDepth++;
      };
    
      actions[PUSH_SUB_PATH] = function () {
        if (subPathDepth > 0) {
          subPathDepth--;
          mode = IN_SUB_PATH;
          actions[APPEND]();
        } else {
          subPathDepth = 0;
          key = formatSubPath(key);
          if (key === false) {
            return false;
          } else {
            actions[PUSH]();
          }
        }
      };
    
      function maybeUnescapeQuote() {
        var nextChar = path[index + 1];
        if (mode === IN_SINGLE_QUOTE && nextChar === "'" || mode === IN_DOUBLE_QUOTE && nextChar === '"') {
          index++;
          newChar = '\\' + nextChar;
          actions[APPEND]();
          return true;
        }
      }
    
      while (mode != null) {
        index++;
        c = path[index];
    
        if (c === '\\' && maybeUnescapeQuote()) {
          continue;
        }
    
        type = getPathCharType(c);
        typeMap = pathStateMachine[mode];
        transition = typeMap[type] || typeMap['else'] || ERROR;
    
        if (transition === ERROR) {
          return; // parse error
        }
    
        mode = transition[0];
        action = actions[transition[1]];
        if (action) {
          newChar = transition[2];
          newChar = newChar === undefined ? c : newChar;
          if (action() === false) {
            return;
          }
        }
    
        if (mode === AFTER_PATH) {
          keys.raw = path;
          return keys;
        }
      }
    }
    
    /**
     * External parse that check for a cache hit first
     *
     * @param {String} path
     * @return {Array|undefined}
     */
    
    function parsePath(path) {
      var hit = pathCache.get(path);
      if (!hit) {
        hit = parse(path);
        if (hit) {
          pathCache.put(path, hit);
        }
      }
      return hit;
    }
    
    /**
     * Get from an object from a path string
     *
     * @param {Object} obj
     * @param {String} path
     */
    
    function getPath(obj, path) {
      return parseExpression(path).get(obj);
    }
    
    /**
     * Warn against setting non-existent root path on a vm.
     */
    
    var warnNonExistent;
    if (process.env.NODE_ENV !== 'production') {
      warnNonExistent = function (path) {
        warn('You are setting a non-existent path "' + path.raw + '" ' + 'on a vm instance. Consider pre-initializing the property ' + 'with the "data" option for more reliable reactivity ' + 'and better performance.');
      };
    }
    
    /**
     * Set on an object from a path
     *
     * @param {Object} obj
     * @param {String | Array} path
     * @param {*} val
     */
    
    function setPath(obj, path, val) {
      var original = obj;
      if (typeof path === 'string') {
        path = parse(path);
      }
      if (!path || !isObject(obj)) {
        return false;
      }
      var last, key;
      for (var i = 0, l = path.length; i < l; i++) {
        last = obj;
        key = path[i];
        if (key.charAt(0) === '*') {
          key = parseExpression(key.slice(1)).get.call(original, original);
        }
        if (i < l - 1) {
          obj = obj[key];
          if (!isObject(obj)) {
            obj = {};
            if (process.env.NODE_ENV !== 'production' && last._isVue) {
              warnNonExistent(path);
            }
            set(last, key, obj);
          }
        } else {
          if (isArray(obj)) {
            obj.$set(key, val);
          } else if (key in obj) {
            obj[key] = val;
          } else {
            if (process.env.NODE_ENV !== 'production' && obj._isVue) {
              warnNonExistent(path);
            }
            set(obj, key, val);
          }
        }
      }
      return true;
    }
    
    var path = Object.freeze({
      parsePath: parsePath,
      getPath: getPath,
      setPath: setPath
    });
    
    var expressionCache = new Cache(1000);
    
    var allowedKeywords = 'Math,Date,this,true,false,null,undefined,Infinity,NaN,' + 'isNaN,isFinite,decodeURI,decodeURIComponent,encodeURI,' + 'encodeURIComponent,parseInt,parseFloat';
    var allowedKeywordsRE = new RegExp('^(' + allowedKeywords.replace(/,/g, '\\b|') + '\\b)');
    
    // keywords that don't make sense inside expressions
    var improperKeywords = 'break,case,class,catch,const,continue,debugger,default,' + 'delete,do,else,export,extends,finally,for,function,if,' + 'import,in,instanceof,let,return,super,switch,throw,try,' + 'var,while,with,yield,enum,await,implements,package,' + 'proctected,static,interface,private,public';
    var improperKeywordsRE = new RegExp('^(' + improperKeywords.replace(/,/g, '\\b|') + '\\b)');
    
    var wsRE = /\s/g;
    var newlineRE = /\n/g;
    var saveRE = /[\{,]\s*[\w\$_]+\s*:|('(?:[^'\\]|\\.)*'|"(?:[^"\\]|\\.)*")|new |typeof |void /g;
    var restoreRE = /"(\d+)"/g;
    var pathTestRE = /^[A-Za-z_$][\w$]*(?:\.[A-Za-z_$][\w$]*|\['.*?'\]|\[".*?"\]|\[\d+\]|\[[A-Za-z_$][\w$]*\])*$/;
    var identRE = /[^\w$\.](?:[A-Za-z_$][\w$]*)/g;
    var booleanLiteralRE = /^(?:true|false)$/;
    
    /**
     * Save / Rewrite / Restore
     *
     * When rewriting paths found in an expression, it is
     * possible for the same letter sequences to be found in
     * strings and Object literal property keys. Therefore we
     * remove and store these parts in a temporary array, and
     * restore them after the path rewrite.
     */
    
    var saved = [];
    
    /**
     * Save replacer
     *
     * The save regex can match two possible cases:
     * 1. An opening object literal
     * 2. A string
     * If matched as a plain string, we need to escape its
     * newlines, since the string needs to be preserved when
     * generating the function body.
     *
     * @param {String} str
     * @param {String} isString - str if matched as a string
     * @return {String} - placeholder with index
     */
    
    function save(str, isString) {
      var i = saved.length;
      saved[i] = isString ? str.replace(newlineRE, '\\n') : str;
      return '"' + i + '"';
    }
    
    /**
     * Path rewrite replacer
     *
     * @param {String} raw
     * @return {String}
     */
    
    function rewrite(raw) {
      var c = raw.charAt(0);
      var path = raw.slice(1);
      if (allowedKeywordsRE.test(path)) {
        return raw;
      } else {
        path = path.indexOf('"') > -1 ? path.replace(restoreRE, restore) : path;
        return c + 'scope.' + path;
      }
    }
    
    /**
     * Restore replacer
     *
     * @param {String} str
     * @param {String} i - matched save index
     * @return {String}
     */
    
    function restore(str, i) {
      return saved[i];
    }
    
    /**
     * Rewrite an expression, prefixing all path accessors with
     * `scope.` and generate getter/setter functions.
     *
     * @param {String} exp
     * @return {Function}
     */
    
    function compileGetter(exp) {
      if (improperKeywordsRE.test(exp)) {
        process.env.NODE_ENV !== 'production' && warn('Avoid using reserved keywords in expression: ' + exp);
      }
      // reset state
      saved.length = 0;
      // save strings and object literal keys
      var body = exp.replace(saveRE, save).replace(wsRE, '');
      // rewrite all paths
      // pad 1 space here becaue the regex matches 1 extra char
      body = (' ' + body).replace(identRE, rewrite).replace(restoreRE, restore);
      return makeGetterFn(body);
    }
    
    /**
     * Build a getter function. Requires eval.
     *
     * We isolate the try/catch so it doesn't affect the
     * optimization of the parse function when it is not called.
     *
     * @param {String} body
     * @return {Function|undefined}
     */
    
    function makeGetterFn(body) {
      try {
        return new Function('scope', 'return ' + body + ';');
      } catch (e) {
        process.env.NODE_ENV !== 'production' && warn('Invalid expression. ' + 'Generated function body: ' + body);
      }
    }
    
    /**
     * Compile a setter function for the expression.
     *
     * @param {String} exp
     * @return {Function|undefined}
     */
    
    function compileSetter(exp) {
      var path = parsePath(exp);
      if (path) {
        return function (scope, val) {
          setPath(scope, path, val);
        };
      } else {
        process.env.NODE_ENV !== 'production' && warn('Invalid setter expression: ' + exp);
      }
    }
    
    /**
     * Parse an expression into re-written getter/setters.
     *
     * @param {String} exp
     * @param {Boolean} needSet
     * @return {Function}
     */
    
    function parseExpression(exp, needSet) {
      exp = exp.trim();
      // try cache
      var hit = expressionCache.get(exp);
      if (hit) {
        if (needSet && !hit.set) {
          hit.set = compileSetter(hit.exp);
        }
        return hit;
      }
      var res = { exp: exp };
      res.get = isSimplePath(exp) && exp.indexOf('[') < 0
      // optimized super simple getter
      ? makeGetterFn('scope.' + exp)
      // dynamic getter
      : compileGetter(exp);
      if (needSet) {
        res.set = compileSetter(exp);
      }
      expressionCache.put(exp, res);
      return res;
    }
    
    /**
     * Check if an expression is a simple path.
     *
     * @param {String} exp
     * @return {Boolean}
     */
    
    function isSimplePath(exp) {
      return pathTestRE.test(exp) &&
      // don't treat true/false as paths
      !booleanLiteralRE.test(exp) &&
      // Math constants e.g. Math.PI, Math.E etc.
      exp.slice(0, 5) !== 'Math.';
    }
    
    var expression = Object.freeze({
      parseExpression: parseExpression,
      isSimplePath: isSimplePath
    });
    
    // we have two separate queues: one for directive updates
    // and one for user watcher registered via $watch().
    // we want to guarantee directive updates to be called
    // before user watchers so that when user watchers are
    // triggered, the DOM would have already been in updated
    // state.
    var queue = [];
    var userQueue = [];
    var has = {};
    var circular = {};
    var waiting = false;
    var internalQueueDepleted = false;
    
    /**
     * Reset the batcher's state.
     */
    
    function resetBatcherState() {
      queue = [];
      userQueue = [];
      has = {};
      circular = {};
      waiting = internalQueueDepleted = false;
    }
    
    /**
     * Flush both queues and run the watchers.
     */
    
    function flushBatcherQueue() {
      runBatcherQueue(queue);
      internalQueueDepleted = true;
      runBatcherQueue(userQueue);
      // dev tool hook
      /* istanbul ignore if */
      if (devtools) {
        devtools.emit('flush');
      }
      resetBatcherState();
    }
    
    /**
     * Run the watchers in a single queue.
     *
     * @param {Array} queue
     */
    
    function runBatcherQueue(queue) {
      // do not cache length because more watchers might be pushed
      // as we run existing watchers
      for (var i = 0; i < queue.length; i++) {
        var watcher = queue[i];
        var id = watcher.id;
        has[id] = null;
        watcher.run();
        // in dev build, check and stop circular updates.
        if (process.env.NODE_ENV !== 'production' && has[id] != null) {
          circular[id] = (circular[id] || 0) + 1;
          if (circular[id] > config._maxUpdateCount) {
            queue.splice(has[id], 1);
            warn('You may have an infinite update loop for watcher ' + 'with expression: ' + watcher.expression);
          }
        }
      }
    }
    
    /**
     * Push a watcher into the watcher queue.
     * Jobs with duplicate IDs will be skipped unless it's
     * pushed when the queue is being flushed.
     *
     * @param {Watcher} watcher
     *   properties:
     *   - {Number} id
     *   - {Function} run
     */
    
    function pushWatcher(watcher) {
      var id = watcher.id;
      if (has[id] == null) {
        // if an internal watcher is pushed, but the internal
        // queue is already depleted, we run it immediately.
        if (internalQueueDepleted && !watcher.user) {
          watcher.run();
          return;
        }
        // push watcher into appropriate queue
        var q = watcher.user ? userQueue : queue;
        has[id] = q.length;
        q.push(watcher);
        // queue the flush
        if (!waiting) {
          waiting = true;
          nextTick(flushBatcherQueue);
        }
      }
    }
    
    var uid$2 = 0;
    
    /**
     * A watcher parses an expression, collects dependencies,
     * and fires callback when the expression value changes.
     * This is used for both the $watch() api and directives.
     *
     * @param {Vue} vm
     * @param {String} expression
     * @param {Function} cb
     * @param {Object} options
     *                 - {Array} filters
     *                 - {Boolean} twoWay
     *                 - {Boolean} deep
     *                 - {Boolean} user
     *                 - {Boolean} sync
     *                 - {Boolean} lazy
     *                 - {Function} [preProcess]
     *                 - {Function} [postProcess]
     * @constructor
     */
    function Watcher(vm, expOrFn, cb, options) {
      // mix in options
      if (options) {
        extend(this, options);
      }
      var isFn = typeof expOrFn === 'function';
      this.vm = vm;
      vm._watchers.push(this);
      this.expression = isFn ? expOrFn.toString() : expOrFn;
      this.cb = cb;
      this.id = ++uid$2; // uid for batching
      this.active = true;
      this.dirty = this.lazy; // for lazy watchers
      this.deps = Object.create(null);
      this.newDeps = null;
      this.prevError = null; // for async error stacks
      // parse expression for getter/setter
      if (isFn) {
        this.getter = expOrFn;
        this.setter = undefined;
      } else {
        var res = parseExpression(expOrFn, this.twoWay);
        this.getter = res.get;
        this.setter = res.set;
      }
      this.value = this.lazy ? undefined : this.get();
      // state for avoiding false triggers for deep and Array
      // watchers during vm._digest()
      this.queued = this.shallow = false;
    }
    
    /**
     * Add a dependency to this directive.
     *
     * @param {Dep} dep
     */
    
    Watcher.prototype.addDep = function (dep) {
      var id = dep.id;
      if (!this.newDeps[id]) {
        this.newDeps[id] = dep;
        if (!this.deps[id]) {
          this.deps[id] = dep;
          dep.addSub(this);
        }
      }
    };
    
    /**
     * Evaluate the getter, and re-collect dependencies.
     */
    
    Watcher.prototype.get = function () {
      this.beforeGet();
      var scope = this.scope || this.vm;
      var value;
      try {
        value = this.getter.call(scope, scope);
      } catch (e) {
        if (process.env.NODE_ENV !== 'production' && config.warnExpressionErrors) {
          warn('Error when evaluating expression "' + this.expression + '". ' + (config.debug ? '' : 'Turn on debug mode to see stack trace.'), e);
        }
      }
      // "touch" every property so they are all tracked as
      // dependencies for deep watching
      if (this.deep) {
        traverse(value);
      }
      if (this.preProcess) {
        value = this.preProcess(value);
      }
      if (this.filters) {
        value = scope._applyFilters(value, null, this.filters, false);
      }
      if (this.postProcess) {
        value = this.postProcess(value);
      }
      this.afterGet();
      return value;
    };
    
    /**
     * Set the corresponding value with the setter.
     *
     * @param {*} value
     */
    
    Watcher.prototype.set = function (value) {
      var scope = this.scope || this.vm;
      if (this.filters) {
        value = scope._applyFilters(value, this.value, this.filters, true);
      }
      try {
        this.setter.call(scope, scope, value);
      } catch (e) {
        if (process.env.NODE_ENV !== 'production' && config.warnExpressionErrors) {
          warn('Error when evaluating setter "' + this.expression + '"', e);
        }
      }
      // two-way sync for v-for alias
      var forContext = scope.$forContext;
      if (forContext && forContext.alias === this.expression) {
        if (forContext.filters) {
          process.env.NODE_ENV !== 'production' && warn('It seems you are using two-way binding on ' + 'a v-for alias (' + this.expression + '), and the ' + 'v-for has filters. This will not work properly. ' + 'Either remove the filters or use an array of ' + 'objects and bind to object properties instead.');
          return;
        }
        forContext._withLock(function () {
          if (scope.$key) {
            // original is an object
            forContext.rawValue[scope.$key] = value;
          } else {
            forContext.rawValue.$set(scope.$index, value);
          }
        });
      }
    };
    
    /**
     * Prepare for dependency collection.
     */
    
    Watcher.prototype.beforeGet = function () {
      Dep.target = this;
      this.newDeps = Object.create(null);
    };
    
    /**
     * Clean up for dependency collection.
     */
    
    Watcher.prototype.afterGet = function () {
      Dep.target = null;
      var ids = Object.keys(this.deps);
      var i = ids.length;
      while (i--) {
        var id = ids[i];
        if (!this.newDeps[id]) {
          this.deps[id].removeSub(this);
        }
      }
      this.deps = this.newDeps;
    };
    
    /**
     * Subscriber interface.
     * Will be called when a dependency changes.
     *
     * @param {Boolean} shallow
     */
    
    Watcher.prototype.update = function (shallow) {
      if (this.lazy) {
        this.dirty = true;
      } else if (this.sync || !config.async) {
        this.run();
      } else {
        // if queued, only overwrite shallow with non-shallow,
        // but not the other way around.
        this.shallow = this.queued ? shallow ? this.shallow : false : !!shallow;
        this.queued = true;
        // record before-push error stack in debug mode
        /* istanbul ignore if */
        if (process.env.NODE_ENV !== 'production' && config.debug) {
          this.prevError = new Error('[vue] async stack trace');
        }
        pushWatcher(this);
      }
    };
    
    /**
     * Batcher job interface.
     * Will be called by the batcher.
     */
    
    Watcher.prototype.run = function () {
      if (this.active) {
        var value = this.get();
        if (value !== this.value ||
        // Deep watchers and watchers on Object/Arrays should fire even
        // when the value is the same, because the value may
        // have mutated; but only do so if this is a
        // non-shallow update (caused by a vm digest).
        (isObject(value) || this.deep) && !this.shallow) {
          // set new value
          var oldValue = this.value;
          this.value = value;
          // in debug + async mode, when a watcher callbacks
          // throws, we also throw the saved before-push error
          // so the full cross-tick stack trace is available.
          var prevError = this.prevError;
          /* istanbul ignore if */
          if (process.env.NODE_ENV !== 'production' && config.debug && prevError) {
            this.prevError = null;
            try {
              this.cb.call(this.vm, value, oldValue);
            } catch (e) {
              nextTick(function () {
                throw prevError;
              }, 0);
              throw e;
            }
          } else {
            this.cb.call(this.vm, value, oldValue);
          }
        }
        this.queued = this.shallow = false;
      }
    };
    
    /**
     * Evaluate the value of the watcher.
     * This only gets called for lazy watchers.
     */
    
    Watcher.prototype.evaluate = function () {
      // avoid overwriting another watcher that is being
      // collected.
      var current = Dep.target;
      this.value = this.get();
      this.dirty = false;
      Dep.target = current;
    };
    
    /**
     * Depend on all deps collected by this watcher.
     */
    
    Watcher.prototype.depend = function () {
      var depIds = Object.keys(this.deps);
      var i = depIds.length;
      while (i--) {
        this.deps[depIds[i]].depend();
      }
    };
    
    /**
     * Remove self from all dependencies' subcriber list.
     */
    
    Watcher.prototype.teardown = function () {
      if (this.active) {
        // remove self from vm's watcher list
        // this is a somewhat expensive operation so we skip it
        // if the vm is being destroyed or is performing a v-for
        // re-render (the watcher list is then filtered by v-for).
        if (!this.vm._isBeingDestroyed && !this.vm._vForRemoving) {
          this.vm._watchers.$remove(this);
        }
        var depIds = Object.keys(this.deps);
        var i = depIds.length;
        while (i--) {
          this.deps[depIds[i]].removeSub(this);
        }
        this.active = false;
        this.vm = this.cb = this.value = null;
      }
    };
    
    /**
     * Recrusively traverse an object to evoke all converted
     * getters, so that every nested property inside the object
     * is collected as a "deep" dependency.
     *
     * @param {*} val
     */
    
    function traverse(val) {
      var i, keys;
      if (isArray(val)) {
        i = val.length;
        while (i--) traverse(val[i]);
      } else if (isObject(val)) {
        keys = Object.keys(val);
        i = keys.length;
        while (i--) traverse(val[keys[i]]);
      }
    }
    
    var cloak = {
      bind: function bind() {
        var el = this.el;
        this.vm.$once('pre-hook:compiled', function () {
          el.removeAttribute('v-cloak');
        });
      }
    };
    
    var ref = {
      bind: function bind() {
        process.env.NODE_ENV !== 'production' && warn('v-ref:' + this.arg + ' must be used on a child ' + 'component. Found on <' + this.el.tagName.toLowerCase() + '>.');
      }
    };
    
    var ON = 700;
    var MODEL = 800;
    var BIND = 850;
    var TRANSITION = 1100;
    var EL = 1500;
    var COMPONENT = 1500;
    var PARTIAL = 1750;
    var FOR = 2000;
    var IF = 2000;
    var SLOT = 2100;
    
    var el = {
    
      priority: EL,
    
      bind: function bind() {
        /* istanbul ignore if */
        if (!this.arg) {
          return;
        }
        var id = this.id = camelize(this.arg);
        var refs = (this._scope || this.vm).$els;
        if (hasOwn(refs, id)) {
          refs[id] = this.el;
        } else {
          defineReactive(refs, id, this.el);
        }
      },
    
      unbind: function unbind() {
        var refs = (this._scope || this.vm).$els;
        if (refs[this.id] === this.el) {
          refs[this.id] = null;
        }
      }
    };
    
    var prefixes = ['-webkit-', '-moz-', '-ms-'];
    var camelPrefixes = ['Webkit', 'Moz', 'ms'];
    var importantRE = /!important;?$/;
    var propCache = Object.create(null);
    
    var testEl = null;
    
    var style = {
    
      deep: true,
    
      update: function update(value) {
        if (typeof value === 'string') {
          this.el.style.cssText = value;
        } else if (isArray(value)) {
          this.handleObject(value.reduce(extend, {}));
        } else {
          this.handleObject(value || {});
        }
      },
    
      handleObject: function handleObject(value) {
        // cache object styles so that only changed props
        // are actually updated.
        var cache = this.cache || (this.cache = {});
        var name, val;
        for (name in cache) {
          if (!(name in value)) {
            this.handleSingle(name, null);
            delete cache[name];
          }
        }
        for (name in value) {
          val = value[name];
          if (val !== cache[name]) {
            cache[name] = val;
            this.handleSingle(name, val);
          }
        }
      },
    
      handleSingle: function handleSingle(prop, value) {
        prop = normalize(prop);
        if (!prop) return; // unsupported prop
        // cast possible numbers/booleans into strings
        if (value != null) value += '';
        if (value) {
          var isImportant = importantRE.test(value) ? 'important' : '';
          if (isImportant) {
            value = value.replace(importantRE, '').trim();
          }
          this.el.style.setProperty(prop, value, isImportant);
        } else {
          this.el.style.removeProperty(prop);
        }
      }
    
    };
    
    /**
     * Normalize a CSS property name.
     * - cache result
     * - auto prefix
     * - camelCase -> dash-case
     *
     * @param {String} prop
     * @return {String}
     */
    
    function normalize(prop) {
      if (propCache[prop]) {
        return propCache[prop];
      }
      var res = prefix(prop);
      propCache[prop] = propCache[res] = res;
      return res;
    }
    
    /**
     * Auto detect the appropriate prefix for a CSS property.
     * https://gist.github.com/paulirish/523692
     *
     * @param {String} prop
     * @return {String}
     */
    
    function prefix(prop) {
      prop = hyphenate(prop);
      var camel = camelize(prop);
      var upper = camel.charAt(0).toUpperCase() + camel.slice(1);
      if (!testEl) {
        testEl = document.createElement('div');
      }
      var i = prefixes.length;
      var prefixed;
      while (i--) {
        prefixed = camelPrefixes[i] + upper;
        if (prefixed in testEl.style) {
          return prefixes[i] + prop;
        }
      }
      if (camel in testEl.style) {
        return prop;
      }
    }
    
    // xlink
    var xlinkNS = 'http://www.w3.org/1999/xlink';
    var xlinkRE = /^xlink:/;
    
    // check for attributes that prohibit interpolations
    var disallowedInterpAttrRE = /^v-|^:|^@|^(?:is|transition|transition-mode|debounce|track-by|stagger|enter-stagger|leave-stagger)$/;
    // these attributes should also set their corresponding properties
    // because they only affect the initial state of the element
    var attrWithPropsRE = /^(?:value|checked|selected|muted)$/;
    
    // these attributes should set a hidden property for
    // binding v-model to object values
    var modelProps = {
      value: '_value',
      'true-value': '_trueValue',
      'false-value': '_falseValue'
    };
    
    var bind = {
    
      priority: BIND,
    
      bind: function bind() {
        var attr = this.arg;
        var tag = this.el.tagName;
        // should be deep watch on object mode
        if (!attr) {
          this.deep = true;
        }
        // handle interpolation bindings
        var descriptor = this.descriptor;
        var tokens = descriptor.interp;
        if (tokens) {
          // handle interpolations with one-time tokens
          if (descriptor.hasOneTime) {
            this.expression = tokensToExp(tokens, this._scope || this.vm);
          }
    
          // only allow binding on native attributes
          if (disallowedInterpAttrRE.test(attr) || attr === 'name' && (tag === 'PARTIAL' || tag === 'SLOT')) {
            process.env.NODE_ENV !== 'production' && warn(attr + '="' + descriptor.raw + '": ' + 'attribute interpolation is not allowed in Vue.js ' + 'directives and special attributes.');
            this.el.removeAttribute(attr);
            this.invalid = true;
          }
    
          /* istanbul ignore if */
          if (process.env.NODE_ENV !== 'production') {
            var raw = attr + '="' + descriptor.raw + '": ';
            // warn src
            if (attr === 'src') {
              warn(raw + 'interpolation in "src" attribute will cause ' + 'a 404 request. Use v-bind:src instead.');
            }
    
            // warn style
            if (attr === 'style') {
              warn(raw + 'interpolation in "style" attribute will cause ' + 'the attribute to be discarded in Internet Explorer. ' + 'Use v-bind:style instead.');
            }
          }
        }
      },
    
      update: function update(value) {
        if (this.invalid) {
          return;
        }
        var attr = this.arg;
        if (this.arg) {
          this.handleSingle(attr, value);
        } else {
          this.handleObject(value || {});
        }
      },
    
      // share object handler with v-bind:class
      handleObject: style.handleObject,
    
      handleSingle: function handleSingle(attr, value) {
        var el = this.el;
        var interp = this.descriptor.interp;
        if (this.modifiers.camel) {
          attr = camelize(attr);
        }
        if (!interp && attrWithPropsRE.test(attr) && attr in el) {
          el[attr] = attr === 'value' ? value == null // IE9 will set input.value to "null" for null...
          ? '' : value : value;
        }
        // set model props
        var modelProp = modelProps[attr];
        if (!interp && modelProp) {
          el[modelProp] = value;
          // update v-model if present
          var model = el.__v_model;
          if (model) {
            model.listener();
          }
        }
        // do not set value attribute for textarea
        if (attr === 'value' && el.tagName === 'TEXTAREA') {
          el.removeAttribute(attr);
          return;
        }
        // update attribute
        if (value != null && value !== false) {
          if (attr === 'class') {
            // handle edge case #1960:
            // class interpolation should not overwrite Vue transition class
            if (el.__v_trans) {
              value += ' ' + el.__v_trans.id + '-transition';
            }
            setClass(el, value);
          } else if (xlinkRE.test(attr)) {
            el.setAttributeNS(xlinkNS, attr, value === true ? '' : value);
          } else {
            el.setAttribute(attr, value === true ? '' : value);
          }
        } else {
          el.removeAttribute(attr);
        }
      }
    };
    
    // keyCode aliases
    var keyCodes = {
      esc: 27,
      tab: 9,
      enter: 13,
      space: 32,
      'delete': [8, 46],
      up: 38,
      left: 37,
      right: 39,
      down: 40
    };
    
    function keyFilter(handler, keys) {
      var codes = keys.map(function (key) {
        var charCode = key.charCodeAt(0);
        if (charCode > 47 && charCode < 58) {
          return parseInt(key, 10);
        }
        if (key.length === 1) {
          charCode = key.toUpperCase().charCodeAt(0);
          if (charCode > 64 && charCode < 91) {
            return charCode;
          }
        }
        return keyCodes[key];
      });
      codes = [].concat.apply([], codes);
      return function keyHandler(e) {
        if (codes.indexOf(e.keyCode) > -1) {
          return handler.call(this, e);
        }
      };
    }
    
    function stopFilter(handler) {
      return function stopHandler(e) {
        e.stopPropagation();
        return handler.call(this, e);
      };
    }
    
    function preventFilter(handler) {
      return function preventHandler(e) {
        e.preventDefault();
        return handler.call(this, e);
      };
    }
    
    function selfFilter(handler) {
      return function selfHandler(e) {
        if (e.target === e.currentTarget) {
          return handler.call(this, e);
        }
      };
    }
    
    var on = {
    
      acceptStatement: true,
      priority: ON,
    
      bind: function bind() {
        // deal with iframes
        if (this.el.tagName === 'IFRAME' && this.arg !== 'load') {
          var self = this;
          this.iframeBind = function () {
            on$1(self.el.contentWindow, self.arg, self.handler, self.modifiers.capture);
          };
          this.on('load', this.iframeBind);
        }
      },
    
      update: function update(handler) {
        // stub a noop for v-on with no value,
        // e.g. @mousedown.prevent
        if (!this.descriptor.raw) {
          handler = function () {};
        }
    
        if (typeof handler !== 'function') {
          process.env.NODE_ENV !== 'production' && warn('v-on:' + this.arg + '="' + this.expression + '" expects a function value, ' + 'got ' + handler);
          return;
        }
    
        // apply modifiers
        if (this.modifiers.stop) {
          handler = stopFilter(handler);
        }
        if (this.modifiers.prevent) {
          handler = preventFilter(handler);
        }
        if (this.modifiers.self) {
          handler = selfFilter(handler);
        }
        // key filter
        var keys = Object.keys(this.modifiers).filter(function (key) {
          return key !== 'stop' && key !== 'prevent';
        });
        if (keys.length) {
          handler = keyFilter(handler, keys);
        }
    
        this.reset();
        this.handler = handler;
    
        if (this.iframeBind) {
          this.iframeBind();
        } else {
          on$1(this.el, this.arg, this.handler, this.modifiers.capture);
        }
      },
    
      reset: function reset() {
        var el = this.iframeBind ? this.el.contentWindow : this.el;
        if (this.handler) {
          off(el, this.arg, this.handler);
        }
      },
    
      unbind: function unbind() {
        this.reset();
      }
    };
    
    var checkbox = {
    
      bind: function bind() {
        var self = this;
        var el = this.el;
    
        this.getValue = function () {
          return el.hasOwnProperty('_value') ? el._value : self.params.number ? toNumber(el.value) : el.value;
        };
    
        function getBooleanValue() {
          var val = el.checked;
          if (val && el.hasOwnProperty('_trueValue')) {
            return el._trueValue;
          }
          if (!val && el.hasOwnProperty('_falseValue')) {
            return el._falseValue;
          }
          return val;
        }
    
        this.listener = function () {
          var model = self._watcher.value;
          if (isArray(model)) {
            var val = self.getValue();
            if (el.checked) {
              if (indexOf(model, val) < 0) {
                model.push(val);
              }
            } else {
              model.$remove(val);
            }
          } else {
            self.set(getBooleanValue());
          }
        };
    
        this.on('change', this.listener);
        if (el.hasAttribute('checked')) {
          this.afterBind = this.listener;
        }
      },
    
      update: function update(value) {
        var el = this.el;
        if (isArray(value)) {
          el.checked = indexOf(value, this.getValue()) > -1;
        } else {
          if (el.hasOwnProperty('_trueValue')) {
            el.checked = looseEqual(value, el._trueValue);
          } else {
            el.checked = !!value;
          }
        }
      }
    };
    
    var select = {
    
      bind: function bind() {
        var self = this;
        var el = this.el;
    
        // method to force update DOM using latest value.
        this.forceUpdate = function () {
          if (self._watcher) {
            self.update(self._watcher.get());
          }
        };
    
        // check if this is a multiple select
        var multiple = this.multiple = el.hasAttribute('multiple');
    
        // attach listener
        this.listener = function () {
          var value = getValue(el, multiple);
          value = self.params.number ? isArray(value) ? value.map(toNumber) : toNumber(value) : value;
          self.set(value);
        };
        this.on('change', this.listener);
    
        // if has initial value, set afterBind
        var initValue = getValue(el, multiple, true);
        if (multiple && initValue.length || !multiple && initValue !== null) {
          this.afterBind = this.listener;
        }
    
        // All major browsers except Firefox resets
        // selectedIndex with value -1 to 0 when the element
        // is appended to a new parent, therefore we have to
        // force a DOM update whenever that happens...
        this.vm.$on('hook:attached', this.forceUpdate);
      },
    
      update: function update(value) {
        var el = this.el;
        el.selectedIndex = -1;
        var multi = this.multiple && isArray(value);
        var options = el.options;
        var i = options.length;
        var op, val;
        while (i--) {
          op = options[i];
          val = op.hasOwnProperty('_value') ? op._value : op.value;
          /* eslint-disable eqeqeq */
          op.selected = multi ? indexOf$1(value, val) > -1 : looseEqual(value, val);
          /* eslint-enable eqeqeq */
        }
      },
    
      unbind: function unbind() {
        /* istanbul ignore next */
        this.vm.$off('hook:attached', this.forceUpdate);
      }
    };
    
    /**
     * Get select value
     *
     * @param {SelectElement} el
     * @param {Boolean} multi
     * @param {Boolean} init
     * @return {Array|*}
     */
    
    function getValue(el, multi, init) {
      var res = multi ? [] : null;
      var op, val, selected;
      for (var i = 0, l = el.options.length; i < l; i++) {
        op = el.options[i];
        selected = init ? op.hasAttribute('selected') : op.selected;
        if (selected) {
          val = op.hasOwnProperty('_value') ? op._value : op.value;
          if (multi) {
            res.push(val);
          } else {
            return val;
          }
        }
      }
      return res;
    }
    
    /**
     * Native Array.indexOf uses strict equal, but in this
     * case we need to match string/numbers with custom equal.
     *
     * @param {Array} arr
     * @param {*} val
     */
    
    function indexOf$1(arr, val) {
      var i = arr.length;
      while (i--) {
        if (looseEqual(arr[i], val)) {
          return i;
        }
      }
      return -1;
    }
    
    var radio = {
    
      bind: function bind() {
        var self = this;
        var el = this.el;
    
        this.getValue = function () {
          // value overwrite via v-bind:value
          if (el.hasOwnProperty('_value')) {
            return el._value;
          }
          var val = el.value;
          if (self.params.number) {
            val = toNumber(val);
          }
          return val;
        };
    
        this.listener = function () {
          self.set(self.getValue());
        };
        this.on('change', this.listener);
    
        if (el.hasAttribute('checked')) {
          this.afterBind = this.listener;
        }
      },
    
      update: function update(value) {
        this.el.checked = looseEqual(value, this.getValue());
      }
    };
    
    var text$2 = {
    
      bind: function bind() {
        var self = this;
        var el = this.el;
        var isRange = el.type === 'range';
        var lazy = this.params.lazy;
        var number = this.params.number;
        var debounce = this.params.debounce;
    
        // handle composition events.
        //   http://blog.evanyou.me/2014/01/03/composition-event/
        // skip this for Android because it handles composition
        // events quite differently. Android doesn't trigger
        // composition events for language input methods e.g.
        // Chinese, but instead triggers them for spelling
        // suggestions... (see Discussion/#162)
        var composing = false;
        if (!isAndroid && !isRange) {
          this.on('compositionstart', function () {
            composing = true;
          });
          this.on('compositionend', function () {
            composing = false;
            // in IE11 the "compositionend" event fires AFTER
            // the "input" event, so the input handler is blocked
            // at the end... have to call it here.
            //
            // #1327: in lazy mode this is unecessary.
            if (!lazy) {
              self.listener();
            }
          });
        }
    
        // prevent messing with the input when user is typing,
        // and force update on blur.
        this.focused = false;
        if (!isRange && !lazy) {
          this.on('focus', function () {
            self.focused = true;
          });
          this.on('blur', function () {
            self.focused = false;
            // do not sync value after fragment removal (#2017)
            if (!self._frag || self._frag.inserted) {
              self.rawListener();
            }
          });
        }
    
        // Now attach the main listener
        this.listener = this.rawListener = function () {
          if (composing || !self._bound) {
            return;
          }
          var val = number || isRange ? toNumber(el.value) : el.value;
          self.set(val);
          // force update on next tick to avoid lock & same value
          // also only update when user is not typing
          nextTick(function () {
            if (self._bound && !self.focused) {
              self.update(self._watcher.value);
            }
          });
        };
    
        // apply debounce
        if (debounce) {
          this.listener = _debounce(this.listener, debounce);
        }
    
        // Support jQuery events, since jQuery.trigger() doesn't
        // trigger native events in some cases and some plugins
        // rely on $.trigger()
        //
        // We want to make sure if a listener is attached using
        // jQuery, it is also removed with jQuery, that's why
        // we do the check for each directive instance and
        // store that check result on itself. This also allows
        // easier test coverage control by unsetting the global
        // jQuery variable in tests.
        this.hasjQuery = typeof jQuery === 'function';
        if (this.hasjQuery) {
          var method = jQuery.fn.on ? 'on' : 'bind';
          jQuery(el)[method]('change', this.listener);
          if (!lazy) {
            jQuery(el)[method]('input', this.listener);
          }
        } else {
          this.on('change', this.listener);
          if (!lazy) {
            this.on('input', this.listener);
          }
        }
    
        // IE9 doesn't fire input event on backspace/del/cut
        if (!lazy && isIE9) {
          this.on('cut', function () {
            nextTick(self.listener);
          });
          this.on('keyup', function (e) {
            if (e.keyCode === 46 || e.keyCode === 8) {
              self.listener();
            }
          });
        }
    
        // set initial value if present
        if (el.hasAttribute('value') || el.tagName === 'TEXTAREA' && el.value.trim()) {
          this.afterBind = this.listener;
        }
      },
    
      update: function update(value) {
        this.el.value = _toString(value);
      },
    
      unbind: function unbind() {
        var el = this.el;
        if (this.hasjQuery) {
          var method = jQuery.fn.off ? 'off' : 'unbind';
          jQuery(el)[method]('change', this.listener);
          jQuery(el)[method]('input', this.listener);
        }
      }
    };
    
    var handlers = {
      text: text$2,
      radio: radio,
      select: select,
      checkbox: checkbox
    };
    
    var model = {
    
      priority: MODEL,
      twoWay: true,
      handlers: handlers,
      params: ['lazy', 'number', 'debounce'],
    
      /**
       * Possible elements:
       *   <select>
       *   <textarea>
       *   <input type="*">
       *     - text
       *     - checkbox
       *     - radio
       *     - number
       */
    
      bind: function bind() {
        // friendly warning...
        this.checkFilters();
        if (this.hasRead && !this.hasWrite) {
          process.env.NODE_ENV !== 'production' && warn('It seems you are using a read-only filter with ' + 'v-model. You might want to use a two-way filter ' + 'to ensure correct behavior.');
        }
        var el = this.el;
        var tag = el.tagName;
        var handler;
        if (tag === 'INPUT') {
          handler = handlers[el.type] || handlers.text;
        } else if (tag === 'SELECT') {
          handler = handlers.select;
        } else if (tag === 'TEXTAREA') {
          handler = handlers.text;
        } else {
          process.env.NODE_ENV !== 'production' && warn('v-model does not support element type: ' + tag);
          return;
        }
        el.__v_model = this;
        handler.bind.call(this);
        this.update = handler.update;
        this._unbind = handler.unbind;
      },
    
      /**
       * Check read/write filter stats.
       */
    
      checkFilters: function checkFilters() {
        var filters = this.filters;
        if (!filters) return;
        var i = filters.length;
        while (i--) {
          var filter = resolveAsset(this.vm.$options, 'filters', filters[i].name);
          if (typeof filter === 'function' || filter.read) {
            this.hasRead = true;
          }
          if (filter.write) {
            this.hasWrite = true;
          }
        }
      },
    
      unbind: function unbind() {
        this.el.__v_model = null;
        this._unbind && this._unbind();
      }
    };
    
    var show = {
    
      bind: function bind() {
        // check else block
        var next = this.el.nextElementSibling;
        if (next && getAttr(next, 'v-else') !== null) {
          this.elseEl = next;
        }
      },
    
      update: function update(value) {
        this.apply(this.el, value);
        if (this.elseEl) {
          this.apply(this.elseEl, !value);
        }
      },
    
      apply: function apply(el, value) {
        if (inDoc(el)) {
          applyTransition(el, value ? 1 : -1, toggle, this.vm);
        } else {
          toggle();
        }
        function toggle() {
          el.style.display = value ? '' : 'none';
        }
      }
    };
    
    var templateCache = new Cache(1000);
    var idSelectorCache = new Cache(1000);
    
    var map = {
      efault: [0, '', ''],
      legend: [1, '<fieldset>', '</fieldset>'],
      tr: [2, '<table><tbody>', '</tbody></table>'],
      col: [2, '<table><tbody></tbody><colgroup>', '</colgroup></table>']
    };
    
    map.td = map.th = [3, '<table><tbody><tr>', '</tr></tbody></table>'];
    
    map.option = map.optgroup = [1, '<select multiple="multiple">', '</select>'];
    
    map.thead = map.tbody = map.colgroup = map.caption = map.tfoot = [1, '<table>', '</table>'];
    
    map.g = map.defs = map.symbol = map.use = map.image = map.text = map.circle = map.ellipse = map.line = map.path = map.polygon = map.polyline = map.rect = [1, '<svg ' + 'xmlns="http://www.w3.org/2000/svg" ' + 'xmlns:xlink="http://www.w3.org/1999/xlink" ' + 'xmlns:ev="http://www.w3.org/2001/xml-events"' + 'version="1.1">', '</svg>'];
    
    /**
     * Check if a node is a supported template node with a
     * DocumentFragment content.
     *
     * @param {Node} node
     * @return {Boolean}
     */
    
    function isRealTemplate(node) {
      return isTemplate(node) && node.content instanceof DocumentFragment;
    }
    
    var tagRE$1 = /<([\w:]+)/;
    var entityRE = /&#?\w+?;/;
    
    /**
     * Convert a string template to a DocumentFragment.
     * Determines correct wrapping by tag types. Wrapping
     * strategy found in jQuery & component/domify.
     *
     * @param {String} templateString
     * @param {Boolean} raw
     * @return {DocumentFragment}
     */
    
    function stringToFragment(templateString, raw) {
      // try a cache hit first
      var cacheKey = raw ? templateString : templateString.trim();
      var hit = templateCache.get(cacheKey);
      if (hit) {
        return hit;
      }
    
      var frag = document.createDocumentFragment();
      var tagMatch = templateString.match(tagRE$1);
      var entityMatch = entityRE.test(templateString);
    
      if (!tagMatch && !entityMatch) {
        // text only, return a single text node.
        frag.appendChild(document.createTextNode(templateString));
      } else {
    
        var tag = tagMatch && tagMatch[1];
        var wrap = map[tag] || map.efault;
        var depth = wrap[0];
        var prefix = wrap[1];
        var suffix = wrap[2];
        var node = document.createElement('div');
    
        node.innerHTML = prefix + templateString + suffix;
        while (depth--) {
          node = node.lastChild;
        }
    
        var child;
        /* eslint-disable no-cond-assign */
        while (child = node.firstChild) {
          /* eslint-enable no-cond-assign */
          frag.appendChild(child);
        }
      }
      if (!raw) {
        trimNode(frag);
      }
      templateCache.put(cacheKey, frag);
      return frag;
    }
    
    /**
     * Convert a template node to a DocumentFragment.
     *
     * @param {Node} node
     * @return {DocumentFragment}
     */
    
    function nodeToFragment(node) {
      // if its a template tag and the browser supports it,
      // its content is already a document fragment.
      if (isRealTemplate(node)) {
        trimNode(node.content);
        return node.content;
      }
      // script template
      if (node.tagName === 'SCRIPT') {
        return stringToFragment(node.textContent);
      }
      // normal node, clone it to avoid mutating the original
      var clonedNode = cloneNode(node);
      var frag = document.createDocumentFragment();
      var child;
      /* eslint-disable no-cond-assign */
      while (child = clonedNode.firstChild) {
        /* eslint-enable no-cond-assign */
        frag.appendChild(child);
      }
      trimNode(frag);
      return frag;
    }
    
    // Test for the presence of the Safari template cloning bug
    // https://bugs.webkit.org/showug.cgi?id=137755
    var hasBrokenTemplate = (function () {
      /* istanbul ignore else */
      if (inBrowser) {
        var a = document.createElement('div');
        a.innerHTML = '<template>1</template>';
        return !a.cloneNode(true).firstChild.innerHTML;
      } else {
        return false;
      }
    })();
    
    // Test for IE10/11 textarea placeholder clone bug
    var hasTextareaCloneBug = (function () {
      /* istanbul ignore else */
      if (inBrowser) {
        var t = document.createElement('textarea');
        t.placeholder = 't';
        return t.cloneNode(true).value === 't';
      } else {
        return false;
      }
    })();
    
    /**
     * 1. Deal with Safari cloning nested <template> bug by
     *    manually cloning all template instances.
     * 2. Deal with IE10/11 textarea placeholder bug by setting
     *    the correct value after cloning.
     *
     * @param {Element|DocumentFragment} node
     * @return {Element|DocumentFragment}
     */
    
    function cloneNode(node) {
      if (!node.querySelectorAll) {
        return node.cloneNode();
      }
      var res = node.cloneNode(true);
      var i, original, cloned;
      /* istanbul ignore if */
      if (hasBrokenTemplate) {
        var tempClone = res;
        if (isRealTemplate(node)) {
          node = node.content;
          tempClone = res.content;
        }
        original = node.querySelectorAll('template');
        if (original.length) {
          cloned = tempClone.querySelectorAll('template');
          i = cloned.length;
          while (i--) {
            cloned[i].parentNode.replaceChild(cloneNode(original[i]), cloned[i]);
          }
        }
      }
      /* istanbul ignore if */
      if (hasTextareaCloneBug) {
        if (node.tagName === 'TEXTAREA') {
          res.value = node.value;
        } else {
          original = node.querySelectorAll('textarea');
          if (original.length) {
            cloned = res.querySelectorAll('textarea');
            i = cloned.length;
            while (i--) {
              cloned[i].value = original[i].value;
            }
          }
        }
      }
      return res;
    }
    
    /**
     * Process the template option and normalizes it into a
     * a DocumentFragment that can be used as a partial or a
     * instance template.
     *
     * @param {*} template
     *        Possible values include:
     *        - DocumentFragment object
     *        - Node object of type Template
     *        - id selector: '#some-template-id'
     *        - template string: '<div><span>{{msg}}</span></div>'
     * @param {Boolean} shouldClone
     * @param {Boolean} raw
     *        inline HTML interpolation. Do not check for id
     *        selector and keep whitespace in the string.
     * @return {DocumentFragment|undefined}
     */
    
    function parseTemplate(template, shouldClone, raw) {
      var node, frag;
    
      // if the template is already a document fragment,
      // do nothing
      if (template instanceof DocumentFragment) {
        trimNode(template);
        return shouldClone ? cloneNode(template) : template;
      }
    
      if (typeof template === 'string') {
        // id selector
        if (!raw && template.charAt(0) === '#') {
          // id selector can be cached too
          frag = idSelectorCache.get(template);
          if (!frag) {
            node = document.getElementById(template.slice(1));
            if (node) {
              frag = nodeToFragment(node);
              // save selector to cache
              idSelectorCache.put(template, frag);
            }
          }
        } else {
          // normal string template
          frag = stringToFragment(template, raw);
        }
      } else if (template.nodeType) {
        // a direct node
        frag = nodeToFragment(template);
      }
    
      return frag && shouldClone ? cloneNode(frag) : frag;
    }
    
    var template = Object.freeze({
      cloneNode: cloneNode,
      parseTemplate: parseTemplate
    });
    
    /**
     * Abstraction for a partially-compiled fragment.
     * Can optionally compile content with a child scope.
     *
     * @param {Function} linker
     * @param {Vue} vm
     * @param {DocumentFragment} frag
     * @param {Vue} [host]
     * @param {Object} [scope]
     */
    function Fragment(linker, vm, frag, host, scope, parentFrag) {
      this.children = [];
      this.childFrags = [];
      this.vm = vm;
      this.scope = scope;
      this.inserted = false;
      this.parentFrag = parentFrag;
      if (parentFrag) {
        parentFrag.childFrags.push(this);
      }
      this.unlink = linker(vm, frag, host, scope, this);
      var single = this.single = frag.childNodes.length === 1 &&
      // do not go single mode if the only node is an anchor
      !frag.childNodes[0].__vue_anchor;
      if (single) {
        this.node = frag.childNodes[0];
        this.before = singleBefore;
        this.remove = singleRemove;
      } else {
        this.node = createAnchor('fragment-start');
        this.end = createAnchor('fragment-end');
        this.frag = frag;
        prepend(this.node, frag);
        frag.appendChild(this.end);
        this.before = multiBefore;
        this.remove = multiRemove;
      }
      this.node.__vfrag__ = this;
    }
    
    /**
     * Call attach/detach for all components contained within
     * this fragment. Also do so recursively for all child
     * fragments.
     *
     * @param {Function} hook
     */
    
    Fragment.prototype.callHook = function (hook) {
      var i, l;
      for (i = 0, l = this.childFrags.length; i < l; i++) {
        this.childFrags[i].callHook(hook);
      }
      for (i = 0, l = this.children.length; i < l; i++) {
        hook(this.children[i]);
      }
    };
    
    /**
     * Insert fragment before target, single node version
     *
     * @param {Node} target
     * @param {Boolean} withTransition
     */
    
    function singleBefore(target, withTransition) {
      this.inserted = true;
      var method = withTransition !== false ? beforeWithTransition : before;
      method(this.node, target, this.vm);
      if (inDoc(this.node)) {
        this.callHook(attach);
      }
    }
    
    /**
     * Remove fragment, single node version
     */
    
    function singleRemove() {
      this.inserted = false;
      var shouldCallRemove = inDoc(this.node);
      var self = this;
      this.beforeRemove();
      removeWithTransition(this.node, this.vm, function () {
        if (shouldCallRemove) {
          self.callHook(detach);
        }
        self.destroy();
      });
    }
    
    /**
     * Insert fragment before target, multi-nodes version
     *
     * @param {Node} target
     * @param {Boolean} withTransition
     */
    
    function multiBefore(target, withTransition) {
      this.inserted = true;
      var vm = this.vm;
      var method = withTransition !== false ? beforeWithTransition : before;
      mapNodeRange(this.node, this.end, function (node) {
        method(node, target, vm);
      });
      if (inDoc(this.node)) {
        this.callHook(attach);
      }
    }
    
    /**
     * Remove fragment, multi-nodes version
     */
    
    function multiRemove() {
      this.inserted = false;
      var self = this;
      var shouldCallRemove = inDoc(this.node);
      this.beforeRemove();
      removeNodeRange(this.node, this.end, this.vm, this.frag, function () {
        if (shouldCallRemove) {
          self.callHook(detach);
        }
        self.destroy();
      });
    }
    
    /**
     * Prepare the fragment for removal.
     */
    
    Fragment.prototype.beforeRemove = function () {
      var i, l;
      for (i = 0, l = this.childFrags.length; i < l; i++) {
        // call the same method recursively on child
        // fragments, depth-first
        this.childFrags[i].beforeRemove(false);
      }
      for (i = 0, l = this.children.length; i < l; i++) {
        // Call destroy for all contained instances,
        // with remove:false and defer:true.
        // Defer is necessary because we need to
        // keep the children to call detach hooks
        // on them.
        this.children[i].$destroy(false, true);
      }
      var dirs = this.unlink.dirs;
      for (i = 0, l = dirs.length; i < l; i++) {
        // disable the watchers on all the directives
        // so that the rendered content stays the same
        // during removal.
        dirs[i]._watcher && dirs[i]._watcher.teardown();
      }
    };
    
    /**
     * Destroy the fragment.
     */
    
    Fragment.prototype.destroy = function () {
      if (this.parentFrag) {
        this.parentFrag.childFrags.$remove(this);
      }
      this.node.__vfrag__ = null;
      this.unlink();
    };
    
    /**
     * Call attach hook for a Vue instance.
     *
     * @param {Vue} child
     */
    
    function attach(child) {
      if (!child._isAttached) {
        child._callHook('attached');
      }
    }
    
    /**
     * Call detach hook for a Vue instance.
     *
     * @param {Vue} child
     */
    
    function detach(child) {
      if (child._isAttached) {
        child._callHook('detached');
      }
    }
    
    var linkerCache = new Cache(5000);
    
    /**
     * A factory that can be used to create instances of a
     * fragment. Caches the compiled linker if possible.
     *
     * @param {Vue} vm
     * @param {Element|String} el
     */
    function FragmentFactory(vm, el) {
      this.vm = vm;
      var template;
      var isString = typeof el === 'string';
      if (isString || isTemplate(el)) {
        template = parseTemplate(el, true);
      } else {
        template = document.createDocumentFragment();
        template.appendChild(el);
      }
      this.template = template;
      // linker can be cached, but only for components
      var linker;
      var cid = vm.constructor.cid;
      if (cid > 0) {
        var cacheId = cid + (isString ? el : el.outerHTML);
        linker = linkerCache.get(cacheId);
        if (!linker) {
          linker = compile(template, vm.$options, true);
          linkerCache.put(cacheId, linker);
        }
      } else {
        linker = compile(template, vm.$options, true);
      }
      this.linker = linker;
    }
    
    /**
     * Create a fragment instance with given host and scope.
     *
     * @param {Vue} host
     * @param {Object} scope
     * @param {Fragment} parentFrag
     */
    
    FragmentFactory.prototype.create = function (host, scope, parentFrag) {
      var frag = cloneNode(this.template);
      return new Fragment(this.linker, this.vm, frag, host, scope, parentFrag);
    };
    
    var vIf = {
    
      priority: IF,
    
      bind: function bind() {
        var el = this.el;
        if (!el.__vue__) {
          // check else block
          var next = el.nextElementSibling;
          if (next && getAttr(next, 'v-else') !== null) {
            remove(next);
            this.elseFactory = new FragmentFactory(this.vm, next);
          }
          // check main block
          this.anchor = createAnchor('v-if');
          replace(el, this.anchor);
          this.factory = new FragmentFactory(this.vm, el);
        } else {
          process.env.NODE_ENV !== 'production' && warn('v-if="' + this.expression + '" cannot be ' + 'used on an instance root element.');
          this.invalid = true;
        }
      },
    
      update: function update(value) {
        if (this.invalid) return;
        if (value) {
          if (!this.frag) {
            this.insert();
          }
        } else {
          this.remove();
        }
      },
    
      insert: function insert() {
        if (this.elseFrag) {
          this.elseFrag.remove();
          this.elseFrag = null;
        }
        this.frag = this.factory.create(this._host, this._scope, this._frag);
        this.frag.before(this.anchor);
      },
    
      remove: function remove() {
        if (this.frag) {
          this.frag.remove();
          this.frag = null;
        }
        if (this.elseFactory && !this.elseFrag) {
          this.elseFrag = this.elseFactory.create(this._host, this._scope, this._frag);
          this.elseFrag.before(this.anchor);
        }
      },
    
      unbind: function unbind() {
        if (this.frag) {
          this.frag.destroy();
        }
        if (this.elseFrag) {
          this.elseFrag.destroy();
        }
      }
    };
    
    var uid$1 = 0;
    
    var vFor = {
    
      priority: FOR,
    
      params: ['track-by', 'stagger', 'enter-stagger', 'leave-stagger'],
    
      bind: function bind() {
        // support "item in items" syntax
        var inMatch = this.expression.match(/(.*) in (.*)/);
        if (inMatch) {
          var itMatch = inMatch[1].match(/\((.*),(.*)\)/);
          if (itMatch) {
            this.iterator = itMatch[1].trim();
            this.alias = itMatch[2].trim();
          } else {
            this.alias = inMatch[1].trim();
          }
          this.expression = inMatch[2];
        }
    
        if (!this.alias) {
          process.env.NODE_ENV !== 'production' && warn('Alias is required in v-for.');
          return;
        }
    
        // uid as a cache identifier
        this.id = '__v-for__' + ++uid$1;
    
        // check if this is an option list,
        // so that we know if we need to update the <select>'s
        // v-model when the option list has changed.
        // because v-model has a lower priority than v-for,
        // the v-model is not bound here yet, so we have to
        // retrive it in the actual updateModel() function.
        var tag = this.el.tagName;
        this.isOption = (tag === 'OPTION' || tag === 'OPTGROUP') && this.el.parentNode.tagName === 'SELECT';
    
        // setup anchor nodes
        this.start = createAnchor('v-for-start');
        this.end = createAnchor('v-for-end');
        replace(this.el, this.end);
        before(this.start, this.end);
    
        // cache
        this.cache = Object.create(null);
    
        // fragment factory
        this.factory = new FragmentFactory(this.vm, this.el);
      },
    
      update: function update(data) {
        this.diff(data);
        this.updateRef();
        this.updateModel();
      },
    
      /**
       * Diff, based on new data and old data, determine the
       * minimum amount of DOM manipulations needed to make the
       * DOM reflect the new data Array.
       *
       * The algorithm diffs the new data Array by storing a
       * hidden reference to an owner vm instance on previously
       * seen data. This allows us to achieve O(n) which is
       * better than a levenshtein distance based algorithm,
       * which is O(m * n).
       *
       * @param {Array} data
       */
    
      diff: function diff(data) {
        // check if the Array was converted from an Object
        var item = data[0];
        var convertedFromObject = this.fromObject = isObject(item) && hasOwn(item, '$key') && hasOwn(item, '$value');
    
        var trackByKey = this.params.trackBy;
        var oldFrags = this.frags;
        var frags = this.frags = new Array(data.length);
        var alias = this.alias;
        var iterator = this.iterator;
        var start = this.start;
        var end = this.end;
        var inDocument = inDoc(start);
        var init = !oldFrags;
        var i, l, frag, key, value, primitive;
    
        // First pass, go through the new Array and fill up
        // the new frags array. If a piece of data has a cached
        // instance for it, we reuse it. Otherwise build a new
        // instance.
        for (i = 0, l = data.length; i < l; i++) {
          item = data[i];
          key = convertedFromObject ? item.$key : null;
          value = convertedFromObject ? item.$value : item;
          primitive = !isObject(value);
          frag = !init && this.getCachedFrag(value, i, key);
          if (frag) {
            // reusable fragment
            frag.reused = true;
            // update $index
            frag.scope.$index = i;
            // update $key
            if (key) {
              frag.scope.$key = key;
            }
            // update iterator
            if (iterator) {
              frag.scope[iterator] = key !== null ? key : i;
            }
            // update data for track-by, object repeat &
            // primitive values.
            if (trackByKey || convertedFromObject || primitive) {
              frag.scope[alias] = value;
            }
          } else {
            // new isntance
            frag = this.create(value, alias, i, key);
            frag.fresh = !init;
          }
          frags[i] = frag;
          if (init) {
            frag.before(end);
          }
        }
    
        // we're done for the initial render.
        if (init) {
          return;
        }
    
        // Second pass, go through the old fragments and
        // destroy those who are not reused (and remove them
        // from cache)
        var removalIndex = 0;
        var totalRemoved = oldFrags.length - frags.length;
        // when removing a large number of fragments, watcher removal
        // turns out to be a perf bottleneck, so we batch the watcher
        // removals into a single filter call!
        this.vm._vForRemoving = true;
        for (i = 0, l = oldFrags.length; i < l; i++) {
          frag = oldFrags[i];
          if (!frag.reused) {
            this.deleteCachedFrag(frag);
            this.remove(frag, removalIndex++, totalRemoved, inDocument);
          }
        }
        this.vm._vForRemoving = false;
        this.vm._watchers = this.vm._watchers.filter(function (w) {
          return w.active;
        });
    
        // Final pass, move/insert new fragments into the
        // right place.
        var targetPrev, prevEl, currentPrev;
        var insertionIndex = 0;
        for (i = 0, l = frags.length; i < l; i++) {
          frag = frags[i];
          // this is the frag that we should be after
          targetPrev = frags[i - 1];
          prevEl = targetPrev ? targetPrev.staggerCb ? targetPrev.staggerAnchor : targetPrev.end || targetPrev.node : start;
          if (frag.reused && !frag.staggerCb) {
            currentPrev = findPrevFrag(frag, start, this.id);
            if (currentPrev !== targetPrev && (!currentPrev ||
            // optimization for moving a single item.
            // thanks to suggestions by @livoras in #1807
            findPrevFrag(currentPrev, start, this.id) !== targetPrev)) {
              this.move(frag, prevEl);
            }
          } else {
            // new instance, or still in stagger.
            // insert with updated stagger index.
            this.insert(frag, insertionIndex++, prevEl, inDocument);
          }
          frag.reused = frag.fresh = false;
        }
      },
    
      /**
       * Create a new fragment instance.
       *
       * @param {*} value
       * @param {String} alias
       * @param {Number} index
       * @param {String} [key]
       * @return {Fragment}
       */
    
      create: function create(value, alias, index, key) {
        var host = this._host;
        // create iteration scope
        var parentScope = this._scope || this.vm;
        var scope = Object.create(parentScope);
        // ref holder for the scope
        scope.$refs = Object.create(parentScope.$refs);
        scope.$els = Object.create(parentScope.$els);
        // make sure point $parent to parent scope
        scope.$parent = parentScope;
        // for two-way binding on alias
        scope.$forContext = this;
        // define scope properties
        defineReactive(scope, alias, value);
        defineReactive(scope, '$index', index);
        if (key) {
          defineReactive(scope, '$key', key);
        } else if (scope.$key) {
          // avoid accidental fallback
          def(scope, '$key', null);
        }
        if (this.iterator) {
          defineReactive(scope, this.iterator, key !== null ? key : index);
        }
        var frag = this.factory.create(host, scope, this._frag);
        frag.forId = this.id;
        this.cacheFrag(value, frag, index, key);
        return frag;
      },
    
      /**
       * Update the v-ref on owner vm.
       */
    
      updateRef: function updateRef() {
        var ref = this.descriptor.ref;
        if (!ref) return;
        var hash = (this._scope || this.vm).$refs;
        var refs;
        if (!this.fromObject) {
          refs = this.frags.map(findVmFromFrag);
        } else {
          refs = {};
          this.frags.forEach(function (frag) {
            refs[frag.scope.$key] = findVmFromFrag(frag);
          });
        }
        hash[ref] = refs;
      },
    
      /**
       * For option lists, update the containing v-model on
       * parent <select>.
       */
    
      updateModel: function updateModel() {
        if (this.isOption) {
          var parent = this.start.parentNode;
          var model = parent && parent.__v_model;
          if (model) {
            model.forceUpdate();
          }
        }
      },
    
      /**
       * Insert a fragment. Handles staggering.
       *
       * @param {Fragment} frag
       * @param {Number} index
       * @param {Node} prevEl
       * @param {Boolean} inDocument
       */
    
      insert: function insert(frag, index, prevEl, inDocument) {
        if (frag.staggerCb) {
          frag.staggerCb.cancel();
          frag.staggerCb = null;
        }
        var staggerAmount = this.getStagger(frag, index, null, 'enter');
        if (inDocument && staggerAmount) {
          // create an anchor and insert it synchronously,
          // so that we can resolve the correct order without
          // worrying about some elements not inserted yet
          var anchor = frag.staggerAnchor;
          if (!anchor) {
            anchor = frag.staggerAnchor = createAnchor('stagger-anchor');
            anchor.__vfrag__ = frag;
          }
          after(anchor, prevEl);
          var op = frag.staggerCb = cancellable(function () {
            frag.staggerCb = null;
            frag.before(anchor);
            remove(anchor);
          });
          setTimeout(op, staggerAmount);
        } else {
          frag.before(prevEl.nextSibling);
        }
      },
    
      /**
       * Remove a fragment. Handles staggering.
       *
       * @param {Fragment} frag
       * @param {Number} index
       * @param {Number} total
       * @param {Boolean} inDocument
       */
    
      remove: function remove(frag, index, total, inDocument) {
        if (frag.staggerCb) {
          frag.staggerCb.cancel();
          frag.staggerCb = null;
          // it's not possible for the same frag to be removed
          // twice, so if we have a pending stagger callback,
          // it means this frag is queued for enter but removed
          // before its transition started. Since it is already
          // destroyed, we can just leave it in detached state.
          return;
        }
        var staggerAmount = this.getStagger(frag, index, total, 'leave');
        if (inDocument && staggerAmount) {
          var op = frag.staggerCb = cancellable(function () {
            frag.staggerCb = null;
            frag.remove();
          });
          setTimeout(op, staggerAmount);
        } else {
          frag.remove();
        }
      },
    
      /**
       * Move a fragment to a new position.
       * Force no transition.
       *
       * @param {Fragment} frag
       * @param {Node} prevEl
       */
    
      move: function move(frag, prevEl) {
        // fix a common issue with Sortable:
        // if prevEl doesn't have nextSibling, this means it's
        // been dragged after the end anchor. Just re-position
        // the end anchor to the end of the container.
        /* istanbul ignore if */
        if (!prevEl.nextSibling) {
          this.end.parentNode.appendChild(this.end);
        }
        frag.before(prevEl.nextSibling, false);
      },
    
      /**
       * Cache a fragment using track-by or the object key.
       *
       * @param {*} value
       * @param {Fragment} frag
       * @param {Number} index
       * @param {String} [key]
       */
    
      cacheFrag: function cacheFrag(value, frag, index, key) {
        var trackByKey = this.params.trackBy;
        var cache = this.cache;
        var primitive = !isObject(value);
        var id;
        if (key || trackByKey || primitive) {
          id = trackByKey ? trackByKey === '$index' ? index : value[trackByKey] : key || value;
          if (!cache[id]) {
            cache[id] = frag;
          } else if (trackByKey !== '$index') {
            process.env.NODE_ENV !== 'production' && this.warnDuplicate(value);
          }
        } else {
          id = this.id;
          if (hasOwn(value, id)) {
            if (value[id] === null) {
              value[id] = frag;
            } else {
              process.env.NODE_ENV !== 'production' && this.warnDuplicate(value);
            }
          } else {
            def(value, id, frag);
          }
        }
        frag.raw = value;
      },
    
      /**
       * Get a cached fragment from the value/index/key
       *
       * @param {*} value
       * @param {Number} index
       * @param {String} key
       * @return {Fragment}
       */
    
      getCachedFrag: function getCachedFrag(value, index, key) {
        var trackByKey = this.params.trackBy;
        var primitive = !isObject(value);
        var frag;
        if (key || trackByKey || primitive) {
          var id = trackByKey ? trackByKey === '$index' ? index : value[trackByKey] : key || value;
          frag = this.cache[id];
        } else {
          frag = value[this.id];
        }
        if (frag && (frag.reused || frag.fresh)) {
          process.env.NODE_ENV !== 'production' && this.warnDuplicate(value);
        }
        return frag;
      },
    
      /**
       * Delete a fragment from cache.
       *
       * @param {Fragment} frag
       */
    
      deleteCachedFrag: function deleteCachedFrag(frag) {
        var value = frag.raw;
        var trackByKey = this.params.trackBy;
        var scope = frag.scope;
        var index = scope.$index;
        // fix #948: avoid accidentally fall through to
        // a parent repeater which happens to have $key.
        var key = hasOwn(scope, '$key') && scope.$key;
        var primitive = !isObject(value);
        if (trackByKey || key || primitive) {
          var id = trackByKey ? trackByKey === '$index' ? index : value[trackByKey] : key || value;
          this.cache[id] = null;
        } else {
          value[this.id] = null;
          frag.raw = null;
        }
      },
    
      /**
       * Get the stagger amount for an insertion/removal.
       *
       * @param {Fragment} frag
       * @param {Number} index
       * @param {Number} total
       * @param {String} type
       */
    
      getStagger: function getStagger(frag, index, total, type) {
        type = type + 'Stagger';
        var trans = frag.node.__v_trans;
        var hooks = trans && trans.hooks;
        var hook = hooks && (hooks[type] || hooks.stagger);
        return hook ? hook.call(frag, index, total) : index * parseInt(this.params[type] || this.params.stagger, 10);
      },
    
      /**
       * Pre-process the value before piping it through the
       * filters. This is passed to and called by the watcher.
       */
    
      _preProcess: function _preProcess(value) {
        // regardless of type, store the un-filtered raw value.
        this.rawValue = value;
        return value;
      },
    
      /**
       * Post-process the value after it has been piped through
       * the filters. This is passed to and called by the watcher.
       *
       * It is necessary for this to be called during the
       * wathcer's dependency collection phase because we want
       * the v-for to update when the source Object is mutated.
       */
    
      _postProcess: function _postProcess(value) {
        if (isArray(value)) {
          return value;
        } else if (isPlainObject(value)) {
          // convert plain object to array.
          var keys = Object.keys(value);
          var i = keys.length;
          var res = new Array(i);
          var key;
          while (i--) {
            key = keys[i];
            res[i] = {
              $key: key,
              $value: value[key]
            };
          }
          return res;
        } else {
          if (typeof value === 'number' && !isNaN(value)) {
            value = range(value);
          }
          return value || [];
        }
      },
    
      unbind: function unbind() {
        if (this.descriptor.ref) {
          (this._scope || this.vm).$refs[this.descriptor.ref] = null;
        }
        if (this.frags) {
          var i = this.frags.length;
          var frag;
          while (i--) {
            frag = this.frags[i];
            this.deleteCachedFrag(frag);
            frag.destroy();
          }
        }
      }
    };
    
    /**
     * Helper to find the previous element that is a fragment
     * anchor. This is necessary because a destroyed frag's
     * element could still be lingering in the DOM before its
     * leaving transition finishes, but its inserted flag
     * should have been set to false so we can skip them.
     *
     * If this is a block repeat, we want to make sure we only
     * return frag that is bound to this v-for. (see #929)
     *
     * @param {Fragment} frag
     * @param {Comment|Text} anchor
     * @param {String} id
     * @return {Fragment}
     */
    
    function findPrevFrag(frag, anchor, id) {
      var el = frag.node.previousSibling;
      /* istanbul ignore if */
      if (!el) return;
      frag = el.__vfrag__;
      while ((!frag || frag.forId !== id || !frag.inserted) && el !== anchor) {
        el = el.previousSibling;
        /* istanbul ignore if */
        if (!el) return;
        frag = el.__vfrag__;
      }
      return frag;
    }
    
    /**
     * Find a vm from a fragment.
     *
     * @param {Fragment} frag
     * @return {Vue|undefined}
     */
    
    function findVmFromFrag(frag) {
      var node = frag.node;
      // handle multi-node frag
      if (frag.end) {
        while (!node.__vue__ && node !== frag.end && node.nextSibling) {
          node = node.nextSibling;
        }
      }
      return node.__vue__;
    }
    
    /**
     * Create a range array from given number.
     *
     * @param {Number} n
     * @return {Array}
     */
    
    function range(n) {
      var i = -1;
      var ret = new Array(Math.floor(n));
      while (++i < n) {
        ret[i] = i;
      }
      return ret;
    }
    
    if (process.env.NODE_ENV !== 'production') {
      vFor.warnDuplicate = function (value) {
        warn('Duplicate value found in v-for="' + this.descriptor.raw + '": ' + JSON.stringify(value) + '. Use track-by="$index" if ' + 'you are expecting duplicate values.');
      };
    }
    
    var html = {
    
      bind: function bind() {
        // a comment node means this is a binding for
        // {{{ inline unescaped html }}}
        if (this.el.nodeType === 8) {
          // hold nodes
          this.nodes = [];
          // replace the placeholder with proper anchor
          this.anchor = createAnchor('v-html');
          replace(this.el, this.anchor);
        }
      },
    
      update: function update(value) {
        value = _toString(value);
        if (this.nodes) {
          this.swap(value);
        } else {
          this.el.innerHTML = value;
        }
      },
    
      swap: function swap(value) {
        // remove old nodes
        var i = this.nodes.length;
        while (i--) {
          remove(this.nodes[i]);
        }
        // convert new value to a fragment
        // do not attempt to retrieve from id selector
        var frag = parseTemplate(value, true, true);
        // save a reference to these nodes so we can remove later
        this.nodes = toArray(frag.childNodes);
        before(frag, this.anchor);
      }
    };
    
    var text = {
    
      bind: function bind() {
        this.attr = this.el.nodeType === 3 ? 'data' : 'textContent';
      },
    
      update: function update(value) {
        this.el[this.attr] = _toString(value);
      }
    };
    
    // must export plain object
    var publicDirectives = {
      text: text,
      html: html,
      'for': vFor,
      'if': vIf,
      show: show,
      model: model,
      on: on,
      bind: bind,
      el: el,
      ref: ref,
      cloak: cloak
    };
    
    var queue$1 = [];
    var queued = false;
    
    /**
     * Push a job into the queue.
     *
     * @param {Function} job
     */
    
    function pushJob(job) {
      queue$1.push(job);
      if (!queued) {
        queued = true;
        nextTick(flush);
      }
    }
    
    /**
     * Flush the queue, and do one forced reflow before
     * triggering transitions.
     */
    
    function flush() {
      // Force layout
      var f = document.documentElement.offsetHeight;
      for (var i = 0; i < queue$1.length; i++) {
        queue$1[i]();
      }
      queue$1 = [];
      queued = false;
      // dummy return, so js linters don't complain about
      // unused variable f
      return f;
    }
    
    var TYPE_TRANSITION = 'transition';
    var TYPE_ANIMATION = 'animation';
    var transDurationProp = transitionProp + 'Duration';
    var animDurationProp = animationProp + 'Duration';
    
    /**
     * A Transition object that encapsulates the state and logic
     * of the transition.
     *
     * @param {Element} el
     * @param {String} id
     * @param {Object} hooks
     * @param {Vue} vm
     */
    function Transition(el, id, hooks, vm) {
      this.id = id;
      this.el = el;
      this.enterClass = hooks && hooks.enterClass || id + '-enter';
      this.leaveClass = hooks && hooks.leaveClass || id + '-leave';
      this.hooks = hooks;
      this.vm = vm;
      // async state
      this.pendingCssEvent = this.pendingCssCb = this.cancel = this.pendingJsCb = this.op = this.cb = null;
      this.justEntered = false;
      this.entered = this.left = false;
      this.typeCache = {};
      // check css transition type
      this.type = hooks && hooks.type;
      /* istanbul ignore if */
      if (process.env.NODE_ENV !== 'production') {
        if (this.type && this.type !== TYPE_TRANSITION && this.type !== TYPE_ANIMATION) {
          warn('invalid CSS transition type for transition="' + this.id + '": ' + this.type);
        }
      }
      // bind
      var self = this;['enterNextTick', 'enterDone', 'leaveNextTick', 'leaveDone'].forEach(function (m) {
        self[m] = bind$1(self[m], self);
      });
    }
    
    var p$1 = Transition.prototype;
    
    /**
     * Start an entering transition.
     *
     * 1. enter transition triggered
     * 2. call beforeEnter hook
     * 3. add enter class
     * 4. insert/show element
     * 5. call enter hook (with possible explicit js callback)
     * 6. reflow
     * 7. based on transition type:
     *    - transition:
     *        remove class now, wait for transitionend,
     *        then done if there's no explicit js callback.
     *    - animation:
     *        wait for animationend, remove class,
     *        then done if there's no explicit js callback.
     *    - no css transition:
     *        done now if there's no explicit js callback.
     * 8. wait for either done or js callback, then call
     *    afterEnter hook.
     *
     * @param {Function} op - insert/show the element
     * @param {Function} [cb]
     */
    
    p$1.enter = function (op, cb) {
      this.cancelPending();
      this.callHook('beforeEnter');
      this.cb = cb;
      addClass(this.el, this.enterClass);
      op();
      this.entered = false;
      this.callHookWithCb('enter');
      if (this.entered) {
        return; // user called done synchronously.
      }
      this.cancel = this.hooks && this.hooks.enterCancelled;
      pushJob(this.enterNextTick);
    };
    
    /**
     * The "nextTick" phase of an entering transition, which is
     * to be pushed into a queue and executed after a reflow so
     * that removing the class can trigger a CSS transition.
     */
    
    p$1.enterNextTick = function () {
    
      // Important hack:
      // in Chrome, if a just-entered element is applied the
      // leave class while its interpolated property still has
      // a very small value (within one frame), Chrome will
      // skip the leave transition entirely and not firing the
      // transtionend event. Therefore we need to protected
      // against such cases using a one-frame timeout.
      this.justEntered = true;
      var self = this;
      setTimeout(function () {
        self.justEntered = false;
      }, 17);
    
      var enterDone = this.enterDone;
      var type = this.getCssTransitionType(this.enterClass);
      if (!this.pendingJsCb) {
        if (type === TYPE_TRANSITION) {
          // trigger transition by removing enter class now
          removeClass(this.el, this.enterClass);
          this.setupCssCb(transitionEndEvent, enterDone);
        } else if (type === TYPE_ANIMATION) {
          this.setupCssCb(animationEndEvent, enterDone);
        } else {
          enterDone();
        }
      } else if (type === TYPE_TRANSITION) {
        removeClass(this.el, this.enterClass);
      }
    };
    
    /**
     * The "cleanup" phase of an entering transition.
     */
    
    p$1.enterDone = function () {
      this.entered = true;
      this.cancel = this.pendingJsCb = null;
      removeClass(this.el, this.enterClass);
      this.callHook('afterEnter');
      if (this.cb) this.cb();
    };
    
    /**
     * Start a leaving transition.
     *
     * 1. leave transition triggered.
     * 2. call beforeLeave hook
     * 3. add leave class (trigger css transition)
     * 4. call leave hook (with possible explicit js callback)
     * 5. reflow if no explicit js callback is provided
     * 6. based on transition type:
     *    - transition or animation:
     *        wait for end event, remove class, then done if
     *        there's no explicit js callback.
     *    - no css transition:
     *        done if there's no explicit js callback.
     * 7. wait for either done or js callback, then call
     *    afterLeave hook.
     *
     * @param {Function} op - remove/hide the element
     * @param {Function} [cb]
     */
    
    p$1.leave = function (op, cb) {
      this.cancelPending();
      this.callHook('beforeLeave');
      this.op = op;
      this.cb = cb;
      addClass(this.el, this.leaveClass);
      this.left = false;
      this.callHookWithCb('leave');
      if (this.left) {
        return; // user called done synchronously.
      }
      this.cancel = this.hooks && this.hooks.leaveCancelled;
      // only need to handle leaveDone if
      // 1. the transition is already done (synchronously called
      //    by the user, which causes this.op set to null)
      // 2. there's no explicit js callback
      if (this.op && !this.pendingJsCb) {
        // if a CSS transition leaves immediately after enter,
        // the transitionend event never fires. therefore we
        // detect such cases and end the leave immediately.
        if (this.justEntered) {
          this.leaveDone();
        } else {
          pushJob(this.leaveNextTick);
        }
      }
    };
    
    /**
     * The "nextTick" phase of a leaving transition.
     */
    
    p$1.leaveNextTick = function () {
      var type = this.getCssTransitionType(this.leaveClass);
      if (type) {
        var event = type === TYPE_TRANSITION ? transitionEndEvent : animationEndEvent;
        this.setupCssCb(event, this.leaveDone);
      } else {
        this.leaveDone();
      }
    };
    
    /**
     * The "cleanup" phase of a leaving transition.
     */
    
    p$1.leaveDone = function () {
      this.left = true;
      this.cancel = this.pendingJsCb = null;
      this.op();
      removeClass(this.el, this.leaveClass);
      this.callHook('afterLeave');
      if (this.cb) this.cb();
      this.op = null;
    };
    
    /**
     * Cancel any pending callbacks from a previously running
     * but not finished transition.
     */
    
    p$1.cancelPending = function () {
      this.op = this.cb = null;
      var hasPending = false;
      if (this.pendingCssCb) {
        hasPending = true;
        off(this.el, this.pendingCssEvent, this.pendingCssCb);
        this.pendingCssEvent = this.pendingCssCb = null;
      }
      if (this.pendingJsCb) {
        hasPending = true;
        this.pendingJsCb.cancel();
        this.pendingJsCb = null;
      }
      if (hasPending) {
        removeClass(this.el, this.enterClass);
        removeClass(this.el, this.leaveClass);
      }
      if (this.cancel) {
        this.cancel.call(this.vm, this.el);
        this.cancel = null;
      }
    };
    
    /**
     * Call a user-provided synchronous hook function.
     *
     * @param {String} type
     */
    
    p$1.callHook = function (type) {
      if (this.hooks && this.hooks[type]) {
        this.hooks[type].call(this.vm, this.el);
      }
    };
    
    /**
     * Call a user-provided, potentially-async hook function.
     * We check for the length of arguments to see if the hook
     * expects a `done` callback. If true, the transition's end
     * will be determined by when the user calls that callback;
     * otherwise, the end is determined by the CSS transition or
     * animation.
     *
     * @param {String} type
     */
    
    p$1.callHookWithCb = function (type) {
      var hook = this.hooks && this.hooks[type];
      if (hook) {
        if (hook.length > 1) {
          this.pendingJsCb = cancellable(this[type + 'Done']);
        }
        hook.call(this.vm, this.el, this.pendingJsCb);
      }
    };
    
    /**
     * Get an element's transition type based on the
     * calculated styles.
     *
     * @param {String} className
     * @return {Number}
     */
    
    p$1.getCssTransitionType = function (className) {
      /* istanbul ignore if */
      if (!transitionEndEvent ||
      // skip CSS transitions if page is not visible -
      // this solves the issue of transitionend events not
      // firing until the page is visible again.
      // pageVisibility API is supported in IE10+, same as
      // CSS transitions.
      document.hidden ||
      // explicit js-only transition
      this.hooks && this.hooks.css === false ||
      // element is hidden
      isHidden(this.el)) {
        return;
      }
      var type = this.type || this.typeCache[className];
      if (type) return type;
      var inlineStyles = this.el.style;
      var computedStyles = window.getComputedStyle(this.el);
      var transDuration = inlineStyles[transDurationProp] || computedStyles[transDurationProp];
      if (transDuration && transDuration !== '0s') {
        type = TYPE_TRANSITION;
      } else {
        var animDuration = inlineStyles[animDurationProp] || computedStyles[animDurationProp];
        if (animDuration && animDuration !== '0s') {
          type = TYPE_ANIMATION;
        }
      }
      if (type) {
        this.typeCache[className] = type;
      }
      return type;
    };
    
    /**
     * Setup a CSS transitionend/animationend callback.
     *
     * @param {String} event
     * @param {Function} cb
     */
    
    p$1.setupCssCb = function (event, cb) {
      this.pendingCssEvent = event;
      var self = this;
      var el = this.el;
      var onEnd = this.pendingCssCb = function (e) {
        if (e.target === el) {
          off(el, event, onEnd);
          self.pendingCssEvent = self.pendingCssCb = null;
          if (!self.pendingJsCb && cb) {
            cb();
          }
        }
      };
      on$1(el, event, onEnd);
    };
    
    /**
     * Check if an element is hidden - in that case we can just
     * skip the transition alltogether.
     *
     * @param {Element} el
     * @return {Boolean}
     */
    
    function isHidden(el) {
      return !(el.offsetWidth || el.offsetHeight || el.getClientRects().length);
    }
    
    var transition = {
    
      priority: TRANSITION,
    
      update: function update(id, oldId) {
        var el = this.el;
        // resolve on owner vm
        var hooks = resolveAsset(this.vm.$options, 'transitions', id);
        id = id || 'v';
        // apply on closest vm
        el.__v_trans = new Transition(el, id, hooks, this.el.__vue__ || this.vm);
        if (oldId) {
          removeClass(el, oldId + '-transition');
        }
        addClass(el, id + '-transition');
      }
    };
    
    var bindingModes = config._propBindingModes;
    
    var propDef = {
    
      bind: function bind() {
    
        var child = this.vm;
        var parent = child._context;
        // passed in from compiler directly
        var prop = this.descriptor.prop;
        var childKey = prop.path;
        var parentKey = prop.parentPath;
        var twoWay = prop.mode === bindingModes.TWO_WAY;
    
        var parentWatcher = this.parentWatcher = new Watcher(parent, parentKey, function (val) {
          val = coerceProp(prop, val);
          if (assertProp(prop, val)) {
            child[childKey] = val;
          }
        }, {
          twoWay: twoWay,
          filters: prop.filters,
          // important: props need to be observed on the
          // v-for scope if present
          scope: this._scope
        });
    
        // set the child initial value.
        initProp(child, prop, parentWatcher.value);
    
        // setup two-way binding
        if (twoWay) {
          // important: defer the child watcher creation until
          // the created hook (after data observation)
          var self = this;
          child.$once('pre-hook:created', function () {
            self.childWatcher = new Watcher(child, childKey, function (val) {
              parentWatcher.set(val);
            }, {
              // ensure sync upward before parent sync down.
              // this is necessary in cases e.g. the child
              // mutates a prop array, then replaces it. (#1683)
              sync: true
            });
          });
        }
      },
    
      unbind: function unbind() {
        this.parentWatcher.teardown();
        if (this.childWatcher) {
          this.childWatcher.teardown();
        }
      }
    };
    
    var component = {
    
      priority: COMPONENT,
    
      params: ['keep-alive', 'transition-mode', 'inline-template'],
    
      /**
       * Setup. Two possible usages:
       *
       * - static:
       *   <comp> or <div v-component="comp">
       *
       * - dynamic:
       *   <component :is="view">
       */
    
      bind: function bind() {
        if (!this.el.__vue__) {
          // keep-alive cache
          this.keepAlive = this.params.keepAlive;
          if (this.keepAlive) {
            this.cache = {};
          }
          // check inline-template
          if (this.params.inlineTemplate) {
            // extract inline template as a DocumentFragment
            this.inlineTemplate = extractContent(this.el, true);
          }
          // component resolution related state
          this.pendingComponentCb = this.Component = null;
          // transition related state
          this.pendingRemovals = 0;
          this.pendingRemovalCb = null;
          // create a ref anchor
          this.anchor = createAnchor('v-component');
          replace(this.el, this.anchor);
          // remove is attribute.
          // this is removed during compilation, but because compilation is
          // cached, when the component is used elsewhere this attribute
          // will remain at link time.
          this.el.removeAttribute('is');
          // remove ref, same as above
          if (this.descriptor.ref) {
            this.el.removeAttribute('v-ref:' + hyphenate(this.descriptor.ref));
          }
          // if static, build right now.
          if (this.literal) {
            this.setComponent(this.expression);
          }
        } else {
          process.env.NODE_ENV !== 'production' && warn('cannot mount component "' + this.expression + '" ' + 'on already mounted element: ' + this.el);
        }
      },
    
      /**
       * Public update, called by the watcher in the dynamic
       * literal scenario, e.g. <component :is="view">
       */
    
      update: function update(value) {
        if (!this.literal) {
          this.setComponent(value);
        }
      },
    
      /**
       * Switch dynamic components. May resolve the component
       * asynchronously, and perform transition based on
       * specified transition mode. Accepts a few additional
       * arguments specifically for vue-router.
       *
       * The callback is called when the full transition is
       * finished.
       *
       * @param {String} value
       * @param {Function} [cb]
       */
    
      setComponent: function setComponent(value, cb) {
        this.invalidatePending();
        if (!value) {
          // just remove current
          this.unbuild(true);
          this.remove(this.childVM, cb);
          this.childVM = null;
        } else {
          var self = this;
          this.resolveComponent(value, function () {
            self.mountComponent(cb);
          });
        }
      },
    
      /**
       * Resolve the component constructor to use when creating
       * the child vm.
       */
    
      resolveComponent: function resolveComponent(id, cb) {
        var self = this;
        this.pendingComponentCb = cancellable(function (Component) {
          self.ComponentName = Component.options.name || id;
          self.Component = Component;
          cb();
        });
        this.vm._resolveComponent(id, this.pendingComponentCb);
      },
    
      /**
       * Create a new instance using the current constructor and
       * replace the existing instance. This method doesn't care
       * whether the new component and the old one are actually
       * the same.
       *
       * @param {Function} [cb]
       */
    
      mountComponent: function mountComponent(cb) {
        // actual mount
        this.unbuild(true);
        var self = this;
        var activateHook = this.Component.options.activate;
        var cached = this.getCached();
        var newComponent = this.build();
        if (activateHook && !cached) {
          this.waitingFor = newComponent;
          activateHook.call(newComponent, function () {
            if (self.waitingFor !== newComponent) {
              return;
            }
            self.waitingFor = null;
            self.transition(newComponent, cb);
          });
        } else {
          // update ref for kept-alive component
          if (cached) {
            newComponent._updateRef();
          }
          this.transition(newComponent, cb);
        }
      },
    
      /**
       * When the component changes or unbinds before an async
       * constructor is resolved, we need to invalidate its
       * pending callback.
       */
    
      invalidatePending: function invalidatePending() {
        if (this.pendingComponentCb) {
          this.pendingComponentCb.cancel();
          this.pendingComponentCb = null;
        }
      },
    
      /**
       * Instantiate/insert a new child vm.
       * If keep alive and has cached instance, insert that
       * instance; otherwise build a new one and cache it.
       *
       * @param {Object} [extraOptions]
       * @return {Vue} - the created instance
       */
    
      build: function build(extraOptions) {
        var cached = this.getCached();
        if (cached) {
          return cached;
        }
        if (this.Component) {
          // default options
          var options = {
            name: this.ComponentName,
            el: cloneNode(this.el),
            template: this.inlineTemplate,
            // make sure to add the child with correct parent
            // if this is a transcluded component, its parent
            // should be the transclusion host.
            parent: this._host || this.vm,
            // if no inline-template, then the compiled
            // linker can be cached for better performance.
            _linkerCachable: !this.inlineTemplate,
            _ref: this.descriptor.ref,
            _asComponent: true,
            _isRouterView: this._isRouterView,
            // if this is a transcluded component, context
            // will be the common parent vm of this instance
            // and its host.
            _context: this.vm,
            // if this is inside an inline v-for, the scope
            // will be the intermediate scope created for this
            // repeat fragment. this is used for linking props
            // and container directives.
            _scope: this._scope,
            // pass in the owner fragment of this component.
            // this is necessary so that the fragment can keep
            // track of its contained components in order to
            // call attach/detach hooks for them.
            _frag: this._frag
          };
          // extra options
          // in 1.0.0 this is used by vue-router only
          /* istanbul ignore if */
          if (extraOptions) {
            extend(options, extraOptions);
          }
          var child = new this.Component(options);
          if (this.keepAlive) {
            this.cache[this.Component.cid] = child;
          }
          /* istanbul ignore if */
          if (process.env.NODE_ENV !== 'production' && this.el.hasAttribute('transition') && child._isFragment) {
            warn('Transitions will not work on a fragment instance. ' + 'Template: ' + child.$options.template);
          }
          return child;
        }
      },
    
      /**
       * Try to get a cached instance of the current component.
       *
       * @return {Vue|undefined}
       */
    
      getCached: function getCached() {
        return this.keepAlive && this.cache[this.Component.cid];
      },
    
      /**
       * Teardown the current child, but defers cleanup so
       * that we can separate the destroy and removal steps.
       *
       * @param {Boolean} defer
       */
    
      unbuild: function unbuild(defer) {
        if (this.waitingFor) {
          this.waitingFor.$destroy();
          this.waitingFor = null;
        }
        var child = this.childVM;
        if (!child || this.keepAlive) {
          if (child) {
            // remove ref
            child._updateRef(true);
          }
          return;
        }
        // the sole purpose of `deferCleanup` is so that we can
        // "deactivate" the vm right now and perform DOM removal
        // later.
        child.$destroy(false, defer);
      },
    
      /**
       * Remove current destroyed child and manually do
       * the cleanup after removal.
       *
       * @param {Function} cb
       */
    
      remove: function remove(child, cb) {
        var keepAlive = this.keepAlive;
        if (child) {
          // we may have a component switch when a previous
          // component is still being transitioned out.
          // we want to trigger only one lastest insertion cb
          // when the existing transition finishes. (#1119)
          this.pendingRemovals++;
          this.pendingRemovalCb = cb;
          var self = this;
          child.$remove(function () {
            self.pendingRemovals--;
            if (!keepAlive) child._cleanup();
            if (!self.pendingRemovals && self.pendingRemovalCb) {
              self.pendingRemovalCb();
              self.pendingRemovalCb = null;
            }
          });
        } else if (cb) {
          cb();
        }
      },
    
      /**
       * Actually swap the components, depending on the
       * transition mode. Defaults to simultaneous.
       *
       * @param {Vue} target
       * @param {Function} [cb]
       */
    
      transition: function transition(target, cb) {
        var self = this;
        var current = this.childVM;
        // for devtool inspection
        if (process.env.NODE_ENV !== 'production') {
          if (current) current._inactive = true;
          target._inactive = false;
        }
        this.childVM = target;
        switch (self.params.transitionMode) {
          case 'in-out':
            target.$before(self.anchor, function () {
              self.remove(current, cb);
            });
            break;
          case 'out-in':
            self.remove(current, function () {
              target.$before(self.anchor, cb);
            });
            break;
          default:
            self.remove(current);
            target.$before(self.anchor, cb);
        }
      },
    
      /**
       * Unbind.
       */
    
      unbind: function unbind() {
        this.invalidatePending();
        // Do not defer cleanup when unbinding
        this.unbuild();
        // destroy all keep-alive cached instances
        if (this.cache) {
          for (var key in this.cache) {
            this.cache[key].$destroy();
          }
          this.cache = null;
        }
      }
    };
    
    var vClass = {
    
      deep: true,
    
      update: function update(value) {
        if (value && typeof value === 'string') {
          this.handleObject(stringToObject(value));
        } else if (isPlainObject(value)) {
          this.handleObject(value);
        } else if (isArray(value)) {
          this.handleArray(value);
        } else {
          this.cleanup();
        }
      },
    
      handleObject: function handleObject(value) {
        this.cleanup(value);
        var keys = this.prevKeys = Object.keys(value);
        for (var i = 0, l = keys.length; i < l; i++) {
          var key = keys[i];
          if (value[key]) {
            addClass(this.el, key);
          } else {
            removeClass(this.el, key);
          }
        }
      },
    
      handleArray: function handleArray(value) {
        this.cleanup(value);
        for (var i = 0, l = value.length; i < l; i++) {
          if (value[i]) {
            addClass(this.el, value[i]);
          }
        }
        this.prevKeys = value.slice();
      },
    
      cleanup: function cleanup(value) {
        if (this.prevKeys) {
          var i = this.prevKeys.length;
          while (i--) {
            var key = this.prevKeys[i];
            if (key && (!value || !contains$1(value, key))) {
              removeClass(this.el, key);
            }
          }
        }
      }
    };
    
    function stringToObject(value) {
      var res = {};
      var keys = value.trim().split(/\s+/);
      var i = keys.length;
      while (i--) {
        res[keys[i]] = true;
      }
      return res;
    }
    
    function contains$1(value, key) {
      return isArray(value) ? value.indexOf(key) > -1 : hasOwn(value, key);
    }
    
    var internalDirectives = {
      style: style,
      'class': vClass,
      component: component,
      prop: propDef,
      transition: transition
    };
    
    var propBindingModes = config._propBindingModes;
    var empty = {};
    
    // regexes
    var identRE$1 = /^[$_a-zA-Z]+[\w$]*$/;
    var settablePathRE = /^[A-Za-z_$][\w$]*(\.[A-Za-z_$][\w$]*|\[[^\[\]]+\])*$/;
    
    /**
     * Compile props on a root element and return
     * a props link function.
     *
     * @param {Element|DocumentFragment} el
     * @param {Array} propOptions
     * @return {Function} propsLinkFn
     */
    
    function compileProps(el, propOptions) {
      var props = [];
      var names = Object.keys(propOptions);
      var i = names.length;
      var options, name, attr, value, path, parsed, prop;
      while (i--) {
        name = names[i];
        options = propOptions[name] || empty;
    
        if (process.env.NODE_ENV !== 'production' && name === '$data') {
          warn('Do not use $data as prop.');
          continue;
        }
    
        // props could contain dashes, which will be
        // interpreted as minus calculations by the parser
        // so we need to camelize the path here
        path = camelize(name);
        if (!identRE$1.test(path)) {
          process.env.NODE_ENV !== 'production' && warn('Invalid prop key: "' + name + '". Prop keys ' + 'must be valid identifiers.');
          continue;
        }
    
        prop = {
          name: name,
          path: path,
          options: options,
          mode: propBindingModes.ONE_WAY,
          raw: null
        };
    
        attr = hyphenate(name);
        // first check dynamic version
        if ((value = getBindAttr(el, attr)) === null) {
          if ((value = getBindAttr(el, attr + '.sync')) !== null) {
            prop.mode = propBindingModes.TWO_WAY;
          } else if ((value = getBindAttr(el, attr + '.once')) !== null) {
            prop.mode = propBindingModes.ONE_TIME;
          }
        }
        if (value !== null) {
          // has dynamic binding!
          prop.raw = value;
          parsed = parseDirective(value);
          value = parsed.expression;
          prop.filters = parsed.filters;
          // check binding type
          if (isLiteral(value) && !parsed.filters) {
            // for expressions containing literal numbers and
            // booleans, there's no need to setup a prop binding,
            // so we can optimize them as a one-time set.
            prop.optimizedLiteral = true;
          } else {
            prop.dynamic = true;
            // check non-settable path for two-way bindings
            if (process.env.NODE_ENV !== 'production' && prop.mode === propBindingModes.TWO_WAY && !settablePathRE.test(value)) {
              prop.mode = propBindingModes.ONE_WAY;
              warn('Cannot bind two-way prop with non-settable ' + 'parent path: ' + value);
            }
          }
          prop.parentPath = value;
    
          // warn required two-way
          if (process.env.NODE_ENV !== 'production' && options.twoWay && prop.mode !== propBindingModes.TWO_WAY) {
            warn('Prop "' + name + '" expects a two-way binding type.');
          }
        } else if ((value = getAttr(el, attr)) !== null) {
          // has literal binding!
          prop.raw = value;
        } else if (options.required) {
          // warn missing required
          process.env.NODE_ENV !== 'production' && warn('Missing required prop: ' + name);
        }
        // push prop
        props.push(prop);
      }
      return makePropsLinkFn(props);
    }
    
    /**
     * Build a function that applies props to a vm.
     *
     * @param {Array} props
     * @return {Function} propsLinkFn
     */
    
    function makePropsLinkFn(props) {
      return function propsLinkFn(vm, scope) {
        // store resolved props info
        vm._props = {};
        var i = props.length;
        var prop, path, options, value, raw;
        while (i--) {
          prop = props[i];
          raw = prop.raw;
          path = prop.path;
          options = prop.options;
          vm._props[path] = prop;
          if (raw === null) {
            // initialize absent prop
            initProp(vm, prop, getDefault(vm, options));
          } else if (prop.dynamic) {
            // dynamic prop
            if (vm._context) {
              if (prop.mode === propBindingModes.ONE_TIME) {
                // one time binding
                value = (scope || vm._context).$get(prop.parentPath);
                initProp(vm, prop, value);
              } else {
                // dynamic binding
                vm._bindDir({
                  name: 'prop',
                  def: propDef,
                  prop: prop
                }, null, null, scope); // el, host, scope
              }
            } else {
                process.env.NODE_ENV !== 'production' && warn('Cannot bind dynamic prop on a root instance' + ' with no parent: ' + prop.name + '="' + raw + '"');
              }
          } else if (prop.optimizedLiteral) {
            // optimized literal, cast it and just set once
            var stripped = stripQuotes(raw);
            value = stripped === raw ? toBoolean(toNumber(raw)) : stripped;
            initProp(vm, prop, value);
          } else {
            // string literal, but we need to cater for
            // Boolean props with no value
            value = options.type === Boolean && raw === '' ? true : raw;
            initProp(vm, prop, value);
          }
        }
      };
    }
    
    /**
     * Get the default value of a prop.
     *
     * @param {Vue} vm
     * @param {Object} options
     * @return {*}
     */
    
    function getDefault(vm, options) {
      // no default, return undefined
      if (!hasOwn(options, 'default')) {
        // absent boolean value defaults to false
        return options.type === Boolean ? false : undefined;
      }
      var def = options['default'];
      // warn against non-factory defaults for Object & Array
      if (isObject(def)) {
        process.env.NODE_ENV !== 'production' && warn('Object/Array as default prop values will be shared ' + 'across multiple instances. Use a factory function ' + 'to return the default value instead.');
      }
      // call factory function for non-Function types
      return typeof def === 'function' && options.type !== Function ? def.call(vm) : def;
    }
    
    // special binding prefixes
    var bindRE = /^v-bind:|^:/;
    var onRE = /^v-on:|^@/;
    var dirAttrRE = /^v-([^:]+)(?:$|:(.*)$)/;
    var modifierRE = /\.[^\.]+/g;
    var transitionRE = /^(v-bind:|:)?transition$/;
    
    // terminal directives
    var terminalDirectives = ['for', 'if'];
    
    // default directive priority
    var DEFAULT_PRIORITY = 1000;
    
    /**
     * Compile a template and return a reusable composite link
     * function, which recursively contains more link functions
     * inside. This top level compile function would normally
     * be called on instance root nodes, but can also be used
     * for partial compilation if the partial argument is true.
     *
     * The returned composite link function, when called, will
     * return an unlink function that tearsdown all directives
     * created during the linking phase.
     *
     * @param {Element|DocumentFragment} el
     * @param {Object} options
     * @param {Boolean} partial
     * @return {Function}
     */
    
    function compile(el, options, partial) {
      // link function for the node itself.
      var nodeLinkFn = partial || !options._asComponent ? compileNode(el, options) : null;
      // link function for the childNodes
      var childLinkFn = !(nodeLinkFn && nodeLinkFn.terminal) && el.tagName !== 'SCRIPT' && el.hasChildNodes() ? compileNodeList(el.childNodes, options) : null;
    
      /**
       * A composite linker function to be called on a already
       * compiled piece of DOM, which instantiates all directive
       * instances.
       *
       * @param {Vue} vm
       * @param {Element|DocumentFragment} el
       * @param {Vue} [host] - host vm of transcluded content
       * @param {Object} [scope] - v-for scope
       * @param {Fragment} [frag] - link context fragment
       * @return {Function|undefined}
       */
    
      return function compositeLinkFn(vm, el, host, scope, frag) {
        // cache childNodes before linking parent, fix #657
        var childNodes = toArray(el.childNodes);
        // link
        var dirs = linkAndCapture(function compositeLinkCapturer() {
          if (nodeLinkFn) nodeLinkFn(vm, el, host, scope, frag);
          if (childLinkFn) childLinkFn(vm, childNodes, host, scope, frag);
        }, vm);
        return makeUnlinkFn(vm, dirs);
      };
    }
    
    /**
     * Apply a linker to a vm/element pair and capture the
     * directives created during the process.
     *
     * @param {Function} linker
     * @param {Vue} vm
     */
    
    function linkAndCapture(linker, vm) {
      /* istanbul ignore if */
      if (process.env.NODE_ENV === 'production') {
        // reset directives before every capture in production
        // mode, so that when unlinking we don't need to splice
        // them out (which turns out to be a perf hit).
        // they are kept in development mode because they are
        // useful for Vue's own tests.
        vm._directives = [];
      }
      var originalDirCount = vm._directives.length;
      linker();
      var dirs = vm._directives.slice(originalDirCount);
      dirs.sort(directiveComparator);
      for (var i = 0, l = dirs.length; i < l; i++) {
        dirs[i]._bind();
      }
      return dirs;
    }
    
    /**
     * Directive priority sort comparator
     *
     * @param {Object} a
     * @param {Object} b
     */
    
    function directiveComparator(a, b) {
      a = a.descriptor.def.priority || DEFAULT_PRIORITY;
      b = b.descriptor.def.priority || DEFAULT_PRIORITY;
      return a > b ? -1 : a === b ? 0 : 1;
    }
    
    /**
     * Linker functions return an unlink function that
     * tearsdown all directives instances generated during
     * the process.
     *
     * We create unlink functions with only the necessary
     * information to avoid retaining additional closures.
     *
     * @param {Vue} vm
     * @param {Array} dirs
     * @param {Vue} [context]
     * @param {Array} [contextDirs]
     * @return {Function}
     */
    
    function makeUnlinkFn(vm, dirs, context, contextDirs) {
      function unlink(destroying) {
        teardownDirs(vm, dirs, destroying);
        if (context && contextDirs) {
          teardownDirs(context, contextDirs);
        }
      }
      // expose linked directives
      unlink.dirs = dirs;
      return unlink;
    }
    
    /**
     * Teardown partial linked directives.
     *
     * @param {Vue} vm
     * @param {Array} dirs
     * @param {Boolean} destroying
     */
    
    function teardownDirs(vm, dirs, destroying) {
      var i = dirs.length;
      while (i--) {
        dirs[i]._teardown();
        if (process.env.NODE_ENV !== 'production' && !destroying) {
          vm._directives.$remove(dirs[i]);
        }
      }
    }
    
    /**
     * Compile link props on an instance.
     *
     * @param {Vue} vm
     * @param {Element} el
     * @param {Object} props
     * @param {Object} [scope]
     * @return {Function}
     */
    
    function compileAndLinkProps(vm, el, props, scope) {
      var propsLinkFn = compileProps(el, props);
      var propDirs = linkAndCapture(function () {
        propsLinkFn(vm, scope);
      }, vm);
      return makeUnlinkFn(vm, propDirs);
    }
    
    /**
     * Compile the root element of an instance.
     *
     * 1. attrs on context container (context scope)
     * 2. attrs on the component template root node, if
     *    replace:true (child scope)
     *
     * If this is a fragment instance, we only need to compile 1.
     *
     * @param {Element} el
     * @param {Object} options
     * @param {Object} contextOptions
     * @return {Function}
     */
    
    function compileRoot(el, options, contextOptions) {
      var containerAttrs = options._containerAttrs;
      var replacerAttrs = options._replacerAttrs;
      var contextLinkFn, replacerLinkFn;
    
      // only need to compile other attributes for
      // non-fragment instances
      if (el.nodeType !== 11) {
        // for components, container and replacer need to be
        // compiled separately and linked in different scopes.
        if (options._asComponent) {
          // 2. container attributes
          if (containerAttrs && contextOptions) {
            contextLinkFn = compileDirectives(containerAttrs, contextOptions);
          }
          if (replacerAttrs) {
            // 3. replacer attributes
            replacerLinkFn = compileDirectives(replacerAttrs, options);
          }
        } else {
          // non-component, just compile as a normal element.
          replacerLinkFn = compileDirectives(el.attributes, options);
        }
      } else if (process.env.NODE_ENV !== 'production' && containerAttrs) {
        // warn container directives for fragment instances
        var names = containerAttrs.filter(function (attr) {
          // allow vue-loader/vueify scoped css attributes
          return attr.name.indexOf('_v-') < 0 &&
          // allow event listeners
          !onRE.test(attr.name) &&
          // allow slots
          attr.name !== 'slot';
        }).map(function (attr) {
          return '"' + attr.name + '"';
        });
        if (names.length) {
          var plural = names.length > 1;
          warn('Attribute' + (plural ? 's ' : ' ') + names.join(', ') + (plural ? ' are' : ' is') + ' ignored on component ' + '<' + options.el.tagName.toLowerCase() + '> because ' + 'the component is a fragment instance: ' + 'http://vuejs.org/guide/components.html#Fragment_Instance');
        }
      }
    
      options._containerAttrs = options._replacerAttrs = null;
      return function rootLinkFn(vm, el, scope) {
        // link context scope dirs
        var context = vm._context;
        var contextDirs;
        if (context && contextLinkFn) {
          contextDirs = linkAndCapture(function () {
            contextLinkFn(context, el, null, scope);
          }, context);
        }
    
        // link self
        var selfDirs = linkAndCapture(function () {
          if (replacerLinkFn) replacerLinkFn(vm, el);
        }, vm);
    
        // return the unlink function that tearsdown context
        // container directives.
        return makeUnlinkFn(vm, selfDirs, context, contextDirs);
      };
    }
    
    /**
     * Compile a node and return a nodeLinkFn based on the
     * node type.
     *
     * @param {Node} node
     * @param {Object} options
     * @return {Function|null}
     */
    
    function compileNode(node, options) {
      var type = node.nodeType;
      if (type === 1 && node.tagName !== 'SCRIPT') {
        return compileElement(node, options);
      } else if (type === 3 && node.data.trim()) {
        return compileTextNode(node, options);
      } else {
        return null;
      }
    }
    
    /**
     * Compile an element and return a nodeLinkFn.
     *
     * @param {Element} el
     * @param {Object} options
     * @return {Function|null}
     */
    
    function compileElement(el, options) {
      // preprocess textareas.
      // textarea treats its text content as the initial value.
      // just bind it as an attr directive for value.
      if (el.tagName === 'TEXTAREA') {
        var tokens = parseText(el.value);
        if (tokens) {
          el.setAttribute(':value', tokensToExp(tokens));
          el.value = '';
        }
      }
      var linkFn;
      var hasAttrs = el.hasAttributes();
      // check terminal directives (for & if)
      if (hasAttrs) {
        linkFn = checkTerminalDirectives(el, options);
      }
      // check element directives
      if (!linkFn) {
        linkFn = checkElementDirectives(el, options);
      }
      // check component
      if (!linkFn) {
        linkFn = checkComponent(el, options);
      }
      // normal directives
      if (!linkFn && hasAttrs) {
        linkFn = compileDirectives(el.attributes, options);
      }
      return linkFn;
    }
    
    /**
     * Compile a textNode and return a nodeLinkFn.
     *
     * @param {TextNode} node
     * @param {Object} options
     * @return {Function|null} textNodeLinkFn
     */
    
    function compileTextNode(node, options) {
      // skip marked text nodes
      if (node._skip) {
        return removeText;
      }
    
      var tokens = parseText(node.wholeText);
      if (!tokens) {
        return null;
      }
    
      // mark adjacent text nodes as skipped,
      // because we are using node.wholeText to compile
      // all adjacent text nodes together. This fixes
      // issues in IE where sometimes it splits up a single
      // text node into multiple ones.
      var next = node.nextSibling;
      while (next && next.nodeType === 3) {
        next._skip = true;
        next = next.nextSibling;
      }
    
      var frag = document.createDocumentFragment();
      var el, token;
      for (var i = 0, l = tokens.length; i < l; i++) {
        token = tokens[i];
        el = token.tag ? processTextToken(token, options) : document.createTextNode(token.value);
        frag.appendChild(el);
      }
      return makeTextNodeLinkFn(tokens, frag, options);
    }
    
    /**
     * Linker for an skipped text node.
     *
     * @param {Vue} vm
     * @param {Text} node
     */
    
    function removeText(vm, node) {
      remove(node);
    }
    
    /**
     * Process a single text token.
     *
     * @param {Object} token
     * @param {Object} options
     * @return {Node}
     */
    
    function processTextToken(token, options) {
      var el;
      if (token.oneTime) {
        el = document.createTextNode(token.value);
      } else {
        if (token.html) {
          el = document.createComment('v-html');
          setTokenType('html');
        } else {
          // IE will clean up empty textNodes during
          // frag.cloneNode(true), so we have to give it
          // something here...
          el = document.createTextNode(' ');
          setTokenType('text');
        }
      }
      function setTokenType(type) {
        if (token.descriptor) return;
        var parsed = parseDirective(token.value);
        token.descriptor = {
          name: type,
          def: publicDirectives[type],
          expression: parsed.expression,
          filters: parsed.filters
        };
      }
      return el;
    }
    
    /**
     * Build a function that processes a textNode.
     *
     * @param {Array<Object>} tokens
     * @param {DocumentFragment} frag
     */
    
    function makeTextNodeLinkFn(tokens, frag) {
      return function textNodeLinkFn(vm, el, host, scope) {
        var fragClone = frag.cloneNode(true);
        var childNodes = toArray(fragClone.childNodes);
        var token, value, node;
        for (var i = 0, l = tokens.length; i < l; i++) {
          token = tokens[i];
          value = token.value;
          if (token.tag) {
            node = childNodes[i];
            if (token.oneTime) {
              value = (scope || vm).$eval(value);
              if (token.html) {
                replace(node, parseTemplate(value, true));
              } else {
                node.data = value;
              }
            } else {
              vm._bindDir(token.descriptor, node, host, scope);
            }
          }
        }
        replace(el, fragClone);
      };
    }
    
    /**
     * Compile a node list and return a childLinkFn.
     *
     * @param {NodeList} nodeList
     * @param {Object} options
     * @return {Function|undefined}
     */
    
    function compileNodeList(nodeList, options) {
      var linkFns = [];
      var nodeLinkFn, childLinkFn, node;
      for (var i = 0, l = nodeList.length; i < l; i++) {
        node = nodeList[i];
        nodeLinkFn = compileNode(node, options);
        childLinkFn = !(nodeLinkFn && nodeLinkFn.terminal) && node.tagName !== 'SCRIPT' && node.hasChildNodes() ? compileNodeList(node.childNodes, options) : null;
        linkFns.push(nodeLinkFn, childLinkFn);
      }
      return linkFns.length ? makeChildLinkFn(linkFns) : null;
    }
    
    /**
     * Make a child link function for a node's childNodes.
     *
     * @param {Array<Function>} linkFns
     * @return {Function} childLinkFn
     */
    
    function makeChildLinkFn(linkFns) {
      return function childLinkFn(vm, nodes, host, scope, frag) {
        var node, nodeLinkFn, childrenLinkFn;
        for (var i = 0, n = 0, l = linkFns.length; i < l; n++) {
          node = nodes[n];
          nodeLinkFn = linkFns[i++];
          childrenLinkFn = linkFns[i++];
          // cache childNodes before linking parent, fix #657
          var childNodes = toArray(node.childNodes);
          if (nodeLinkFn) {
            nodeLinkFn(vm, node, host, scope, frag);
          }
          if (childrenLinkFn) {
            childrenLinkFn(vm, childNodes, host, scope, frag);
          }
        }
      };
    }
    
    /**
     * Check for element directives (custom elements that should
     * be resovled as terminal directives).
     *
     * @param {Element} el
     * @param {Object} options
     */
    
    function checkElementDirectives(el, options) {
      var tag = el.tagName.toLowerCase();
      if (commonTagRE.test(tag)) return;
      // special case: give named slot a higher priority
      // than unnamed slots
      if (tag === 'slot' && hasBindAttr(el, 'name')) {
        tag = '_namedSlot';
      }
      var def = resolveAsset(options, 'elementDirectives', tag);
      if (def) {
        return makeTerminalNodeLinkFn(el, tag, '', options, def);
      }
    }
    
    /**
     * Check if an element is a component. If yes, return
     * a component link function.
     *
     * @param {Element} el
     * @param {Object} options
     * @return {Function|undefined}
     */
    
    function checkComponent(el, options) {
      var component = checkComponentAttr(el, options);
      if (component) {
        var ref = findRef(el);
        var descriptor = {
          name: 'component',
          ref: ref,
          expression: component.id,
          def: internalDirectives.component,
          modifiers: {
            literal: !component.dynamic
          }
        };
        var componentLinkFn = function componentLinkFn(vm, el, host, scope, frag) {
          if (ref) {
            defineReactive((scope || vm).$refs, ref, null);
          }
          vm._bindDir(descriptor, el, host, scope, frag);
        };
        componentLinkFn.terminal = true;
        return componentLinkFn;
      }
    }
    
    /**
     * Check an element for terminal directives in fixed order.
     * If it finds one, return a terminal link function.
     *
     * @param {Element} el
     * @param {Object} options
     * @return {Function} terminalLinkFn
     */
    
    function checkTerminalDirectives(el, options) {
      // skip v-pre
      if (getAttr(el, 'v-pre') !== null) {
        return skip;
      }
      // skip v-else block, but only if following v-if
      if (el.hasAttribute('v-else')) {
        var prev = el.previousElementSibling;
        if (prev && prev.hasAttribute('v-if')) {
          return skip;
        }
      }
      var value, dirName;
      for (var i = 0, l = terminalDirectives.length; i < l; i++) {
        dirName = terminalDirectives[i];
        value = el.getAttribute('v-' + dirName);
        if (value != null) {
          return makeTerminalNodeLinkFn(el, dirName, value, options);
        }
      }
    }
    
    function skip() {}
    skip.terminal = true;
    
    /**
     * Build a node link function for a terminal directive.
     * A terminal link function terminates the current
     * compilation recursion and handles compilation of the
     * subtree in the directive.
     *
     * @param {Element} el
     * @param {String} dirName
     * @param {String} value
     * @param {Object} options
     * @param {Object} [def]
     * @return {Function} terminalLinkFn
     */
    
    function makeTerminalNodeLinkFn(el, dirName, value, options, def) {
      var parsed = parseDirective(value);
      var descriptor = {
        name: dirName,
        expression: parsed.expression,
        filters: parsed.filters,
        raw: value,
        // either an element directive, or if/for
        def: def || publicDirectives[dirName]
      };
      // check ref for v-for and router-view
      if (dirName === 'for' || dirName === 'router-view') {
        descriptor.ref = findRef(el);
      }
      var fn = function terminalNodeLinkFn(vm, el, host, scope, frag) {
        if (descriptor.ref) {
          defineReactive((scope || vm).$refs, descriptor.ref, null);
        }
        vm._bindDir(descriptor, el, host, scope, frag);
      };
      fn.terminal = true;
      return fn;
    }
    
    /**
     * Compile the directives on an element and return a linker.
     *
     * @param {Array|NamedNodeMap} attrs
     * @param {Object} options
     * @return {Function}
     */
    
    function compileDirectives(attrs, options) {
      var i = attrs.length;
      var dirs = [];
      var attr, name, value, rawName, rawValue, dirName, arg, modifiers, dirDef, tokens, matched;
      while (i--) {
        attr = attrs[i];
        name = rawName = attr.name;
        value = rawValue = attr.value;
        tokens = parseText(value);
        // reset arg
        arg = null;
        // check modifiers
        modifiers = parseModifiers(name);
        name = name.replace(modifierRE, '');
    
        // attribute interpolations
        if (tokens) {
          value = tokensToExp(tokens);
          arg = name;
          pushDir('bind', publicDirectives.bind, tokens);
          // warn against mixing mustaches with v-bind
          if (process.env.NODE_ENV !== 'production') {
            if (name === 'class' && Array.prototype.some.call(attrs, function (attr) {
              return attr.name === ':class' || attr.name === 'v-bind:class';
            })) {
              warn('class="' + rawValue + '": Do not mix mustache interpolation ' + 'and v-bind for "class" on the same element. Use one or the other.');
            }
          }
        } else
    
          // special attribute: transition
          if (transitionRE.test(name)) {
            modifiers.literal = !bindRE.test(name);
            pushDir('transition', internalDirectives.transition);
          } else
    
            // event handlers
            if (onRE.test(name)) {
              arg = name.replace(onRE, '');
              pushDir('on', publicDirectives.on);
            } else
    
              // attribute bindings
              if (bindRE.test(name)) {
                dirName = name.replace(bindRE, '');
                if (dirName === 'style' || dirName === 'class') {
                  pushDir(dirName, internalDirectives[dirName]);
                } else {
                  arg = dirName;
                  pushDir('bind', publicDirectives.bind);
                }
              } else
    
                // normal directives
                if (matched = name.match(dirAttrRE)) {
                  dirName = matched[1];
                  arg = matched[2];
    
                  // skip v-else (when used with v-show)
                  if (dirName === 'else') {
                    continue;
                  }
    
                  dirDef = resolveAsset(options, 'directives', dirName);
    
                  if (process.env.NODE_ENV !== 'production') {
                    assertAsset(dirDef, 'directive', dirName);
                  }
    
                  if (dirDef) {
                    pushDir(dirName, dirDef);
                  }
                }
      }
    
      /**
       * Push a directive.
       *
       * @param {String} dirName
       * @param {Object|Function} def
       * @param {Array} [interpTokens]
       */
    
      function pushDir(dirName, def, interpTokens) {
        var hasOneTimeToken = interpTokens && hasOneTime(interpTokens);
        var parsed = !hasOneTimeToken && parseDirective(value);
        dirs.push({
          name: dirName,
          attr: rawName,
          raw: rawValue,
          def: def,
          arg: arg,
          modifiers: modifiers,
          // conversion from interpolation strings with one-time token
          // to expression is differed until directive bind time so that we
          // have access to the actual vm context for one-time bindings.
          expression: parsed && parsed.expression,
          filters: parsed && parsed.filters,
          interp: interpTokens,
          hasOneTime: hasOneTimeToken
        });
      }
    
      if (dirs.length) {
        return makeNodeLinkFn(dirs);
      }
    }
    
    /**
     * Parse modifiers from directive attribute name.
     *
     * @param {String} name
     * @return {Object}
     */
    
    function parseModifiers(name) {
      var res = Object.create(null);
      var match = name.match(modifierRE);
      if (match) {
        var i = match.length;
        while (i--) {
          res[match[i].slice(1)] = true;
        }
      }
      return res;
    }
    
    /**
     * Build a link function for all directives on a single node.
     *
     * @param {Array} directives
     * @return {Function} directivesLinkFn
     */
    
    function makeNodeLinkFn(directives) {
      return function nodeLinkFn(vm, el, host, scope, frag) {
        // reverse apply because it's sorted low to high
        var i = directives.length;
        while (i--) {
          vm._bindDir(directives[i], el, host, scope, frag);
        }
      };
    }
    
    /**
     * Check if an interpolation string contains one-time tokens.
     *
     * @param {Array} tokens
     * @return {Boolean}
     */
    
    function hasOneTime(tokens) {
      var i = tokens.length;
      while (i--) {
        if (tokens[i].oneTime) return true;
      }
    }
    
    var specialCharRE = /[^\w\-:\.]/;
    
    /**
     * Process an element or a DocumentFragment based on a
     * instance option object. This allows us to transclude
     * a template node/fragment before the instance is created,
     * so the processed fragment can then be cloned and reused
     * in v-for.
     *
     * @param {Element} el
     * @param {Object} options
     * @return {Element|DocumentFragment}
     */
    
    function transclude(el, options) {
      // extract container attributes to pass them down
      // to compiler, because they need to be compiled in
      // parent scope. we are mutating the options object here
      // assuming the same object will be used for compile
      // right after this.
      if (options) {
        options._containerAttrs = extractAttrs(el);
      }
      // for template tags, what we want is its content as
      // a documentFragment (for fragment instances)
      if (isTemplate(el)) {
        el = parseTemplate(el);
      }
      if (options) {
        if (options._asComponent && !options.template) {
          options.template = '<slot></slot>';
        }
        if (options.template) {
          options._content = extractContent(el);
          el = transcludeTemplate(el, options);
        }
      }
      if (el instanceof DocumentFragment) {
        // anchors for fragment instance
        // passing in `persist: true` to avoid them being
        // discarded by IE during template cloning
        prepend(createAnchor('v-start', true), el);
        el.appendChild(createAnchor('v-end', true));
      }
      return el;
    }
    
    /**
     * Process the template option.
     * If the replace option is true this will swap the $el.
     *
     * @param {Element} el
     * @param {Object} options
     * @return {Element|DocumentFragment}
     */
    
    function transcludeTemplate(el, options) {
      var template = options.template;
      var frag = parseTemplate(template, true);
      if (frag) {
        var replacer = frag.firstChild;
        var tag = replacer.tagName && replacer.tagName.toLowerCase();
        if (options.replace) {
          /* istanbul ignore if */
          if (el === document.body) {
            process.env.NODE_ENV !== 'production' && warn('You are mounting an instance with a template to ' + '<body>. This will replace <body> entirely. You ' + 'should probably use `replace: false` here.');
          }
          // there are many cases where the instance must
          // become a fragment instance: basically anything that
          // can create more than 1 root nodes.
          if (
          // multi-children template
          frag.childNodes.length > 1 ||
          // non-element template
          replacer.nodeType !== 1 ||
          // single nested component
          tag === 'component' || resolveAsset(options, 'components', tag) || hasBindAttr(replacer, 'is') ||
          // element directive
          resolveAsset(options, 'elementDirectives', tag) ||
          // for block
          replacer.hasAttribute('v-for') ||
          // if block
          replacer.hasAttribute('v-if')) {
            return frag;
          } else {
            options._replacerAttrs = extractAttrs(replacer);
            mergeAttrs(el, replacer);
            return replacer;
          }
        } else {
          el.appendChild(frag);
          return el;
        }
      } else {
        process.env.NODE_ENV !== 'production' && warn('Invalid template option: ' + template);
      }
    }
    
    /**
     * Helper to extract a component container's attributes
     * into a plain object array.
     *
     * @param {Element} el
     * @return {Array}
     */
    
    function extractAttrs(el) {
      if (el.nodeType === 1 && el.hasAttributes()) {
        return toArray(el.attributes);
      }
    }
    
    /**
     * Merge the attributes of two elements, and make sure
     * the class names are merged properly.
     *
     * @param {Element} from
     * @param {Element} to
     */
    
    function mergeAttrs(from, to) {
      var attrs = from.attributes;
      var i = attrs.length;
      var name, value;
      while (i--) {
        name = attrs[i].name;
        value = attrs[i].value;
        if (!to.hasAttribute(name) && !specialCharRE.test(name)) {
          to.setAttribute(name, value);
        } else if (name === 'class' && !parseText(value)) {
          value.split(/\s+/).forEach(function (cls) {
            addClass(to, cls);
          });
        }
      }
    }
    
    var compiler = Object.freeze({
    	compile: compile,
    	compileAndLinkProps: compileAndLinkProps,
    	compileRoot: compileRoot,
    	terminalDirectives: terminalDirectives,
    	transclude: transclude
    });
    
    function stateMixin (Vue) {
    
      /**
       * Accessor for `$data` property, since setting $data
       * requires observing the new object and updating
       * proxied properties.
       */
    
      Object.defineProperty(Vue.prototype, '$data', {
        get: function get() {
          return this._data;
        },
        set: function set(newData) {
          if (newData !== this._data) {
            this._setData(newData);
          }
        }
      });
    
      /**
       * Setup the scope of an instance, which contains:
       * - observed data
       * - computed properties
       * - user methods
       * - meta properties
       */
    
      Vue.prototype._initState = function () {
        this._initProps();
        this._initMeta();
        this._initMethods();
        this._initData();
        this._initComputed();
      };
    
      /**
       * Initialize props.
       */
    
      Vue.prototype._initProps = function () {
        var options = this.$options;
        var el = options.el;
        var props = options.props;
        if (props && !el) {
          process.env.NODE_ENV !== 'production' && warn('Props will not be compiled if no `el` option is ' + 'provided at instantiation.');
        }
        // make sure to convert string selectors into element now
        el = options.el = query(el);
        this._propsUnlinkFn = el && el.nodeType === 1 && props
        // props must be linked in proper scope if inside v-for
        ? compileAndLinkProps(this, el, props, this._scope) : null;
      };
    
      /**
       * Initialize the data.
       */
    
      Vue.prototype._initData = function () {
        var propsData = this._data;
        var optionsDataFn = this.$options.data;
        var optionsData = optionsDataFn && optionsDataFn();
        var runtimeData;
        if (process.env.NODE_ENV !== 'production') {
          runtimeData = (typeof this._runtimeData === 'function' ? this._runtimeData() : this._runtimeData) || {};
          this._runtimeData = null;
        }
        if (optionsData) {
          this._data = optionsData;
          for (var prop in propsData) {
            if (process.env.NODE_ENV !== 'production' && hasOwn(optionsData, prop) && !hasOwn(runtimeData, prop)) {
              warn('Data field "' + prop + '" is already defined ' + 'as a prop. Use prop default value instead.');
            }
            if (this._props[prop].raw !== null || !hasOwn(optionsData, prop)) {
              set(optionsData, prop, propsData[prop]);
            }
          }
        }
        var data = this._data;
        // proxy data on instance
        var keys = Object.keys(data);
        var i, key;
        i = keys.length;
        while (i--) {
          key = keys[i];
          this._proxy(key);
        }
        // observe data
        observe(data, this);
      };
    
      /**
       * Swap the instance's $data. Called in $data's setter.
       *
       * @param {Object} newData
       */
    
      Vue.prototype._setData = function (newData) {
        newData = newData || {};
        var oldData = this._data;
        this._data = newData;
        var keys, key, i;
        // unproxy keys not present in new data
        keys = Object.keys(oldData);
        i = keys.length;
        while (i--) {
          key = keys[i];
          if (!(key in newData)) {
            this._unproxy(key);
          }
        }
        // proxy keys not already proxied,
        // and trigger change for changed values
        keys = Object.keys(newData);
        i = keys.length;
        while (i--) {
          key = keys[i];
          if (!hasOwn(this, key)) {
            // new property
            this._proxy(key);
          }
        }
        oldData.__ob__.removeVm(this);
        observe(newData, this);
        this._digest();
      };
    
      /**
       * Proxy a property, so that
       * vm.prop === vm._data.prop
       *
       * @param {String} key
       */
    
      Vue.prototype._proxy = function (key) {
        if (!isReserved(key)) {
          // need to store ref to self here
          // because these getter/setters might
          // be called by child scopes via
          // prototype inheritance.
          var self = this;
          Object.defineProperty(self, key, {
            configurable: true,
            enumerable: true,
            get: function proxyGetter() {
              return self._data[key];
            },
            set: function proxySetter(val) {
              self._data[key] = val;
            }
          });
        }
      };
    
      /**
       * Unproxy a property.
       *
       * @param {String} key
       */
    
      Vue.prototype._unproxy = function (key) {
        if (!isReserved(key)) {
          delete this[key];
        }
      };
    
      /**
       * Force update on every watcher in scope.
       */
    
      Vue.prototype._digest = function () {
        for (var i = 0, l = this._watchers.length; i < l; i++) {
          this._watchers[i].update(true); // shallow updates
        }
      };
    
      /**
       * Setup computed properties. They are essentially
       * special getter/setters
       */
    
      function noop() {}
      Vue.prototype._initComputed = function () {
        var computed = this.$options.computed;
        if (computed) {
          for (var key in computed) {
            var userDef = computed[key];
            var def = {
              enumerable: true,
              configurable: true
            };
            if (typeof userDef === 'function') {
              def.get = makeComputedGetter(userDef, this);
              def.set = noop;
            } else {
              def.get = userDef.get ? userDef.cache !== false ? makeComputedGetter(userDef.get, this) : bind$1(userDef.get, this) : noop;
              def.set = userDef.set ? bind$1(userDef.set, this) : noop;
            }
            Object.defineProperty(this, key, def);
          }
        }
      };
    
      function makeComputedGetter(getter, owner) {
        var watcher = new Watcher(owner, getter, null, {
          lazy: true
        });
        return function computedGetter() {
          if (watcher.dirty) {
            watcher.evaluate();
          }
          if (Dep.target) {
            watcher.depend();
          }
          return watcher.value;
        };
      }
    
      /**
       * Setup instance methods. Methods must be bound to the
       * instance since they might be passed down as a prop to
       * child components.
       */
    
      Vue.prototype._initMethods = function () {
        var methods = this.$options.methods;
        if (methods) {
          for (var key in methods) {
            this[key] = bind$1(methods[key], this);
          }
        }
      };
    
      /**
       * Initialize meta information like $index, $key & $value.
       */
    
      Vue.prototype._initMeta = function () {
        var metas = this.$options._meta;
        if (metas) {
          for (var key in metas) {
            defineReactive(this, key, metas[key]);
          }
        }
      };
    }
    
    var eventRE = /^v-on:|^@/;
    
    function eventsMixin (Vue) {
    
      /**
       * Setup the instance's option events & watchers.
       * If the value is a string, we pull it from the
       * instance's methods by name.
       */
    
      Vue.prototype._initEvents = function () {
        var options = this.$options;
        if (options._asComponent) {
          registerComponentEvents(this, options.el);
        }
        registerCallbacks(this, '$on', options.events);
        registerCallbacks(this, '$watch', options.watch);
      };
    
      /**
       * Register v-on events on a child component
       *
       * @param {Vue} vm
       * @param {Element} el
       */
    
      function registerComponentEvents(vm, el) {
        var attrs = el.attributes;
        var name, handler;
        for (var i = 0, l = attrs.length; i < l; i++) {
          name = attrs[i].name;
          if (eventRE.test(name)) {
            name = name.replace(eventRE, '');
            handler = (vm._scope || vm._context).$eval(attrs[i].value, true);
            handler._fromParent = true;
            vm.$on(name.replace(eventRE), handler);
          }
        }
      }
    
      /**
       * Register callbacks for option events and watchers.
       *
       * @param {Vue} vm
       * @param {String} action
       * @param {Object} hash
       */
    
      function registerCallbacks(vm, action, hash) {
        if (!hash) return;
        var handlers, key, i, j;
        for (key in hash) {
          handlers = hash[key];
          if (isArray(handlers)) {
            for (i = 0, j = handlers.length; i < j; i++) {
              register(vm, action, key, handlers[i]);
            }
          } else {
            register(vm, action, key, handlers);
          }
        }
      }
    
      /**
       * Helper to register an event/watch callback.
       *
       * @param {Vue} vm
       * @param {String} action
       * @param {String} key
       * @param {Function|String|Object} handler
       * @param {Object} [options]
       */
    
      function register(vm, action, key, handler, options) {
        var type = typeof handler;
        if (type === 'function') {
          vm[action](key, handler, options);
        } else if (type === 'string') {
          var methods = vm.$options.methods;
          var method = methods && methods[handler];
          if (method) {
            vm[action](key, method, options);
          } else {
            process.env.NODE_ENV !== 'production' && warn('Unknown method: "' + handler + '" when ' + 'registering callback for ' + action + ': "' + key + '".');
          }
        } else if (handler && type === 'object') {
          register(vm, action, key, handler.handler, handler);
        }
      }
    
      /**
       * Setup recursive attached/detached calls
       */
    
      Vue.prototype._initDOMHooks = function () {
        this.$on('hook:attached', onAttached);
        this.$on('hook:detached', onDetached);
      };
    
      /**
       * Callback to recursively call attached hook on children
       */
    
      function onAttached() {
        if (!this._isAttached) {
          this._isAttached = true;
          this.$children.forEach(callAttach);
        }
      }
    
      /**
       * Iterator to call attached hook
       *
       * @param {Vue} child
       */
    
      function callAttach(child) {
        if (!child._isAttached && inDoc(child.$el)) {
          child._callHook('attached');
        }
      }
    
      /**
       * Callback to recursively call detached hook on children
       */
    
      function onDetached() {
        if (this._isAttached) {
          this._isAttached = false;
          this.$children.forEach(callDetach);
        }
      }
    
      /**
       * Iterator to call detached hook
       *
       * @param {Vue} child
       */
    
      function callDetach(child) {
        if (child._isAttached && !inDoc(child.$el)) {
          child._callHook('detached');
        }
      }
    
      /**
       * Trigger all handlers for a hook
       *
       * @param {String} hook
       */
    
      Vue.prototype._callHook = function (hook) {
        this.$emit('pre-hook:' + hook);
        var handlers = this.$options[hook];
        if (handlers) {
          for (var i = 0, j = handlers.length; i < j; i++) {
            handlers[i].call(this);
          }
        }
        this.$emit('hook:' + hook);
      };
    }
    
    function noop() {}
    
    /**
     * A directive links a DOM element with a piece of data,
     * which is the result of evaluating an expression.
     * It registers a watcher with the expression and calls
     * the DOM update function when a change is triggered.
     *
     * @param {String} name
     * @param {Node} el
     * @param {Vue} vm
     * @param {Object} descriptor
     *                 - {String} name
     *                 - {Object} def
     *                 - {String} expression
     *                 - {Array<Object>} [filters]
     *                 - {Boolean} literal
     *                 - {String} attr
     *                 - {String} raw
     * @param {Object} def - directive definition object
     * @param {Vue} [host] - transclusion host component
     * @param {Object} [scope] - v-for scope
     * @param {Fragment} [frag] - owner fragment
     * @constructor
     */
    function Directive(descriptor, vm, el, host, scope, frag) {
      this.vm = vm;
      this.el = el;
      // copy descriptor properties
      this.descriptor = descriptor;
      this.name = descriptor.name;
      this.expression = descriptor.expression;
      this.arg = descriptor.arg;
      this.modifiers = descriptor.modifiers;
      this.filters = descriptor.filters;
      this.literal = this.modifiers && this.modifiers.literal;
      // private
      this._locked = false;
      this._bound = false;
      this._listeners = null;
      // link context
      this._host = host;
      this._scope = scope;
      this._frag = frag;
      // store directives on node in dev mode
      if (process.env.NODE_ENV !== 'production' && this.el) {
        this.el._vue_directives = this.el._vue_directives || [];
        this.el._vue_directives.push(this);
      }
    }
    
    /**
     * Initialize the directive, mixin definition properties,
     * setup the watcher, call definition bind() and update()
     * if present.
     *
     * @param {Object} def
     */
    
    Directive.prototype._bind = function () {
      var name = this.name;
      var descriptor = this.descriptor;
    
      // remove attribute
      if ((name !== 'cloak' || this.vm._isCompiled) && this.el && this.el.removeAttribute) {
        var attr = descriptor.attr || 'v-' + name;
        this.el.removeAttribute(attr);
      }
    
      // copy def properties
      var def = descriptor.def;
      if (typeof def === 'function') {
        this.update = def;
      } else {
        extend(this, def);
      }
    
      // setup directive params
      this._setupParams();
    
      // initial bind
      if (this.bind) {
        this.bind();
      }
      this._bound = true;
    
      if (this.literal) {
        this.update && this.update(descriptor.raw);
      } else if ((this.expression || this.modifiers) && (this.update || this.twoWay) && !this._checkStatement()) {
        // wrapped updater for context
        var dir = this;
        if (this.update) {
          this._update = function (val, oldVal) {
            if (!dir._locked) {
              dir.update(val, oldVal);
            }
          };
        } else {
          this._update = noop;
        }
        var preProcess = this._preProcess ? bind$1(this._preProcess, this) : null;
        var postProcess = this._postProcess ? bind$1(this._postProcess, this) : null;
        var watcher = this._watcher = new Watcher(this.vm, this.expression, this._update, // callback
        {
          filters: this.filters,
          twoWay: this.twoWay,
          deep: this.deep,
          preProcess: preProcess,
          postProcess: postProcess,
          scope: this._scope
        });
        // v-model with inital inline value need to sync back to
        // model instead of update to DOM on init. They would
        // set the afterBind hook to indicate that.
        if (this.afterBind) {
          this.afterBind();
        } else if (this.update) {
          this.update(watcher.value);
        }
      }
    };
    
    /**
     * Setup all param attributes, e.g. track-by,
     * transition-mode, etc...
     */
    
    Directive.prototype._setupParams = function () {
      if (!this.params) {
        return;
      }
      var params = this.params;
      // swap the params array with a fresh object.
      this.params = Object.create(null);
      var i = params.length;
      var key, val, mappedKey;
      while (i--) {
        key = params[i];
        mappedKey = camelize(key);
        val = getBindAttr(this.el, key);
        if (val != null) {
          // dynamic
          this._setupParamWatcher(mappedKey, val);
        } else {
          // static
          val = getAttr(this.el, key);
          if (val != null) {
            this.params[mappedKey] = val === '' ? true : val;
          }
        }
      }
    };
    
    /**
     * Setup a watcher for a dynamic param.
     *
     * @param {String} key
     * @param {String} expression
     */
    
    Directive.prototype._setupParamWatcher = function (key, expression) {
      var self = this;
      var called = false;
      var unwatch = (this._scope || this.vm).$watch(expression, function (val, oldVal) {
        self.params[key] = val;
        // since we are in immediate mode,
        // only call the param change callbacks if this is not the first update.
        if (called) {
          var cb = self.paramWatchers && self.paramWatchers[key];
          if (cb) {
            cb.call(self, val, oldVal);
          }
        } else {
          called = true;
        }
      }, {
        immediate: true,
        user: false
      });(this._paramUnwatchFns || (this._paramUnwatchFns = [])).push(unwatch);
    };
    
    /**
     * Check if the directive is a function caller
     * and if the expression is a callable one. If both true,
     * we wrap up the expression and use it as the event
     * handler.
     *
     * e.g. on-click="a++"
     *
     * @return {Boolean}
     */
    
    Directive.prototype._checkStatement = function () {
      var expression = this.expression;
      if (expression && this.acceptStatement && !isSimplePath(expression)) {
        var fn = parseExpression(expression).get;
        var scope = this._scope || this.vm;
        var handler = function handler(e) {
          scope.$event = e;
          fn.call(scope, scope);
          scope.$event = null;
        };
        if (this.filters) {
          handler = scope._applyFilters(handler, null, this.filters);
        }
        this.update(handler);
        return true;
      }
    };
    
    /**
     * Set the corresponding value with the setter.
     * This should only be used in two-way directives
     * e.g. v-model.
     *
     * @param {*} value
     * @public
     */
    
    Directive.prototype.set = function (value) {
      /* istanbul ignore else */
      if (this.twoWay) {
        this._withLock(function () {
          this._watcher.set(value);
        });
      } else if (process.env.NODE_ENV !== 'production') {
        warn('Directive.set() can only be used inside twoWay' + 'directives.');
      }
    };
    
    /**
     * Execute a function while preventing that function from
     * triggering updates on this directive instance.
     *
     * @param {Function} fn
     */
    
    Directive.prototype._withLock = function (fn) {
      var self = this;
      self._locked = true;
      fn.call(self);
      nextTick(function () {
        self._locked = false;
      });
    };
    
    /**
     * Convenience method that attaches a DOM event listener
     * to the directive element and autometically tears it down
     * during unbind.
     *
     * @param {String} event
     * @param {Function} handler
     * @param {Boolean} [useCapture]
     */
    
    Directive.prototype.on = function (event, handler, useCapture) {
      on$1(this.el, event, handler, useCapture);(this._listeners || (this._listeners = [])).push([event, handler]);
    };
    
    /**
     * Teardown the watcher and call unbind.
     */
    
    Directive.prototype._teardown = function () {
      if (this._bound) {
        this._bound = false;
        if (this.unbind) {
          this.unbind();
        }
        if (this._watcher) {
          this._watcher.teardown();
        }
        var listeners = this._listeners;
        var i;
        if (listeners) {
          i = listeners.length;
          while (i--) {
            off(this.el, listeners[i][0], listeners[i][1]);
          }
        }
        var unwatchFns = this._paramUnwatchFns;
        if (unwatchFns) {
          i = unwatchFns.length;
          while (i--) {
            unwatchFns[i]();
          }
        }
        if (process.env.NODE_ENV !== 'production' && this.el) {
          this.el._vue_directives.$remove(this);
        }
        this.vm = this.el = this._watcher = this._listeners = null;
      }
    };
    
    function lifecycleMixin (Vue) {
    
      /**
       * Update v-ref for component.
       *
       * @param {Boolean} remove
       */
    
      Vue.prototype._updateRef = function (remove) {
        var ref = this.$options._ref;
        if (ref) {
          var refs = (this._scope || this._context).$refs;
          if (remove) {
            if (refs[ref] === this) {
              refs[ref] = null;
            }
          } else {
            refs[ref] = this;
          }
        }
      };
    
      /**
       * Transclude, compile and link element.
       *
       * If a pre-compiled linker is available, that means the
       * passed in element will be pre-transcluded and compiled
       * as well - all we need to do is to call the linker.
       *
       * Otherwise we need to call transclude/compile/link here.
       *
       * @param {Element} el
       */
    
      Vue.prototype._compile = function (el) {
        var options = this.$options;
    
        // transclude and init element
        // transclude can potentially replace original
        // so we need to keep reference; this step also injects
        // the template and caches the original attributes
        // on the container node and replacer node.
        var original = el;
        el = transclude(el, options);
        this._initElement(el);
    
        // handle v-pre on root node (#2026)
        if (el.nodeType === 1 && getAttr(el, 'v-pre') !== null) {
          return;
        }
    
        // root is always compiled per-instance, because
        // container attrs and props can be different every time.
        var contextOptions = this._context && this._context.$options;
        var rootLinker = compileRoot(el, options, contextOptions);
    
        // compile and link the rest
        var contentLinkFn;
        var ctor = this.constructor;
        // component compilation can be cached
        // as long as it's not using inline-template
        if (options._linkerCachable) {
          contentLinkFn = ctor.linker;
          if (!contentLinkFn) {
            contentLinkFn = ctor.linker = compile(el, options);
          }
        }
    
        // link phase
        // make sure to link root with prop scope!
        var rootUnlinkFn = rootLinker(this, el, this._scope);
        var contentUnlinkFn = contentLinkFn ? contentLinkFn(this, el) : compile(el, options)(this, el);
    
        // register composite unlink function
        // to be called during instance destruction
        this._unlinkFn = function () {
          rootUnlinkFn();
          // passing destroying: true to avoid searching and
          // splicing the directives
          contentUnlinkFn(true);
        };
    
        // finally replace original
        if (options.replace) {
          replace(original, el);
        }
    
        this._isCompiled = true;
        this._callHook('compiled');
      };
    
      /**
       * Initialize instance element. Called in the public
       * $mount() method.
       *
       * @param {Element} el
       */
    
      Vue.prototype._initElement = function (el) {
        if (el instanceof DocumentFragment) {
          this._isFragment = true;
          this.$el = this._fragmentStart = el.firstChild;
          this._fragmentEnd = el.lastChild;
          // set persisted text anchors to empty
          if (this._fragmentStart.nodeType === 3) {
            this._fragmentStart.data = this._fragmentEnd.data = '';
          }
          this._fragment = el;
        } else {
          this.$el = el;
        }
        this.$el.__vue__ = this;
        this._callHook('beforeCompile');
      };
    
      /**
       * Create and bind a directive to an element.
       *
       * @param {String} name - directive name
       * @param {Node} node   - target node
       * @param {Object} desc - parsed directive descriptor
       * @param {Object} def  - directive definition object
       * @param {Vue} [host] - transclusion host component
       * @param {Object} [scope] - v-for scope
       * @param {Fragment} [frag] - owner fragment
       */
    
      Vue.prototype._bindDir = function (descriptor, node, host, scope, frag) {
        this._directives.push(new Directive(descriptor, this, node, host, scope, frag));
      };
    
      /**
       * Teardown an instance, unobserves the data, unbind all the
       * directives, turn off all the event listeners, etc.
       *
       * @param {Boolean} remove - whether to remove the DOM node.
       * @param {Boolean} deferCleanup - if true, defer cleanup to
       *                                 be called later
       */
    
      Vue.prototype._destroy = function (remove, deferCleanup) {
        if (this._isBeingDestroyed) {
          if (!deferCleanup) {
            this._cleanup();
          }
          return;
        }
    
        var destroyReady;
        var pendingRemoval;
    
        var self = this;
        // Cleanup should be called either synchronously or asynchronoysly as
        // callback of this.$remove(), or if remove and deferCleanup are false.
        // In any case it should be called after all other removing, unbinding and
        // turning of is done
        var cleanupIfPossible = function cleanupIfPossible() {
          if (destroyReady && !pendingRemoval && !deferCleanup) {
            self._cleanup();
          }
        };
    
        // remove DOM element
        if (remove && this.$el) {
          pendingRemoval = true;
          this.$remove(function () {
            pendingRemoval = false;
            cleanupIfPossible();
          });
        }
    
        this._callHook('beforeDestroy');
        this._isBeingDestroyed = true;
        var i;
        // remove self from parent. only necessary
        // if parent is not being destroyed as well.
        var parent = this.$parent;
        if (parent && !parent._isBeingDestroyed) {
          parent.$children.$remove(this);
          // unregister ref (remove: true)
          this._updateRef(true);
        }
        // destroy all children.
        i = this.$children.length;
        while (i--) {
          this.$children[i].$destroy();
        }
        // teardown props
        if (this._propsUnlinkFn) {
          this._propsUnlinkFn();
        }
        // teardown all directives. this also tearsdown all
        // directive-owned watchers.
        if (this._unlinkFn) {
          this._unlinkFn();
        }
        i = this._watchers.length;
        while (i--) {
          this._watchers[i].teardown();
        }
        // remove reference to self on $el
        if (this.$el) {
          this.$el.__vue__ = null;
        }
    
        destroyReady = true;
        cleanupIfPossible();
      };
    
      /**
       * Clean up to ensure garbage collection.
       * This is called after the leave transition if there
       * is any.
       */
    
      Vue.prototype._cleanup = function () {
        if (this._isDestroyed) {
          return;
        }
        // remove self from owner fragment
        // do it in cleanup so that we can call $destroy with
        // defer right when a fragment is about to be removed.
        if (this._frag) {
          this._frag.children.$remove(this);
        }
        // remove reference from data ob
        // frozen object may not have observer.
        if (this._data.__ob__) {
          this._data.__ob__.removeVm(this);
        }
        // Clean up references to private properties and other
        // instances. preserve reference to _data so that proxy
        // accessors still work. The only potential side effect
        // here is that mutating the instance after it's destroyed
        // may affect the state of other components that are still
        // observing the same object, but that seems to be a
        // reasonable responsibility for the user rather than
        // always throwing an error on them.
        this.$el = this.$parent = this.$root = this.$children = this._watchers = this._context = this._scope = this._directives = null;
        // call the last hook...
        this._isDestroyed = true;
        this._callHook('destroyed');
        // turn off all instance listeners.
        this.$off();
      };
    }
    
    function miscMixin (Vue) {
    
      /**
       * Apply a list of filter (descriptors) to a value.
       * Using plain for loops here because this will be called in
       * the getter of any watcher with filters so it is very
       * performance sensitive.
       *
       * @param {*} value
       * @param {*} [oldValue]
       * @param {Array} filters
       * @param {Boolean} write
       * @return {*}
       */
    
      Vue.prototype._applyFilters = function (value, oldValue, filters, write) {
        var filter, fn, args, arg, offset, i, l, j, k;
        for (i = 0, l = filters.length; i < l; i++) {
          filter = filters[i];
          fn = resolveAsset(this.$options, 'filters', filter.name);
          if (process.env.NODE_ENV !== 'production') {
            assertAsset(fn, 'filter', filter.name);
          }
          if (!fn) continue;
          fn = write ? fn.write : fn.read || fn;
          if (typeof fn !== 'function') continue;
          args = write ? [value, oldValue] : [value];
          offset = write ? 2 : 1;
          if (filter.args) {
            for (j = 0, k = filter.args.length; j < k; j++) {
              arg = filter.args[j];
              args[j + offset] = arg.dynamic ? this.$get(arg.value) : arg.value;
            }
          }
          value = fn.apply(this, args);
        }
        return value;
      };
    
      /**
       * Resolve a component, depending on whether the component
       * is defined normally or using an async factory function.
       * Resolves synchronously if already resolved, otherwise
       * resolves asynchronously and caches the resolved
       * constructor on the factory.
       *
       * @param {String} id
       * @param {Function} cb
       */
    
      Vue.prototype._resolveComponent = function (id, cb) {
        var factory = resolveAsset(this.$options, 'components', id);
        if (process.env.NODE_ENV !== 'production') {
          assertAsset(factory, 'component', id);
        }
        if (!factory) {
          return;
        }
        // async component factory
        if (!factory.options) {
          if (factory.resolved) {
            // cached
            cb(factory.resolved);
          } else if (factory.requested) {
            // pool callbacks
            factory.pendingCallbacks.push(cb);
          } else {
            factory.requested = true;
            var cbs = factory.pendingCallbacks = [cb];
            factory(function resolve(res) {
              if (isPlainObject(res)) {
                res = Vue.extend(res);
              }
              // cache resolved
              factory.resolved = res;
              // invoke callbacks
              for (var i = 0, l = cbs.length; i < l; i++) {
                cbs[i](res);
              }
            }, function reject(reason) {
              process.env.NODE_ENV !== 'production' && warn('Failed to resolve async component: ' + id + '. ' + (reason ? '\nReason: ' + reason : ''));
            });
          }
        } else {
          // normal component
          cb(factory);
        }
      };
    }
    
    function globalAPI (Vue) {
    
      /**
       * Expose useful internals
       */
    
      Vue.util = util;
      Vue.config = config;
      Vue.set = set;
      Vue['delete'] = del;
      Vue.nextTick = nextTick;
    
      /**
       * The following are exposed for advanced usage / plugins
       */
    
      Vue.compiler = compiler;
      Vue.FragmentFactory = FragmentFactory;
      Vue.internalDirectives = internalDirectives;
      Vue.parsers = {
        path: path,
        text: text$1,
        template: template,
        directive: directive,
        expression: expression
      };
    
      /**
       * Each instance constructor, including Vue, has a unique
       * cid. This enables us to create wrapped "child
       * constructors" for prototypal inheritance and cache them.
       */
    
      Vue.cid = 0;
      var cid = 1;
    
      /**
       * Class inheritance
       *
       * @param {Object} extendOptions
       */
    
      Vue.extend = function (extendOptions) {
        extendOptions = extendOptions || {};
        var Super = this;
        var isFirstExtend = Super.cid === 0;
        if (isFirstExtend && extendOptions._Ctor) {
          return extendOptions._Ctor;
        }
        var name = extendOptions.name || Super.options.name;
        if (process.env.NODE_ENV !== 'production') {
          if (!/^[a-zA-Z][\w-]*$/.test(name)) {
            warn('Invalid component name: "' + name + '". Component names ' + 'can only contain alphanumeric characaters and the hyphen.');
            name = null;
          }
        }
        var Sub = createClass(name || 'VueComponent');
        Sub.prototype = Object.create(Super.prototype);
        Sub.prototype.constructor = Sub;
        Sub.cid = cid++;
        Sub.options = mergeOptions(Super.options, extendOptions);
        Sub['super'] = Super;
        // allow further extension
        Sub.extend = Super.extend;
        // create asset registers, so extended classes
        // can have their private assets too.
        config._assetTypes.forEach(function (type) {
          Sub[type] = Super[type];
        });
        // enable recursive self-lookup
        if (name) {
          Sub.options.components[name] = Sub;
        }
        // cache constructor
        if (isFirstExtend) {
          extendOptions._Ctor = Sub;
        }
        return Sub;
      };
    
      /**
       * A function that returns a sub-class constructor with the
       * given name. This gives us much nicer output when
       * logging instances in the console.
       *
       * @param {String} name
       * @return {Function}
       */
    
      function createClass(name) {
        return new Function('return function ' + classify(name) + ' (options) { this._init(options) }')();
      }
    
      /**
       * Plugin system
       *
       * @param {Object} plugin
       */
    
      Vue.use = function (plugin) {
        /* istanbul ignore if */
        if (plugin.installed) {
          return;
        }
        // additional parameters
        var args = toArray(arguments, 1);
        args.unshift(this);
        if (typeof plugin.install === 'function') {
          plugin.install.apply(plugin, args);
        } else {
          plugin.apply(null, args);
        }
        plugin.installed = true;
        return this;
      };
    
      /**
       * Apply a global mixin by merging it into the default
       * options.
       */
    
      Vue.mixin = function (mixin) {
        Vue.options = mergeOptions(Vue.options, mixin);
      };
    
      /**
       * Create asset registration methods with the following
       * signature:
       *
       * @param {String} id
       * @param {*} definition
       */
    
      config._assetTypes.forEach(function (type) {
        Vue[type] = function (id, definition) {
          if (!definition) {
            return this.options[type + 's'][id];
          } else {
            /* istanbul ignore if */
            if (process.env.NODE_ENV !== 'production') {
              if (type === 'component' && (commonTagRE.test(id) || reservedTagRE.test(id))) {
                warn('Do not use built-in or reserved HTML elements as component ' + 'id: ' + id);
              }
            }
            if (type === 'component' && isPlainObject(definition)) {
              definition.name = id;
              definition = Vue.extend(definition);
            }
            this.options[type + 's'][id] = definition;
            return definition;
          }
        };
      });
    }
    
    var filterRE = /[^|]\|[^|]/;
    
    function dataAPI (Vue) {
    
      /**
       * Get the value from an expression on this vm.
       *
       * @param {String} exp
       * @param {Boolean} [asStatement]
       * @return {*}
       */
    
      Vue.prototype.$get = function (exp, asStatement) {
        var res = parseExpression(exp);
        if (res) {
          if (asStatement && !isSimplePath(exp)) {
            var self = this;
            return function statementHandler() {
              self.$arguments = toArray(arguments);
              var result = res.get.call(self, self);
              self.$arguments = null;
              return result;
            };
          } else {
            try {
              return res.get.call(this, this);
            } catch (e) {}
          }
        }
      };
    
      /**
       * Set the value from an expression on this vm.
       * The expression must be a valid left-hand
       * expression in an assignment.
       *
       * @param {String} exp
       * @param {*} val
       */
    
      Vue.prototype.$set = function (exp, val) {
        var res = parseExpression(exp, true);
        if (res && res.set) {
          res.set.call(this, this, val);
        }
      };
    
      /**
       * Delete a property on the VM
       *
       * @param {String} key
       */
    
      Vue.prototype.$delete = function (key) {
        del(this._data, key);
      };
    
      /**
       * Watch an expression, trigger callback when its
       * value changes.
       *
       * @param {String|Function} expOrFn
       * @param {Function} cb
       * @param {Object} [options]
       *                 - {Boolean} deep
       *                 - {Boolean} immediate
       * @return {Function} - unwatchFn
       */
    
      Vue.prototype.$watch = function (expOrFn, cb, options) {
        var vm = this;
        var parsed;
        if (typeof expOrFn === 'string') {
          parsed = parseDirective(expOrFn);
          expOrFn = parsed.expression;
        }
        var watcher = new Watcher(vm, expOrFn, cb, {
          deep: options && options.deep,
          sync: options && options.sync,
          filters: parsed && parsed.filters,
          user: !options || options.user !== false
        });
        if (options && options.immediate) {
          cb.call(vm, watcher.value);
        }
        return function unwatchFn() {
          watcher.teardown();
        };
      };
    
      /**
       * Evaluate a text directive, including filters.
       *
       * @param {String} text
       * @param {Boolean} [asStatement]
       * @return {String}
       */
    
      Vue.prototype.$eval = function (text, asStatement) {
        // check for filters.
        if (filterRE.test(text)) {
          var dir = parseDirective(text);
          // the filter regex check might give false positive
          // for pipes inside strings, so it's possible that
          // we don't get any filters here
          var val = this.$get(dir.expression, asStatement);
          return dir.filters ? this._applyFilters(val, null, dir.filters) : val;
        } else {
          // no filter
          return this.$get(text, asStatement);
        }
      };
    
      /**
       * Interpolate a piece of template text.
       *
       * @param {String} text
       * @return {String}
       */
    
      Vue.prototype.$interpolate = function (text) {
        var tokens = parseText(text);
        var vm = this;
        if (tokens) {
          if (tokens.length === 1) {
            return vm.$eval(tokens[0].value) + '';
          } else {
            return tokens.map(function (token) {
              return token.tag ? vm.$eval(token.value) : token.value;
            }).join('');
          }
        } else {
          return text;
        }
      };
    
      /**
       * Log instance data as a plain JS object
       * so that it is easier to inspect in console.
       * This method assumes console is available.
       *
       * @param {String} [path]
       */
    
      Vue.prototype.$log = function (path) {
        var data = path ? getPath(this._data, path) : this._data;
        if (data) {
          data = clean(data);
        }
        // include computed fields
        if (!path) {
          for (var key in this.$options.computed) {
            data[key] = clean(this[key]);
          }
        }
        console.log(data);
      };
    
      /**
       * "clean" a getter/setter converted object into a plain
       * object copy.
       *
       * @param {Object} - obj
       * @return {Object}
       */
    
      function clean(obj) {
        return JSON.parse(JSON.stringify(obj));
      }
    }
    
    function domAPI (Vue) {
    
      /**
       * Convenience on-instance nextTick. The callback is
       * auto-bound to the instance, and this avoids component
       * modules having to rely on the global Vue.
       *
       * @param {Function} fn
       */
    
      Vue.prototype.$nextTick = function (fn) {
        nextTick(fn, this);
      };
    
      /**
       * Append instance to target
       *
       * @param {Node} target
       * @param {Function} [cb]
       * @param {Boolean} [withTransition] - defaults to true
       */
    
      Vue.prototype.$appendTo = function (target, cb, withTransition) {
        return insert(this, target, cb, withTransition, append, appendWithTransition);
      };
    
      /**
       * Prepend instance to target
       *
       * @param {Node} target
       * @param {Function} [cb]
       * @param {Boolean} [withTransition] - defaults to true
       */
    
      Vue.prototype.$prependTo = function (target, cb, withTransition) {
        target = query(target);
        if (target.hasChildNodes()) {
          this.$before(target.firstChild, cb, withTransition);
        } else {
          this.$appendTo(target, cb, withTransition);
        }
        return this;
      };
    
      /**
       * Insert instance before target
       *
       * @param {Node} target
       * @param {Function} [cb]
       * @param {Boolean} [withTransition] - defaults to true
       */
    
      Vue.prototype.$before = function (target, cb, withTransition) {
        return insert(this, target, cb, withTransition, beforeWithCb, beforeWithTransition);
      };
    
      /**
       * Insert instance after target
       *
       * @param {Node} target
       * @param {Function} [cb]
       * @param {Boolean} [withTransition] - defaults to true
       */
    
      Vue.prototype.$after = function (target, cb, withTransition) {
        target = query(target);
        if (target.nextSibling) {
          this.$before(target.nextSibling, cb, withTransition);
        } else {
          this.$appendTo(target.parentNode, cb, withTransition);
        }
        return this;
      };
    
      /**
       * Remove instance from DOM
       *
       * @param {Function} [cb]
       * @param {Boolean} [withTransition] - defaults to true
       */
    
      Vue.prototype.$remove = function (cb, withTransition) {
        if (!this.$el.parentNode) {
          return cb && cb();
        }
        var inDocument = this._isAttached && inDoc(this.$el);
        // if we are not in document, no need to check
        // for transitions
        if (!inDocument) withTransition = false;
        var self = this;
        var realCb = function realCb() {
          if (inDocument) self._callHook('detached');
          if (cb) cb();
        };
        if (this._isFragment) {
          removeNodeRange(this._fragmentStart, this._fragmentEnd, this, this._fragment, realCb);
        } else {
          var op = withTransition === false ? removeWithCb : removeWithTransition;
          op(this.$el, this, realCb);
        }
        return this;
      };
    
      /**
       * Shared DOM insertion function.
       *
       * @param {Vue} vm
       * @param {Element} target
       * @param {Function} [cb]
       * @param {Boolean} [withTransition]
       * @param {Function} op1 - op for non-transition insert
       * @param {Function} op2 - op for transition insert
       * @return vm
       */
    
      function insert(vm, target, cb, withTransition, op1, op2) {
        target = query(target);
        var targetIsDetached = !inDoc(target);
        var op = withTransition === false || targetIsDetached ? op1 : op2;
        var shouldCallHook = !targetIsDetached && !vm._isAttached && !inDoc(vm.$el);
        if (vm._isFragment) {
          mapNodeRange(vm._fragmentStart, vm._fragmentEnd, function (node) {
            op(node, target, vm);
          });
          cb && cb();
        } else {
          op(vm.$el, target, vm, cb);
        }
        if (shouldCallHook) {
          vm._callHook('attached');
        }
        return vm;
      }
    
      /**
       * Check for selectors
       *
       * @param {String|Element} el
       */
    
      function query(el) {
        return typeof el === 'string' ? document.querySelector(el) : el;
      }
    
      /**
       * Append operation that takes a callback.
       *
       * @param {Node} el
       * @param {Node} target
       * @param {Vue} vm - unused
       * @param {Function} [cb]
       */
    
      function append(el, target, vm, cb) {
        target.appendChild(el);
        if (cb) cb();
      }
    
      /**
       * InsertBefore operation that takes a callback.
       *
       * @param {Node} el
       * @param {Node} target
       * @param {Vue} vm - unused
       * @param {Function} [cb]
       */
    
      function beforeWithCb(el, target, vm, cb) {
        before(el, target);
        if (cb) cb();
      }
    
      /**
       * Remove operation that takes a callback.
       *
       * @param {Node} el
       * @param {Vue} vm - unused
       * @param {Function} [cb]
       */
    
      function removeWithCb(el, vm, cb) {
        remove(el);
        if (cb) cb();
      }
    }
    
    function eventsAPI (Vue) {
    
      /**
       * Listen on the given `event` with `fn`.
       *
       * @param {String} event
       * @param {Function} fn
       */
    
      Vue.prototype.$on = function (event, fn) {
        (this._events[event] || (this._events[event] = [])).push(fn);
        modifyListenerCount(this, event, 1);
        return this;
      };
    
      /**
       * Adds an `event` listener that will be invoked a single
       * time then automatically removed.
       *
       * @param {String} event
       * @param {Function} fn
       */
    
      Vue.prototype.$once = function (event, fn) {
        var self = this;
        function on() {
          self.$off(event, on);
          fn.apply(this, arguments);
        }
        on.fn = fn;
        this.$on(event, on);
        return this;
      };
    
      /**
       * Remove the given callback for `event` or all
       * registered callbacks.
       *
       * @param {String} event
       * @param {Function} fn
       */
    
      Vue.prototype.$off = function (event, fn) {
        var cbs;
        // all
        if (!arguments.length) {
          if (this.$parent) {
            for (event in this._events) {
              cbs = this._events[event];
              if (cbs) {
                modifyListenerCount(this, event, -cbs.length);
              }
            }
          }
          this._events = {};
          return this;
        }
        // specific event
        cbs = this._events[event];
        if (!cbs) {
          return this;
        }
        if (arguments.length === 1) {
          modifyListenerCount(this, event, -cbs.length);
          this._events[event] = null;
          return this;
        }
        // specific handler
        var cb;
        var i = cbs.length;
        while (i--) {
          cb = cbs[i];
          if (cb === fn || cb.fn === fn) {
            modifyListenerCount(this, event, -1);
            cbs.splice(i, 1);
            break;
          }
        }
        return this;
      };
    
      /**
       * Trigger an event on self.
       *
       * @param {String|Object} event
       * @return {Boolean} shouldPropagate
       */
    
      Vue.prototype.$emit = function (event) {
        var isSource = typeof event === 'string';
        event = isSource ? event : event.name;
        var cbs = this._events[event];
        var shouldPropagate = isSource || !cbs;
        if (cbs) {
          cbs = cbs.length > 1 ? toArray(cbs) : cbs;
          // this is a somewhat hacky solution to the question raised
          // in #2102: for an inline component listener like <comp @test="doThis">,
          // the propagation handling is somewhat broken. Therefore we
          // need to treat these inline callbacks differently.
          var hasParentCbs = isSource && cbs.some(function (cb) {
            return cb._fromParent;
          });
          if (hasParentCbs) {
            shouldPropagate = false;
          }
          var args = toArray(arguments, 1);
          for (var i = 0, l = cbs.length; i < l; i++) {
            var cb = cbs[i];
            var res = cb.apply(this, args);
            if (res === true && (!hasParentCbs || cb._fromParent)) {
              shouldPropagate = true;
            }
          }
        }
        return shouldPropagate;
      };
    
      /**
       * Recursively broadcast an event to all children instances.
       *
       * @param {String|Object} event
       * @param {...*} additional arguments
       */
    
      Vue.prototype.$broadcast = function (event) {
        var isSource = typeof event === 'string';
        event = isSource ? event : event.name;
        // if no child has registered for this event,
        // then there's no need to broadcast.
        if (!this._eventsCount[event]) return;
        var children = this.$children;
        var args = toArray(arguments);
        if (isSource) {
          // use object event to indicate non-source emit
          // on children
          args[0] = { name: event, source: this };
        }
        for (var i = 0, l = children.length; i < l; i++) {
          var child = children[i];
          var shouldPropagate = child.$emit.apply(child, args);
          if (shouldPropagate) {
            child.$broadcast.apply(child, args);
          }
        }
        return this;
      };
    
      /**
       * Recursively propagate an event up the parent chain.
       *
       * @param {String} event
       * @param {...*} additional arguments
       */
    
      Vue.prototype.$dispatch = function (event) {
        var shouldPropagate = this.$emit.apply(this, arguments);
        if (!shouldPropagate) return;
        var parent = this.$parent;
        var args = toArray(arguments);
        // use object event to indicate non-source emit
        // on parents
        args[0] = { name: event, source: this };
        while (parent) {
          shouldPropagate = parent.$emit.apply(parent, args);
          parent = shouldPropagate ? parent.$parent : null;
        }
        return this;
      };
    
      /**
       * Modify the listener counts on all parents.
       * This bookkeeping allows $broadcast to return early when
       * no child has listened to a certain event.
       *
       * @param {Vue} vm
       * @param {String} event
       * @param {Number} count
       */
    
      var hookRE = /^hook:/;
      function modifyListenerCount(vm, event, count) {
        var parent = vm.$parent;
        // hooks do not get broadcasted so no need
        // to do bookkeeping for them
        if (!parent || !count || hookRE.test(event)) return;
        while (parent) {
          parent._eventsCount[event] = (parent._eventsCount[event] || 0) + count;
          parent = parent.$parent;
        }
      }
    }
    
    function lifecycleAPI (Vue) {
    
      /**
       * Set instance target element and kick off the compilation
       * process. The passed in `el` can be a selector string, an
       * existing Element, or a DocumentFragment (for block
       * instances).
       *
       * @param {Element|DocumentFragment|string} el
       * @public
       */
    
      Vue.prototype.$mount = function (el) {
        if (this._isCompiled) {
          process.env.NODE_ENV !== 'production' && warn('$mount() should be called only once.');
          return;
        }
        el = query(el);
        if (!el) {
          el = document.createElement('div');
        }
        this._compile(el);
        this._initDOMHooks();
        if (inDoc(this.$el)) {
          this._callHook('attached');
          ready.call(this);
        } else {
          this.$once('hook:attached', ready);
        }
        return this;
      };
    
      /**
       * Mark an instance as ready.
       */
    
      function ready() {
        this._isAttached = true;
        this._isReady = true;
        this._callHook('ready');
      }
    
      /**
       * Teardown the instance, simply delegate to the internal
       * _destroy.
       */
    
      Vue.prototype.$destroy = function (remove, deferCleanup) {
        this._destroy(remove, deferCleanup);
      };
    
      /**
       * Partially compile a piece of DOM and return a
       * decompile function.
       *
       * @param {Element|DocumentFragment} el
       * @param {Vue} [host]
       * @return {Function}
       */
    
      Vue.prototype.$compile = function (el, host, scope, frag) {
        return compile(el, this.$options, true)(this, el, host, scope, frag);
      };
    }
    
    /**
     * The exposed Vue constructor.
     *
     * API conventions:
     * - public API methods/properties are prefixed with `$`
     * - internal methods/properties are prefixed with `_`
     * - non-prefixed properties are assumed to be proxied user
     *   data.
     *
     * @constructor
     * @param {Object} [options]
     * @public
     */
    
    function Vue(options) {
      this._init(options);
    }
    
    // install internals
    initMixin(Vue);
    stateMixin(Vue);
    eventsMixin(Vue);
    lifecycleMixin(Vue);
    miscMixin(Vue);
    
    // install APIs
    globalAPI(Vue);
    dataAPI(Vue);
    domAPI(Vue);
    eventsAPI(Vue);
    lifecycleAPI(Vue);
    
    var convertArray = vFor._postProcess;
    
    /**
     * Limit filter for arrays
     *
     * @param {Number} n
     * @param {Number} offset (Decimal expected)
     */
    
    function limitBy(arr, n, offset) {
      offset = offset ? parseInt(offset, 10) : 0;
      n = toNumber(n);
      return typeof n === 'number' ? arr.slice(offset, offset + n) : arr;
    }
    
    /**
     * Filter filter for arrays
     *
     * @param {String} search
     * @param {String} [delimiter]
     * @param {String} ...dataKeys
     */
    
    function filterBy(arr, search, delimiter) {
      arr = convertArray(arr);
      if (search == null) {
        return arr;
      }
      if (typeof search === 'function') {
        return arr.filter(search);
      }
      // cast to lowercase string
      search = ('' + search).toLowerCase();
      // allow optional `in` delimiter
      // because why not
      var n = delimiter === 'in' ? 3 : 2;
      // extract and flatten keys
      var keys = toArray(arguments, n).reduce(function (prev, cur) {
        return prev.concat(cur);
      }, []);
      var res = [];
      var item, key, val, j;
      for (var i = 0, l = arr.length; i < l; i++) {
        item = arr[i];
        val = item && item.$value || item;
        j = keys.length;
        if (j) {
          while (j--) {
            key = keys[j];
            if (key === '$key' && contains(item.$key, search) || contains(getPath(val, key), search)) {
              res.push(item);
              break;
            }
          }
        } else if (contains(item, search)) {
          res.push(item);
        }
      }
      return res;
    }
    
    /**
     * Filter filter for arrays
     *
     * @param {String} sortKey
     * @param {String} reverse
     */
    
    function orderBy(arr, sortKey, reverse) {
      arr = convertArray(arr);
      if (!sortKey) {
        return arr;
      }
      var order = reverse && reverse < 0 ? -1 : 1;
      // sort on a copy to avoid mutating original array
      return arr.slice().sort(function (a, b) {
        if (sortKey !== '$key') {
          if (isObject(a) && '$value' in a) a = a.$value;
          if (isObject(b) && '$value' in b) b = b.$value;
        }
        a = isObject(a) ? getPath(a, sortKey) : a;
        b = isObject(b) ? getPath(b, sortKey) : b;
        return a === b ? 0 : a > b ? order : -order;
      });
    }
    
    /**
     * String contain helper
     *
     * @param {*} val
     * @param {String} search
     */
    
    function contains(val, search) {
      var i;
      if (isPlainObject(val)) {
        var keys = Object.keys(val);
        i = keys.length;
        while (i--) {
          if (contains(val[keys[i]], search)) {
            return true;
          }
        }
      } else if (isArray(val)) {
        i = val.length;
        while (i--) {
          if (contains(val[i], search)) {
            return true;
          }
        }
      } else if (val != null) {
        return val.toString().toLowerCase().indexOf(search) > -1;
      }
    }
    
    var digitsRE = /(\d{3})(?=\d)/g;
    
    // asset collections must be a plain object.
    var filters = {
    
      orderBy: orderBy,
      filterBy: filterBy,
      limitBy: limitBy,
    
      /**
       * Stringify value.
       *
       * @param {Number} indent
       */
    
      json: {
        read: function read(value, indent) {
          return typeof value === 'string' ? value : JSON.stringify(value, null, Number(indent) || 2);
        },
        write: function write(value) {
          try {
            return JSON.parse(value);
          } catch (e) {
            return value;
          }
        }
      },
    
      /**
       * 'abc' => 'Abc'
       */
    
      capitalize: function capitalize(value) {
        if (!value && value !== 0) return '';
        value = value.toString();
        return value.charAt(0).toUpperCase() + value.slice(1);
      },
    
      /**
       * 'abc' => 'ABC'
       */
    
      uppercase: function uppercase(value) {
        return value || value === 0 ? value.toString().toUpperCase() : '';
      },
    
      /**
       * 'AbC' => 'abc'
       */
    
      lowercase: function lowercase(value) {
        return value || value === 0 ? value.toString().toLowerCase() : '';
      },
    
      /**
       * 12345 => $12,345.00
       *
       * @param {String} sign
       */
    
      currency: function currency(value, _currency) {
        value = parseFloat(value);
        if (!isFinite(value) || !value && value !== 0) return '';
        _currency = _currency != null ? _currency : '$';
        var stringified = Math.abs(value).toFixed(2);
        var _int = stringified.slice(0, -3);
        var i = _int.length % 3;
        var head = i > 0 ? _int.slice(0, i) + (_int.length > 3 ? ',' : '') : '';
        var _float = stringified.slice(-3);
        var sign = value < 0 ? '-' : '';
        return _currency + sign + head + _int.slice(i).replace(digitsRE, '$1,') + _float;
      },
    
      /**
       * 'item' => 'items'
       *
       * @params
       *  an array of strings corresponding to
       *  the single, double, triple ... forms of the word to
       *  be pluralized. When the number to be pluralized
       *  exceeds the length of the args, it will use the last
       *  entry in the array.
       *
       *  e.g. ['single', 'double', 'triple', 'multiple']
       */
    
      pluralize: function pluralize(value) {
        var args = toArray(arguments, 1);
        return args.length > 1 ? args[value % 10 - 1] || args[args.length - 1] : args[0] + (value === 1 ? '' : 's');
      },
    
      /**
       * Debounce a handler function.
       *
       * @param {Function} handler
       * @param {Number} delay = 300
       * @return {Function}
       */
    
      debounce: function debounce(handler, delay) {
        if (!handler) return;
        if (!delay) {
          delay = 300;
        }
        return _debounce(handler, delay);
      }
    };
    
    var partial = {
    
      priority: PARTIAL,
    
      params: ['name'],
    
      // watch changes to name for dynamic partials
      paramWatchers: {
        name: function name(value) {
          vIf.remove.call(this);
          if (value) {
            this.insert(value);
          }
        }
      },
    
      bind: function bind() {
        this.anchor = createAnchor('v-partial');
        replace(this.el, this.anchor);
        this.insert(this.params.name);
      },
    
      insert: function insert(id) {
        var partial = resolveAsset(this.vm.$options, 'partials', id);
        if (process.env.NODE_ENV !== 'production') {
          assertAsset(partial, 'partial', id);
        }
        if (partial) {
          this.factory = new FragmentFactory(this.vm, partial);
          vIf.insert.call(this);
        }
      },
    
      unbind: function unbind() {
        if (this.frag) {
          this.frag.destroy();
        }
      }
    };
    
    // This is the elementDirective that handles <content>
    // transclusions. It relies on the raw content of an
    // instance being stored as `$options._content` during
    // the transclude phase.
    
    // We are exporting two versions, one for named and one
    // for unnamed, because the unnamed slots must be compiled
    // AFTER all named slots have selected their content. So
    // we need to give them different priorities in the compilation
    // process. (See #1965)
    
    var slot = {
    
      priority: SLOT,
    
      bind: function bind() {
        var host = this.vm;
        var raw = host.$options._content;
        if (!raw) {
          this.fallback();
          return;
        }
        var context = host._context;
        var slotName = this.params && this.params.name;
        if (!slotName) {
          // Default slot
          this.tryCompile(extractFragment(raw.childNodes, raw, true), context, host);
        } else {
          // Named slot
          var selector = '[slot="' + slotName + '"]';
          var nodes = raw.querySelectorAll(selector);
          if (nodes.length) {
            this.tryCompile(extractFragment(nodes, raw), context, host);
          } else {
            this.fallback();
          }
        }
      },
    
      tryCompile: function tryCompile(content, context, host) {
        if (content.hasChildNodes()) {
          this.compile(content, context, host);
        } else {
          this.fallback();
        }
      },
    
      compile: function compile(content, context, host) {
        if (content && context) {
          if (this.el.hasChildNodes() && content.childNodes.length === 1 && content.childNodes[0].nodeType === 1 && content.childNodes[0].hasAttribute('v-if')) {
            // if the inserted slot has v-if
            // inject fallback content as the v-else
            var elseBlock = document.createElement('template');
            elseBlock.setAttribute('v-else', '');
            elseBlock.innerHTML = this.el.innerHTML;
            content.appendChild(elseBlock);
          }
          var scope = host ? host._scope : this._scope;
          this.unlink = context.$compile(content, host, scope, this._frag);
        }
        if (content) {
          replace(this.el, content);
        } else {
          remove(this.el);
        }
      },
    
      fallback: function fallback() {
        this.compile(extractContent(this.el, true), this.vm);
      },
    
      unbind: function unbind() {
        if (this.unlink) {
          this.unlink();
        }
      }
    };
    
    var namedSlot = extend(extend({}, slot), {
      priority: slot.priority + 1,
      params: ['name']
    });
    
    /**
     * Extract qualified content nodes from a node list.
     *
     * @param {NodeList} nodes
     * @param {Element} parent
     * @param {Boolean} main
     * @return {DocumentFragment}
     */
    
    function extractFragment(nodes, parent, main) {
      var frag = document.createDocumentFragment();
      for (var i = 0, l = nodes.length; i < l; i++) {
        var node = nodes[i];
        // if this is the main outlet, we want to skip all
        // previously selected nodes;
        // otherwise, we want to mark the node as selected.
        // clone the node so the original raw content remains
        // intact. this ensures proper re-compilation in cases
        // where the outlet is inside a conditional block
        if (main && !node.__v_selected) {
          append(node);
        } else if (!main && node.parentNode === parent) {
          node.__v_selected = true;
          append(node);
        }
      }
      return frag;
    
      function append(node) {
        if (isTemplate(node) && !node.hasAttribute('v-if') && !node.hasAttribute('v-for')) {
          node = parseTemplate(node);
        }
        node = cloneNode(node);
        frag.appendChild(node);
      }
    }
    
    var elementDirectives = {
      slot: slot,
      _namedSlot: namedSlot, // same as slot but with higher priority
      partial: partial
    };
    
    Vue.version = '1.0.16';
    
    /**
     * Vue and every constructor that extends Vue has an
     * associated options object, which can be accessed during
     * compilation steps as `this.constructor.options`.
     *
     * These can be seen as the default options of every
     * Vue instance.
     */
    
    Vue.options = {
      directives: publicDirectives,
      elementDirectives: elementDirectives,
      filters: filters,
      transitions: {},
      components: {},
      partials: {},
      replace: true
    };
    
    // devtools global hook
    /* istanbul ignore next */
    if (devtools) {
      devtools.emit('init', Vue);
    } else if (process.env.NODE_ENV !== 'production' && inBrowser && /Chrome\/\d+/.test(navigator.userAgent)) {
      console.log('Download the Vue Devtools for a better development experience:\n' + 'https://github.com/vuejs/vue-devtools');
    }
    
    module.exports = Vue;
  provide("vue", module.exports);
}(global));

// pakmanager:vue-animate-css/bootstrap
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /**
     * Created by ryanchan on 25/2/2016.
     */
    
    if (window.$ === undefined || window.jQuery === undefined) {
      window.$ = window.jQuery = require('jquery');
    }
  provide("vue-animate-css/bootstrap", module.exports);
}(global));

// pakmanager:vue-animate-css/transitions
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /**
     * Created by ryanchan on 25/2/2016.
     */
    
    var animations = [
      'bounce',
      'flash',
      'pulse',
      'rubberBand',
      'shake',
      'headShake',
      'swing',
      'tada',
      'wobble',
      'jello',
      'bounceIn',
      'bounceInDown',
      'bounceInLeft',
      'bounceInRight',
      'bounceInUp',
      'bounceOut',
      'bounceOutDown',
      'bounceOutLeft',
      'bounceOutRight',
      'bounceOutUp',
      'fadeIn',
      'fadeInDown',
      'fadeInDownBig',
      'fadeInLeft',
      'fadeInLeftBig',
      'fadeInRight',
      'fadeInRightBig',
      'fadeInUp',
      'fadeInUpBig',
      'fadeOut',
      'fadeOutDown',
      'fadeOutDownBig',
      'fadeOutLeft',
      'fadeOutLeftBig',
      'fadeOutRight',
      'fadeOutRightBig',
      'fadeOutUp',
      'fadeOutUpBig',
      'flipInX',
      'flipInY',
      'flipOutX',
      'flipOutY',
      'lightSpeedIn',
      'lightSpeedOut',
      'rotateIn',
      'rotateInDownLeft',
      'rotateInDownRight',
      'rotateInUpLeft',
      'rotateInUpRight',
      'rotateOut',
      'rotateOutDownLeft',
      'rotateOutDownRight',
      'rotateOutUpLeft',
      'rotateOutUpRight',
      'hinge',
      'rollIn',
      'rollOut',
      'zoomIn',
      'zoomInDown',
      'zoomInLeft',
      'zoomInRight',
      'zoomInUp',
      'zoomOut',
      'zoomOutDown',
      'zoomOutLeft',
      'zoomOutRight',
      'zoomOutUp',
      'slideInDown',
      'slideInLeft',
      'slideInRight',
      'slideInUp',
      'slideOutDown',
      'slideOutLeft',
      'slideOutRight',
      'slideOutUp'
    ];
    
    animations.forEach(function (inAnimation) {
      animations.forEach(function (outAnimation) {
        Vue.transition(inAnimation + '-' + outAnimation, {
          enterClass: inAnimation,
          leaveClass: outAnimation
        });
      });
    });
  provide("vue-animate-css/transitions", module.exports);
}(global));

// pakmanager:vue-animate-css/directive
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /**
     * Created by ryanchan on 25/2/2016.
     */
    
    Vue.directive('animation', {
      params: ['animate', 'loop'],
    
      bind: function () {
        var self = $(this.el);
    
        if (!self.hasClass('animated')) {
          self.addClass('animated')
        }
    
        if (this.params.loop) {
          self.addClass('infinite');
        }
    
        if (this.params.animate) {
          self.addClass(this.params.animate);
        }
      }
    });
  provide("vue-animate-css/directive", module.exports);
}(global));

// pakmanager:vue-animate-css
(function (context) {
  
  var module = { exports: {} }, exports = module.exports
    , $ = require("ender")
    ;
  
  /**
     * Created by ryanchan on 25/2/2016.
     */
    
     require('vue-animate-css/bootstrap');
     require('vue-animate-css/transitions');
     require('vue-animate-css/directive');
  provide("vue-animate-css", module.exports);
}(global));